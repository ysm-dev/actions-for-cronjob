<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><description>개발자 PIGNOSE의 연구실</description><title>PIGNOSE BARN</title><generator>Tumblr (3.0; @pignose-barn)</generator><link>https://blog.pigno.se/</link><item><title>Google I/O 2019 Keynote</title><description>&lt;figure data-orig-width="3164" data-orig-height="1614" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/3b60bdda244f8b5ad40a4f3de0b1df1a/tumblr_inline_pr5kmr02US1td93ol_540.png" alt="image" data-orig-width="3164" data-orig-height="1614"/&gt;&lt;/figure&gt;&lt;p&gt;Google I/O 2019가 미국 현지 시간 5월 7일 9시 20분부터 키노트를 시작으로 본격적인 행사가 진행되고 있다. 서두는 AI와 실제 DJ 인간(?)의 콜라보레이션으로 꽤 멋진 디제잉을 보여주는데 흥이 돋아 수 많은 사람들이 무대 앞으로 나가 파티를 즐기는 분위기다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;필자는 Google I/O 2019가 열린 샌프란시스코에 운좋게 참여할 기회가 생겨 키노트 및 각 세션의 주요 사항을 정리하여 공유하고자 한다. 지금 현장에서 작성되고 있는 블로그 포스트이다 보니 굉장히 러프하게 포스트 내용이 채워 진 후 저녁에 재 정리를 하는 형식으로 포스트 정리가 이루어지는 점 양해 부탁드린다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;- Google I/O 2019 키노트 주요 사항&lt;/p&gt;&lt;p&gt;- Google I/O 2019 키노트 세부 사항&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;!-- more --&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;Google I/O 2019 Keynote Highlights&lt;/h2&gt;&lt;figure data-orig-width="960" data-orig-height="720" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/e68bcf24ee5fde3ef90d02f2c509f290/tumblr_inline_pr6uwkN5Iz1td93ol_540.png" alt="image" data-orig-width="960" data-orig-height="720"/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;다음은 키노트에서 필자가 생각하는 주요 사항이다.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;개인화 (Personalize)&lt;/li&gt;&lt;li&gt;개인정보와 보안 (Privacy &amp;amp; Security)&lt;/li&gt;&lt;li&gt;머신러닝과 인공지능 (ML &amp;amp; AI)&lt;/li&gt;&lt;li&gt;증강현실 (AR)&lt;/li&gt;&lt;li&gt;핸즈프리 (Handsfree)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;&lt;br/&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;구글 렌즈(Google Lens)&lt;/b&gt;&lt;/p&gt;&lt;figure data-orig-width="3312" data-orig-height="1604" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/354676f15d4728eec7ac67de0ff1784d/tumblr_inline_pr6v9dQ0pP1td93ol_540.png" alt="image" data-orig-width="3312" data-orig-height="1604"/&gt;&lt;/figure&gt;&lt;p&gt;구글이 가장 먼저 선보인 것은 구글 렌즈(Google Lens)의 AR 기능으로, 앞으로도 구글 내 서비스들에 여러가지 AR 기능들이 추가 될 것으로 기대된다. 키노트에서는 구글 렌즈를 이용해 물체의 사진을 찍고 그것을 내 책상, 내 방 사물과 한 공간에서 실제 물체의 생김새를 경험할 수 있도록 제공했다.&lt;/p&gt;&lt;p&gt;심지어 구글 검색에 기능을 더해 검색 된 항목을 모델로 랜더링하여 내가 있는 곳으로 AR 기술을 통해 가져와 체험해 볼 수 있는 등의 사용자 경험을 제공했다. Google I/O 2019 현장에서 직접 상어 모델을 현장 관람객과 동일한 무대에서 AR을 통해 랜더링 되는 것을 선보였고 이는 신선한 경험을 제공했다.&lt;/p&gt;&lt;p&gt;AR 제품 책임자 Aparna Chennapragada가 이 내용을 발표했고 반응은 상당히 뜨거웠다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="2874" data-orig-height="1860" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/3b0b0b135eb3292dd25c57a526a2ecf7/tumblr_inline_pr6vir9VlP1td93ol_540.png" alt="image" data-orig-width="2874" data-orig-height="1860"/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;언어 번역 기능도 공개를 했는데, 여행하는 입장에서 많이 유용할 것으로 예상되는 식당 메뉴 번역 및 검색 간편화 서비스가 구글 렌즈에 탑재되었다. 여러분이 식당에서 제공하는 메뉴를 구글 랜즈를 통해 촬영하면 각 메뉴의 내용이 색상으로 하이라이트 되어 클릭할 수 있게되고, 메뉴를 클릭할 경우 구글 맵이랑 연결되어 리뷰 및 사진을 바로 검색할 수 있는 편리한 UX가 제공되었다.&lt;/p&gt;&lt;figure data-orig-width="3304" data-orig-height="1480" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/d58ed5414b888fb83e4ad232a1146794/tumblr_inline_pr6vm9fNNm1td93ol_540.png" alt="image" data-orig-width="3304" data-orig-height="1480"/&gt;&lt;/figure&gt;&lt;p&gt;심지어 각 메뉴는 팁 계산기를 포함하고 있고, 더치 페이등의 산수를 간편하게 앱이 대신해줄 수 있도록 신경써 주었다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="3264" data-orig-height="1444" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/7a7d0bfff41ab96644877359772691e5/tumblr_inline_pr6vw9jdFy1td93ol_540.png" alt="image" data-orig-width="3264" data-orig-height="1444"/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Google Go&lt;/b&gt;&lt;/p&gt;&lt;figure data-orig-width="3110" data-orig-height="1508" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/ae3424b538d6db4dbc285a76e005ae79/tumblr_inline_pr6vxhnHdA1td93ol_540.png" alt="image" data-orig-width="3110" data-orig-height="1508"/&gt;&lt;/figure&gt;&lt;p&gt;구글 렌즈에 번역 기능 서비스가 추가되어 편리함을 제공한 느낌이라면 구글 고의 경우는 번역 그 자체에 집중한 서비스다. 만약 여러분이 구글 번역기를 통해 이미지 번역 (OCR)을 체험해봤다면 이미 어느정도 익숙한 사용자 경험을 가지고 있을 것이다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="1382" data-orig-height="1626" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/552a58245c8740e5272009e040289a86/tumblr_inline_pr74eh1m7V1td93ol_540.png" alt="image" data-orig-width="1382" data-orig-height="1626"/&gt;&lt;/figure&gt;&lt;p&gt;위 사진에서 보듯이 중요한 의미를 담고있는 (예전 카드를 가진 고객은 2020/1/1에 기능이 중단되니 근처 지점을 방문해서 카드를 교체하라는 문구) 포스터는 비영어권 국가에서는 그 의미를 알 수 없기 마련이다. 구글 고는 이런 서로 다른 언어를 쉽게 번역해주는 것에 집중했다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="1164" data-orig-height="1656" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/7227e3c27bfbe3ef74dd923002d72ca6/tumblr_inline_pr74jfI2wn1td93ol_540.png" alt="image" data-orig-width="1164" data-orig-height="1656"/&gt;&lt;/figure&gt;&lt;p&gt;구글 고는 번역 전 컨텍스트를 (OCR을 통해 분석 한 글자를 읽어준다.) 음성으로 읽어주는데 구글 번역기와 어떤점이 다르냐면 OCR로 분석된 글자 boundary를 highlight 해주며 순서대로 읽어준다. 생각해보자 여러분이 일본 식당에 갔는데 메뉴를 전혀 모르는 것이다. 기존 구글 번역기로 번역을 해도 어떤 단어, 글자가 어떤 음인지 모를 수 밖에 없다. 구글 고는 불러주는 단어, 문장에 하이라이트를 표기해주며 순서대로 읽어주기 때문에 어떤 단어, 문장이 어떻게 불리는지 이해할 수 있다.&lt;/p&gt;&lt;p&gt;또한 위 사진을 보면 알 수 있듯이 촬영한 이미지의 글자를 번역된 글자로 바꿔 대체해주는 기능도 포함되어있다. (이것은 번역기에 있는 기능이랑 비슷해보이는데 어떤 차이점이 있는지 모르겠다.)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Google Duplex and Assistant&lt;/b&gt;&lt;/p&gt;&lt;p&gt;구글이 작년부터 굉장히 집중하고 있는 프로젝트고 올해도 어김없이 한층 성장하고 훌륭하게 자리 잡은 에코시스템들을 소개하는 자리였다. 주요 발표 내용은 Google AI Vice President로 Assistant 팀을 이끄는 Scott B. Huffman가 발표했다.&lt;/p&gt;&lt;figure data-orig-width="2678" data-orig-height="1672" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/1e59d96b353fd0afc8f07e79658a6791/tumblr_inline_pr752nuz1j1td93ol_540.png" alt="image" data-orig-width="2678" data-orig-height="1672"/&gt;&lt;/figure&gt;&lt;p&gt;구글 어시스턴트의 가장 큰 변경점은 어시스턴트를 실행하기 위한 실행 이벤트 “Hey Google” 발화가 필요하다는 점인데, 이 부분을 제거하여 직접적인 어시스턴트 기능 실행이 가능한 듯 하다. 가장 대표적인 예시를 구글이 제시했는데 “이제 앞으로는 여러분의 알람을 끌 때 헤이 구글! 그만해! - Hey Google! Stop!라고 할 필요 없이 그만해! Stop! 이라고 외치면 된다는 내용을 조크를 담아 세션 참여자들에게 웃음을 주었다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="3352" data-orig-height="1450" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/05d3aab2ca36062fc93f9f8352e0667c/tumblr_inline_pr75ildtxE1td93ol_540.png" alt="image" data-orig-width="3352" data-orig-height="1450"/&gt;&lt;/figure&gt;&lt;figure data-orig-width="3308" data-orig-height="1466" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/a676358a8de5aa402c09718c37f19813/tumblr_inline_pr75ixKv5p1td93ol_540.png" alt="image" data-orig-width="3308" data-orig-height="1466"/&gt;&lt;/figure&gt;&lt;p&gt;컴파일러나 NLP를 조금이라도 공부해보셨으면 알겠지만 사람의 문장은 기계적으로 정해진 룰로 가득한 문장에 비해서 수 많은 이해측면에서의 어려움(Challenges)들이 존재하는데, 하나의 단어나 표현이 모든 사람에게 있어서 같은 것을 가리키지 않고 심지어 같은 사람이라도 앞뒤 문맥에 따라 그 의미가 달라질 수 있다. 이 포스트에서는 그것을 에매모호함이라고 하자.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="714" data-orig-height="515" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/b279f7af6348bf7fac7b0eaf5ee3c678/tumblr_inline_pr75pd2lFU1td93ol_540.png" alt="image" data-orig-width="714" data-orig-height="515"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;우리가 사용하는 언어는 촘스키위계의 가장 위, recursively enumerable에 해당한다.&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;만약 우리가 구글 어시스턴트에 엄마의 집으로 가는 교통 상황이 어떠냐고 물어보자. 엄마의 집은 발화자의 가족 중 엄마가 사는 집이 될 수도 있고 아니면 어떤 식당의 이름이 “엄마의 집”이 될 수도 있다. 어떤 이는 가족을 보러 가기위해 발화를 했을 것이고 음식을 즐기는 또 다른이는 엄마의 집에서 맛있는 밥을 주문하고 싶어하는 것일 수도 있다.  구글은 이러한 사용자 별 요구가 다른 것을 예전부터 충분히 인식해왔고 오늘 서비스 하나를 더 소개했다.&lt;/p&gt;&lt;figure data-orig-width="2662" data-orig-height="1600" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/1df1d06bb60d44e7fda6d82f06b180fe/tumblr_inline_pr75ipHgwZ1td93ol_540.png" alt="image" data-orig-width="2662" data-orig-height="1600"/&gt;&lt;/figure&gt;&lt;figure data-orig-width="3176" data-orig-height="1500" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/a10d8f69f4bba07d64ad26220f651d62/tumblr_inline_pr766yqEXk1td93ol_540.png" alt="image" data-orig-width="3176" data-orig-height="1500"/&gt;&lt;/figure&gt;&lt;p&gt;Picks for you라고 부르는 서비스는 개인화(Personalize)에 집중된 서비스로 한 대상과 연결된 모든 관계를 개인 참조(Personal References)로 부르고 그것을 이용해서 개인의 선호에 맞는 정보만을 모으고 이어주게 된다. &lt;/p&gt;&lt;figure data-orig-width="1164" data-orig-height="448" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/3416d8ea3510325827d84504675de4ec/tumblr_inline_pr769nDK0s1td93ol_540.png" alt="image" data-orig-width="1164" data-orig-height="448"/&gt;&lt;/figure&gt;&lt;p&gt;이렇게 하여 아들 사진 좀 보여줘!, 식당 예약좀 해줘 등의 대화에서 그 사람의 아들에 대한 정보, 지금 말하는 식당을 가리키는 참조들을 이용하여 사용자가 정말로 의도한 기능을 실행시켜주게 된다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Google Live Caption&lt;/b&gt;&lt;/p&gt;&lt;figure data-orig-width="2764" data-orig-height="1520" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/0b31eea9bb2cd8a60ccdb5a8b83a36da/tumblr_inline_pr7gnuZCw41td93ol_540.png" alt="image" data-orig-width="2764" data-orig-height="1520"/&gt;&lt;/figure&gt;&lt;p&gt;필자가 이번에 세션을 들었을 때 가장 반응이 좋았던 세션이다. 만약 여러분의 안드로이드에 돌아가는 ML 엔진의 모델이 극단적으로 경량화를 거쳐 인지하지 못할 정도로 작은 사이즈로 기존 모델에서 제공하는 모델 퍼포먼스를 제공하면 어떨까? 기존 안드로이드 음성 인지모델은 2GB로 휴대 단말기에 들어가기에는 믿기지 않을 정도로 굉장한 크기였다.&lt;/p&gt;&lt;figure data-orig-width="2734" data-orig-height="1586" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/5fb068b27b88744e25dba59be3b9612a/tumblr_inline_pr7gibPJ5w1td93ol_540.png" alt="image" data-orig-width="2734" data-orig-height="1586"/&gt;&lt;/figure&gt;&lt;p&gt;만약 인터넷이 제공되지 않는 환경에서 80MB 사이즈의 모델로 실시간 음성 인지모델을 온 디바이스에서 제공한다고 한다면 믿을 수 있을 것인가? 이미 구글은 최대한 모델의 Accuracy와 퍼포먼스를 유지하는 선에서 모델을 경량화 하여 모바일 기기에서 제공할 수 있도록 노력해오고 있다. 다만 이 음성 인지모델은 영어 발화를 기준하였기 때문에 다국가 언어가 다양하게 들리는 형태에서 지원할 수 있을지 알 수 없다. 그렇다고 해도 2GB의 모델을 80MB로 줄이는 기염을 토한 것이다.&lt;/p&gt;&lt;figure data-orig-width="2800" data-orig-height="1710" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/e0d99e99a54f86940a6a44046f2f8901/tumblr_inline_pr8y2nDiZs1td93ol_540.png" alt="image" data-orig-width="2800" data-orig-height="1710"/&gt;&lt;/figure&gt;&lt;p&gt;Live Caption은 인터넷이 제공되지 않는 제한된 환경에서도 문제 없이 실행 가능하며, 실시간으로 다른 앱에서 제공되는 오디오를 인지하여 우리가 이해할 수 있는 언어로 텍스트를 표기해주는 편리성을 가지고 있어 기대가 되고 있다.&lt;/p&gt;&lt;p&gt;&lt;b&gt;ML / AI&lt;/b&gt;&lt;/p&gt;&lt;p&gt;구글에서는 이번 키노트에서도 여러가지 ML / AI 관련 기술의 키노트를 소개하였는데 주요 사항은 아래와 같다.&lt;/p&gt;&lt;p&gt;&lt;b&gt;TCAV&lt;/b&gt;&lt;/p&gt;&lt;figure data-orig-width="2230" data-orig-height="1528" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/525ba6f0084e1a7d44bd4557bfc55044/tumblr_inline_pr7gs7XzAk1td93ol_540.png" alt="image" data-orig-width="2230" data-orig-height="1528"/&gt;&lt;/figure&gt;&lt;p&gt;TCAV(Testing with Concept Activation Vectors)는 ICML 2018에서 발표되었던 Interpretability Beyond Feature Attribution: Quantitative Testing with Concept Activation Vectors (&lt;a href="https://arxiv.org/abs/1711.11279"&gt;https://arxiv.org/abs/1711.11279&lt;/a&gt;) 논문을 바탕으로 하고 있다. 깃허브 링크는 &lt;a href="https://github.com/tensorflow/tcav"&gt;이곳으로&lt;/a&gt;.&lt;/p&gt;&lt;figure data-orig-width="1346" data-orig-height="1308" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/f8074af306af979af7b7bbeb7b95672c/tumblr_inline_pr7h8fmU2i1td93ol_540.png" alt="image" data-orig-width="1346" data-orig-height="1308"/&gt;&lt;/figure&gt;&lt;p&gt;DL을 사용하여 우리 세상에 실제하는 무언가를 분류하고 예측하는 문제에서는 그 안에 어떤 이유로 인해 결과가 예측되었는지 그 이유를 분석하는 것이 절대 쉽지 않은 문제다. 각 심층 레이어에 존재하는 Hidden Representation Layer는 가장 최저의 픽셀 패턴부터 시작해서 색상 값 그것으로 인한 가중치 값들이 적용됩니다. 우리 눈에는 그것이 무엇을 의미하는지 알 수 없다.&lt;/p&gt;&lt;p&gt;TCAV의 아이디어는 각 Logit 레이어에 미분을 가해 사람이 이해가능한 추가적인 정보를 얻어낼 수 있는 Post-training 접근 방법이다. 쉽게 설명하면 우리가 얼룩말 모델을 학습하고 그것으로 분류를 한다고 해도, 그것이 왜 얼룩말로 분류된 것인지? 반대로 왜 어떤 이미지는 얼룩말로 분류되지 않는지 정확히 알 수가 없다. 얼룩말다움이란 무엇일까? 그것을 푸는 도전이 TCAV라고 할 수 있다. 얼룩말은 일반적으로 말의 형상을 하고 얼룩을 가지고 배경이 사바나라고 알려주는 것인 셈이다. &lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Federated Learning&lt;/b&gt;&lt;/p&gt;&lt;figure data-orig-width="2438" data-orig-height="1610" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/28bb0a45d4d14f3fb843b9070049404e/tumblr_inline_pr7hgj4h3Z1td93ol_540.png" alt="image" data-orig-width="2438" data-orig-height="1610"/&gt;&lt;/figure&gt;&lt;p&gt;연합 학습(Federated Learning)은 이번 Google I/O 2019 외에 크게 거론된 기술이 아니라 필자도 더 많은 조사가 필요하다, 현재는 Google I/O Session들을 들으면서 노트북을 끄적거리면서 멀티테스크로 작성하는 포스트라 자세한 정보를 제공하지 못함을 죄송하게 생각하고 있다. 한국으로 돌아가는 날짜 5월 11일 이후 15일 전까지 추가적으로 정리가 될 예정이다.&lt;/p&gt;&lt;p&gt;연합 학습의 목적은 모바일 클라이언트 기기에 분산된 환경에서 충분히 퍼포먼스를 가진 중앙화된 모델 학습을 위한 테크닉으로 사용자와 상호작용을 통해 로컬 환경의 모델을 학습시키고 그것을 다른 클라이언트와 공유하여 개선하고 글로벌 모델로 전환하여 중앙화를 시도하는 것이다.&lt;/p&gt;&lt;p&gt;이미 일반적인 서버의 컴퓨팅 머신은 학습 프로세스와 서빙을 최적화하기 위해 노력하고 있다. 예를들어 TPU3를 사용하는 GCP 서버는 AllReduce를 통한 분산 노드의 학습 환경을 소개하고 있는데 이는 이후에 설명한다.&lt;/p&gt;&lt;p&gt;Federated Learning 아이디어는 각 사용자 환경인 모바일에서 상호작용을 통해서 지속적인 로컬 학습을 통해 모델을 개선하고 사용자가 모바일 기기를 사용하지 않는 시기를 이용해 다른 모바일 기기들에게 학습된 결과를 공유하고 공유받아 추가적으로 글로벌 모델을 개선하는 것이다. 이와 관련된 정보는 아래 링크를 체크하자. &lt;a href="https://arxiv.org/abs/1610.05492"&gt;논문은 이곳을 클릭.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://ai.googleblog.com/2017/04/federated-learning-collaborative.html"&gt;https://ai.googleblog.com/2017/04/federated-learning-collaborative.html&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;모바일은 네트워크가 제한된 환경과 와이파이 등을 제공받아 원할한 네트워크 환경을 이용할 수 있는 두가지 상황이 존재한다. 따라서 연합 학습은 아래와 같은 두가지 전략으로 업데이트를 시도하는 것이 이 테크닉의 주 주제이다. &lt;/p&gt;&lt;p&gt;&lt;b&gt;Structured updates&lt;/b&gt;&lt;/p&gt;&lt;p&gt;: 제한된 환경에서의 직접 업데이트를 할 경우 적은 수의 변수를 통한 파라미터화, &lt;/p&gt;&lt;p&gt;&lt;b&gt;Sketched updates&lt;/b&gt;: 전체 모델을 업데이트 할 경우 모델을 전송하기 앞서 압축을 시도.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Today AI&lt;/b&gt;&lt;/p&gt;&lt;figure data-orig-width="3094" data-orig-height="874" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/98b50c14065131aade0f14a7931b7485/tumblr_inline_pr8wspxPBJ1td93ol_540.png" alt="image" data-orig-width="3094" data-orig-height="874"/&gt;&lt;/figure&gt;&lt;figure data-orig-width="1832" data-orig-height="1468" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/279158791ad3d1fa4ecb131bc63055d1/tumblr_inline_pr8wssLtwK1td93ol_540.png" alt="image" data-orig-width="1832" data-orig-height="1468"/&gt;&lt;/figure&gt;&lt;p&gt;이번 키노트에서는 Google Senior Fellow인 Jeff Dean님의 자리도 있었는데 그 동안의 RNN의 방식과 한계점 그리고 BERT에 대해서 소개하는 시간이 있었다. BERT는 지금까지도 DL 테크닉 특히 NLP 연구에 있어 큰 파장이었기 때문에 키노트에서 충분히 하이라이트를 하는 부분에 의의가 있었다고 본다.&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;br/&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Google Nest&lt;/b&gt;&lt;/p&gt;&lt;figure data-orig-width="1998" data-orig-height="1634" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/2c4f12e2100b8f12f96134d5584c9902/tumblr_inline_pr7kq264Gw1td93ol_540.png" alt="image" data-orig-width="1998" data-orig-height="1634"/&gt;&lt;/figure&gt;&lt;p&gt;구글 네스트는 구글이 중요시하는 Well Being 디바이스 제품군 반열에 합류했다. Device &amp;amp; Services 부서의 Senior Vice President인 Rick Osterloh가 소개했다. 구글 네스트는 그동안 가정에 도움을 주는 홈 디바이스 제품군을 묶어 더욱 간단한 하나의 제품 반열로 관리하도록 이름을 리네임했다. 모든 가정을 도와주는 홈 가전은 네스트 아래에서 아래 4가지 원칙을 중시한다.&lt;/p&gt;&lt;figure data-orig-width="2050" data-orig-height="1558" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/9992dcbf2967188c0c59bf72e84daf34/tumblr_inline_pr7l6hOPRj1td93ol_540.png" alt="image" data-orig-width="2050" data-orig-height="1558"/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;Easy for everyone&lt;/li&gt;&lt;li&gt;Rersonal for everyone&lt;/li&gt;&lt;li&gt;Works together&lt;/li&gt;&lt;li&gt;Respects your privacy&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;그리고 홈 가전을 모두 묶는 Nest Hub (구 네임: Home Hub)를 소개했다.&lt;/p&gt;&lt;figure data-orig-width="2670" data-orig-height="1474" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/f87cbb3f78689fa67a079e2cd70c8af4/tumblr_inline_pr7l8aJw3M1td93ol_540.png" alt="image" data-orig-width="2670" data-orig-height="1474"/&gt;&lt;/figure&gt;&lt;p&gt;네스트 허브는 홈 가정기기에 대한 대시보드 정보를 제공하고, 가정 개개인의 정보를 개인의 핑거프린트 정보를 통해 암호화하여 보안을 제공하고 개개인에 필요한 관심사와 관계된 정보를 제공할 수 있도록 개발되었다.&lt;/p&gt;&lt;figure data-orig-width="2346" data-orig-height="1342" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/1d10b14df8ef32203b2815a23274b615/tumblr_inline_pr7lazcH2c1td93ol_540.png" alt="image" data-orig-width="2346" data-orig-height="1342"/&gt;&lt;/figure&gt;&lt;figure data-orig-width="2234" data-orig-height="1620" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/c0bd43bef0d30501e8cbf683c6085390/tumblr_inline_pr8wxeEOzD1td93ol_540.png" alt="image" data-orig-width="2234" data-orig-height="1620"/&gt;&lt;/figure&gt;&lt;p&gt;또한 네스트 캠을 통해 개인 가정환경 상황을 쉽게 볼 수 있도록 카메라와 마이크를 구글 듀오(Google Duo)와 연결하여 볼 수 있게 되어있다. 물론 카메라와 마이크는 네스트 허브의 뒤쪽에 있는 물리적 버튼으로 제어할 수 있도록 하여 개인정보를 보호할 수 있도록 설계되었다. 네스트 허브에 달려있는 카메라 디바이스는 또 하나의 기능을 제공하는데,&lt;/p&gt;&lt;figure data-orig-width="2436" data-orig-height="1496" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/ce15089d8f73affcf0b5b2c0f39ee193/tumblr_inline_pr7lmtdkxF1td93ol_540.png" alt="image" data-orig-width="2436" data-orig-height="1496"/&gt;&lt;/figure&gt;&lt;p&gt;네스트 허브에 달려있는 카메라를 통해 사용자의 포즈와 모션을 통해 특정한 액션을 줄 수 있는 핸즈 프리 옵션이 붙어있다. (이 영상에서 모션 스탑 기능이 보여졌을때 반응이 끝내줬다.)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;가격은 다음과 같이 공개되었다.&lt;/p&gt;&lt;figure data-orig-width="2576" data-orig-height="1326" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/8647845a7b3264da5c6aece2e78b43f8/tumblr_inline_pr7lgc6mVh1td93ol_540.png" alt="image" data-orig-width="2576" data-orig-height="1326"/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;네스트 허브 맥스: $229&lt;/li&gt;&lt;li&gt;네스트 허브: $129&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;Google New Pixel (3A, 3B)&lt;/b&gt;&lt;/p&gt;&lt;figure data-orig-width="2476" data-orig-height="1294" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/cdb8d3133978a0494712f5198be0f2da/tumblr_inline_pr7m0hhnYy1td93ol_540.png" alt="image" data-orig-width="2476" data-orig-height="1294"/&gt;&lt;/figure&gt;&lt;p&gt;구글에서는 추가적으로 픽셀 폰에 대한 정보도 선보였는데 시기가 Android Q에 대해서도 다루는 자리다 보니 Android Q의 기능들도 함께 섞여 소개가 된 것 같다. 픽셀은 이번에 Purple-ish 색상이 추가되었다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="3012" data-orig-height="1424" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/e12bed5bac5bd931c0723251c961edbb/tumblr_inline_pr7m2xD3Sn1td93ol_540.png" alt="image" data-orig-width="3012" data-orig-height="1424"/&gt;&lt;/figure&gt;&lt;p&gt;또한 Phone X(&amp;hellip;)에 대비하여 어둠에서도 높은 색 재현력을 보여주고 있다. 또한 Google Photo에 무제한의 사진 업로드 스페이스를 제공하는 옵션또한 공개되었다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="1156" data-orig-height="1662" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/07e03807c7c007e0f2a5c429d6c51607/tumblr_inline_pr7m6bEAHk1td93ol_540.png" alt="image" data-orig-width="1156" data-orig-height="1662"/&gt;&lt;/figure&gt;&lt;p&gt;그것 뿐이 아닌 구글 맵을 픽셀에서 사용할 경우 AR을 이용한 위치 가이드라인과 위치 포인트에 마커 오브젝트가 위치하는 등 사용자에게 더 넓은 반응을 줄 수 있는 기능이 제공된다. 이것 또한 현장 반응이 엄청났다.&lt;/p&gt;&lt;p&gt;&lt;b&gt;Android Q&lt;/b&gt;&lt;/p&gt;&lt;figure data-orig-width="3228" data-orig-height="1402" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/81b0eb444c51def2b99106723c72b405/tumblr_inline_pr8x8nFJgs1td93ol_540.png" alt="image" data-orig-width="3228" data-orig-height="1402"/&gt;&lt;/figure&gt;&lt;p&gt;Android 팀의 디렉터로 자리하고 있는 Stephanie Saad Cuthbertson가 소개한 안드로이드 Q는 이번 Google I/O 2019에 참여한 수 많은 안드로이드 개발자들에게 있어 핵심이 되는 발표 중에 하나이다.  이번 Google I/O 2019에서 소개된 안드로이드 내용의 주요 사항은 아래와 같다.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;Foldable&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;Security &amp;amp; Privacy&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;Dark Theme&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;Live Caption&lt;/b&gt;&lt;/li&gt;&lt;li&gt;Smart Reply&lt;/li&gt;&lt;li&gt;Focus mode&lt;/li&gt;&lt;li&gt;On-device learning&lt;/li&gt;&lt;li&gt;Suggested Action&lt;/li&gt;&lt;li&gt;5G&lt;/li&gt;&lt;li&gt;Faster security updates&lt;/li&gt;&lt;li&gt;&lt;b&gt;Parental Controls (+ Bonus time!)&lt;/b&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;&lt;br/&gt;&lt;/b&gt;&lt;/p&gt;&lt;figure data-orig-width="1792" data-orig-height="1304" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/67e4470183c966455f379d9279f1157f/tumblr_inline_pr8xmmxXqz1td93ol_540.png" alt="image" data-orig-width="1792" data-orig-height="1304"/&gt;&lt;/figure&gt;&lt;figure data-orig-width="2910" data-orig-height="1392" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/1446b6777bdea4c0692a4ed1af036eee/tumblr_inline_pr8xo2RVVf1td93ol_540.png" alt="image" data-orig-width="2910" data-orig-height="1392"/&gt;&lt;/figure&gt;&lt;p&gt;안드로이드 Q에서는 다크 테마가 추가되는 등 유저가 사랑하는 여러가지 기능들을 수용하여 업데이트 하였다. 하지만 이번 안드로이드 Q에서 집중해서 봐야하는 부분중에 하나는 개인정보 보호와 처리 방침이라고 할 수 있는데,&lt;/p&gt;&lt;figure data-orig-width="2596" data-orig-height="1300" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/6cdc7bc3728be65aaa567b20b5f93112/tumblr_inline_pr8xx1bGqT1td93ol_540.png" alt="image" data-orig-width="2596" data-orig-height="1300"/&gt;&lt;/figure&gt;&lt;figure data-orig-width="3236" data-orig-height="1360" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/321a497c452122ba1dc27515b8bf7c69/tumblr_inline_pr8xx27Nu11td93ol_540.png" alt="image" data-orig-width="3236" data-orig-height="1360"/&gt;&lt;/figure&gt;&lt;p&gt;인터넷 환경이 발달하고 기기가 발달하며 알지도 모르게 새나가는 데이터를 보호하고 각 개인 정보를 숨길 수 있는 권리를 존중하는 구글의 중요한 방침을 느껴볼 수 있다.&lt;/p&gt;&lt;p&gt;Notice: 이 포스트는 현재 작성중(WIP)인 포스트입니다. 실시간으로 포스트 내용이 변경될 수 있습니다.&lt;/p&gt;&lt;p&gt;- 이 포스트는 현장에서 작성되었기 때문에 추가적인 정보가 추가 될 수 있습니다.&lt;/p&gt;&lt;p&gt;- 부족한 정보나 잘못된 정보는 댓글이나 메신저를 통해 알려주시면 감사하겠습니다.&lt;/p&gt;</description><link>https://blog.pigno.se/post/184721259323</link><guid>https://blog.pigno.se/post/184721259323</guid><pubDate>Wed, 08 May 2019 06:25:15 +0900</pubDate><category>google io</category><category>engineering</category><category>it</category><category>android</category><category>ai</category></item><item><title>완벽한 Mac 작업환경 세팅하기 (vim, zsh, iterm)</title><description>&lt;p&gt;그동안 개인 컴퓨터로도 수많은 프로그래밍 언어와 작업 환경을 만들었고, 회사에서도 수많은 인턴분들과 뉴커머들이 오고가면서 그들의 작업환경을 세팅해주고 가이드라인 해줬다, 필자는 최대한 많은 트릭과 신텍틱 슈거, 그리고 불필요한 노동시간을 줄이기위해 깊이있게 파고들고 또 파고드는 것을 좋아한다.
    &lt;br/&gt;&lt;/p&gt;
&lt;p&gt;이번 시간에서는 맥 환경에서 작업하는 주 작업자들을 위해 여러분의 노동시간을 줄일 수 있는 몇가지 팁들을 소개하려고 한다. 이 글에서 tmux에 대한 내용까지 담으려고 했지만 tmux만 해도 내용이 너무 방대하므로 iTerm의 Split View기능으로 대체하고 &lt;a href="https://github.com/tmux/tmux"&gt;tmux&lt;/a&gt;는 다음 시간에 다른 포스트에서 자세히 다루도록 하겠다.&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2&gt;터미널 환경 구성하기&lt;/h2&gt;
&lt;p&gt;내가 일하는 분야나 개인 프로젝트에서는 터미널을 열어 사용하는 경우가 다분하다, 아마 이 분야가 당연히 그렇다고 생각하고 있고 만약 터미널과 친하지 않는 유저라도 이 섹션에서 터미널 환경을 구성해서 이 기회에 터미널과 조금 더 친해져보는 시간을 가지도록 하자.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="956" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/a6c29aa28752f64713e18cf9895f5edd/tumblr_inline_pqu1al50wh1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="956"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;여러분이 가지고 있는 초기 터미널을 위와 같은 모양새라고 생각한다. 우리는 이것을 아래처럼 바꿀 것이고, 생각보다 어렵지 않기 때문에 끈기를 가지고 따라하기를 바란다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1004" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/080ffc6d6dd64bc1aa3d9ac70dfea046/tumblr_inline_pqu1d3IhqJ1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1004"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;1. Oh My ZSH 설치하기&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;가장 먼저 여러분이 해야 할 것은 기본 쉘을 새로운 쉘 프로그램으로 교체하는 일이다. 여러분의 맥 환경이 별다른 수정을 거치지 않았다면 기본적으로 bash가 여러분의 기본 쉘 프로그램일 것이다. &lt;/p&gt;

&lt;br/&gt;&lt;div class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/8c8420585f3d933e6703e43680d87ab3"&gt;https://gist.github.com/KennethanCeyer/8c8420585f3d933e6703e43680d87ab3&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;먼저 아래 명령어를 통해 zsh를 설치해보자.&lt;/p&gt;
&lt;br/&gt;&lt;div class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/47c981fccd3690e1bd410f4a388de5ce"&gt;https://gist.github.com/KennethanCeyer/47c981fccd3690e1bd410f4a388de5ce&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;놀랍게도 이미 여러분의 쉘은 zsh로 변경이 되었다. &lt;a href="https://www.google.com/search?q=oh+my+zsh&amp;amp;oq=oh+my+zsh&amp;amp;aqs=chrome..69i57j0l5.1889j0j7&amp;amp;sourceid=chrome&amp;amp;ie=UTF-8" target="_blank"&gt;oh-my-zsh&lt;/a&gt; 프로젝트는 &lt;b&gt;zsh&lt;/b&gt; 쉘을 쉽게 설치하고 관리할 수 있게 도와준다, 덕분에 여러분은 단 한줄의 코드로 &lt;b&gt;zsh&lt;/b&gt;를 쉽게 설치 / 업그레이드 할 수 있었다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="956" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/a056e7a7f20049e47af28c4690749438/tumblr_inline_pqu1qxTe2g1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="956"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;쉘 이름은 $0 환경변수로 확인할 수 있다. 여러분의 터미널에 `zsh`가 출력되는지 확인해보자, 아래 그림처럼 `zsh`가 나오면 정상적으로 설치된 것이다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="956" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/5e03179b9843e79b5dd78ec8bbb2350f/tumblr_inline_pqu1skqq4X1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="956"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;2. Powerlevel9k 테마 설치&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;zsh는 정상적으로 설치되었어도, 별도의 테마가 적용되지 않으면 굉장히 밋밋한 느낌의 터미널만이 제공된다. 필자는 여러가지 테마를 사용해봤지만 Powerlevel9k 보다 어썸하고 쿨한 테마를 찾지 못했다. 만약 더 좋은 테마를 알고있거나 제안하고 싶으면 이 블로그 하단 댓글로 남겨주시기 바란다.&lt;/p&gt;
&lt;p&gt;아래 처럼 명령어를 입력하여 zsh themes 폴더 내에 powerlevel9k를 내려받는다.&lt;/p&gt;
&lt;br/&gt;&lt;div class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/2794384bce32ae8650eb9e94131c3da5"&gt;https://gist.github.com/KennethanCeyer/2794384bce32ae8650eb9e94131c3da5&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;우리는 테마를 다운로드 받는 것까지는 완료했고, 최종적으로 .zshrc 파일을 수정하여 정확한 테마 이름을 zsh 쉘에 알려주어야 한다. 아래 명령어처럼 .zshrc 파일을 열어보자.&lt;/p&gt;
&lt;br/&gt;&lt;div class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/8739695df2d1ca420326d5a127511a25"&gt;https://gist.github.com/KennethanCeyer/8739695df2d1ca420326d5a127511a25&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;아래 그림처럼 ZSH_THEME 단락을 `powerlevel9k/powerlevel9k`로 바꿔준다. 아마 여러분의 .zshrc의 기본 ZSH_THEME는 `robbyrussell`로 잡혀있을 것이다.&lt;/p&gt;
&lt;p&gt;이해가 잘 가지 않는다면 아래 링크를 클릭하여 변경 방법을 살펴보자.&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;a href="https://asciinema.org/a/OiKeFFEO76vfiNvTR3YsA2Qh0" target="_blank"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://asciinema.org/a/OiKeFFEO76vfiNvTR3YsA2Qh0.svg" alt="image"/&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;`.zshrc` 파일을 변경했다면, zsh 명령어를 통해 쉘을 다시 열어줘야 변경 사항이 확인이 가능하다.&lt;/p&gt;
&lt;br/&gt;&lt;div class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/4bfcc90111e69632111387d239931cb2"&gt;https://gist.github.com/KennethanCeyer/4bfcc90111e69632111387d239931cb2&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;b&gt;3. Iterm2 설치&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;여러분이 기본적으로 사용하는 터미널 프로그램은 터미널의 편의기능이 많이 부족하다. 따라서 아래의 편의 기능을 사용하기 위해 Iterm2를 설치하도록 하자. Iterm2에서 제공하는 기능 중 특별히 아래의 기능이 유용하다.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;터미널 탭 기능 (+토글 단축키)&lt;/li&gt;
    &lt;li&gt;터미널 Split View&lt;/li&gt;
    &lt;li&gt;자동완성 기능&lt;/li&gt;
    &lt;li&gt;터미널 내에서 단어 찾기&lt;/li&gt;
    &lt;li&gt;마우스 없이 복사&amp;amp;붙여넣기&lt;/li&gt;
    &lt;li&gt;256 이상의 색상 지원&lt;/li&gt;
    &lt;li&gt;더 많은 기능 살펴보기: &lt;a href="https://www.iterm2.com/features.html"&gt;https://www.iterm2.com/features.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;그럼 본격적으로 설치를 진행해보자. 설치는 &lt;a href="https://www.iterm2.com/downloads.html"&gt;https://www.iterm2.com/downloads.html&lt;/a&gt;에서 진행할 수 있다.  링크에서 Stable Releases에서 최신 파일을 설치하자. 이 포스트 기준으로는 Iterm2 3.2.9 버전이 최신이다.&lt;/p&gt;
&lt;figure data-orig-width="1704" data-orig-height="712" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/d73b3a5070123a4778f79b13ddd578bd/tumblr_inline_pqu2v8BH0D1td93ol_540.png" alt="image" data-orig-width="1704" data-orig-height="712"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;다운로드가 끝나면 아래와 같이 다운로드 폴더에 Iterm2가 있다, 프로그램을 어플리케이션으로 옮겨 설치를 해주자.&lt;/p&gt;
&lt;figure data-orig-width="676" data-orig-height="208" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/0f8625ba4f8df4504febeb24ac9a02b0/tumblr_inline_pqu2x3mRKZ1td93ol_540.png" alt="image" data-orig-width="676" data-orig-height="208"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;시스템 환경설정 &amp;gt; 보안 및 개인 정보 보호 &amp;gt; 개인 정보 보호 탭&lt;/b&gt;에서 방금 설치한 Iterm2를 추가해주도록 하자.&lt;/p&gt;
&lt;p&gt;설정이 끝났으면 어플리케이션에 설치된 iTerm 앱을 실행시켜보자.&lt;/p&gt;
&lt;figure data-orig-width="1128" data-orig-height="538" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/0c03d1e0f533bc99d26161c6f192472e/tumblr_inline_pqu36c9CSX1td93ol_540.png" alt="image" data-orig-width="1128" data-orig-height="538"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;맥은 기본적으로 인터넷에서 다운로드 받은 앱은 위와 같은 경고 메시지가 나타나게 된다. 열기 버튼을 클릭하면 앱이 정상적으로 실행되고 경고는 다시 나타나지 않는다. `열기`를 클릭하여 열어주자.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1028" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/d7a5f802b1f69c80b33e337e571f4012/tumblr_inline_pqu37kXhoC1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1028"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;여기까지 잘 따라 오셨으면 위와 같은 터미널 창을 볼 수 있다. 이제 터미널 앱은 Dock에서 제거하고 작별을 고하자, 앞으로 여러분은 iTerm을 기본 터미널로 친해질 시간을 가질 날만 남았다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;4. Powerlevel9k font 설치&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;눈치가 빠른 독자라면 느끼겠지만 화면에 일부 텍스트가 깨지는 현상이 보인다. 아래 그림처럼 일부 박스가 깨져 제대로 보이지 않고 `?` 기호로 표시된다.&lt;/p&gt;
&lt;figure data-orig-width="544" data-orig-height="72" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/dc7d9d897e4bddb807b4a451a52a1a13/tumblr_inline_pqu3b4pu6t1td93ol_540.png" alt="image" data-orig-width="544" data-orig-height="72"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;글자가 깨지는 이유는 우리가 앞서 설치한 Powerlevel9k 테마는 일부 특수 문자를 사용하여 TUI (Text User Interface) 화면을 꾸미기 때문에, Powerlevel9k에서 권장하는 폰트를 사용해줘야 한다. 아래와 같은 절차를 따라하여 폰트를 설치해보자.&lt;/p&gt;
&lt;br/&gt;&lt;div class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/6b7243146bb9e0730b32a53f2e116b5e"&gt;https://gist.github.com/KennethanCeyer/6b7243146bb9e0730b32a53f2e116b5e&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;폰트 설치가 끝났으면 iTerm 설정을 통해 터미널 기본 폰트를 변경해주어야 한다. iTerm 화면에서 &lt;b&gt;Command + ,(콤마)&lt;/b&gt; 단축키를 이용해 설정 창을 열어준다. 그 다음 &lt;b&gt;Profiles &amp;gt; Text 탭&lt;/b&gt;의 &lt;b&gt;Font 섹션&lt;/b&gt; 아래에 있는 `&lt;b&gt;Change Font&lt;/b&gt;` 버튼을 클릭해주자.&lt;/p&gt;
&lt;figure data-orig-width="2060" data-orig-height="1182" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/c6a981f26c232badc41fc5168fbca0ac/tumblr_inline_pqu3ksVLFl1td93ol_540.png" alt="image" data-orig-width="2060" data-orig-height="1182"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;좌측 탐색 영역에서 All Fonts를 클릭하고 스크롤을 내리다보면 `&lt;b&gt;Meslo LG M DZ for Powerline&lt;/b&gt;` 폰트가 보인다. 그 폰트를 선택하고 글자 크기를 여러분이 원하는 크기로 세팅하고 창을 닫아준다. (필자는 12pt가 적당하다고 생각하지만, 넓은 화면을 가진 사용자의 경우 13pt가 가장 적절하다.)&lt;/p&gt;
&lt;figure data-orig-width="958" data-orig-height="1686" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/243dde15eaa644067a53c4406699a807/tumblr_inline_pqu3oiVMLn1td93ol_540.png" alt="image" data-orig-width="958" data-orig-height="1686"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;이제 여러분은 아래 화면처럼 모든 텍스트가 깨짐없이 출력되는 것을 확인 할 수 있다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/a306b12ad59affcfb44bea56116b34e3/tumblr_inline_pqu3prONIM1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;5. iTerm color scheme 설정&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;이제 우리는 테마가 적용된 아름다운 터미널 구성 세팅이 끝났다. 하지만 컬러가 너무 시신경을 자극하고 컬러의 색체도 그렇게 아름답지 못한 것 같다. 따라서 컬러 스킴을 적용하여 조금 더 색체 배합이 아름다운 터미널로 교체해보자.&lt;/p&gt;
&lt;p&gt;필자는 여러가지 컬러 스킴을 찾아 테스트를 해보았고 지금은 Brogrammer 스킴이 가장 필자의 선호도에 맞는 스킴이다. 따라서 이 포스트에서는 Brogrammer를 설치하는 가이드를 진행한다. 구글에 iterm color scheme이라 검색하여 여러분에 선호에 맞는 스킴을 설치할 수 있으므로 만약 이 포스트에서 나온 컬러 스킴을 원하지 않을 경우 여러분이 원하는 컬러 로 설정하면 된다.&lt;/p&gt;
&lt;br/&gt;&lt;div class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/a21f23327a0e5ac3bf7fb8b800ecc179"&gt;https://gist.github.com/KennethanCeyer/a21f23327a0e5ac3bf7fb8b800ecc179&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;위 명령어를 입력하여 Brogrammer 컬러 스킴을 여러분의 홈 디렉토리 .iterm 폴더안에 다운로드 하였다. 다운로드가 끝났다면 iTerm 화면에서 Command + ,(콤마) 단축키로 설정 화면을 열고&lt;b&gt; Profiles &amp;gt; Colors&lt;/b&gt; &lt;b&gt;탭&lt;/b&gt;의 우측하단의 &lt;b&gt;Color Presets 콤보박스&lt;/b&gt;를 열어 `&lt;b&gt;Import&lt;/b&gt;` 옵션을 선택하자. 이해가 잘 안간다면 아래 그림을 보자.&lt;/p&gt;
&lt;figure data-orig-width="2080" data-orig-height="1124" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/d97c2d9624b627c9b88f8db8f742ed83/tumblr_inline_pqu40nbzvt1td93ol_540.png" alt="image" data-orig-width="2080" data-orig-height="1124"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;탐색기에서 &lt;b&gt;Command + Shift + g 단축키&lt;/b&gt;를 입력하여 경로 입력 창을 열고 `&lt;b&gt;~/.iterm&lt;/b&gt;` 을 입력하여 ~/.iterm 폴더로 이동한 후 .iterm 폴더 내에 있는 &lt;b&gt;Brogrammer.itermcolors&lt;/b&gt;파일을 선택해주자.&lt;/p&gt;
&lt;figure data-orig-width="1664" data-orig-height="1120" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/3363cf9b963df1612a495c8673d22f78/tumblr_inline_pqu4cg7Sdj1td93ol_540.png" alt="image" data-orig-width="1664" data-orig-height="1120"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;Import&lt;/b&gt;가 완료되었다면 아래와 같이 선택 화면에서 &lt;b&gt;Brogrammer&lt;/b&gt;가 확인된다.&lt;/p&gt;
&lt;figure data-orig-width="548" data-orig-height="778" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/1aab5bda7797a575f388cd7c77db2129/tumblr_inline_pqu4duDjQa1td93ol_540.png" alt="image" data-orig-width="548" data-orig-height="778"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;Brogrammer&lt;/b&gt;를 선택하고, 설정 화면을 닫아주자. 설정이 정상적으로 되었다면 아래와 같이 컬러가 변경된 터미널을 확인할 수 있다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/ebb29cfab37881f2c6900e1dc25bffd7/tumblr_inline_pqu4gkgWb51td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;6. Powerlevel9k context 설정&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;Powerlevel9k 테마는 환경변수를 통해 사용자 입맛에 맞게 커스터마이징 하는 기능을 제공하고 있다. &lt;a href="https://github.com/bhilburn/powerlevel9k#prompt-customization"&gt;https://github.com/bhilburn/powerlevel9k#prompt-customization&lt;/a&gt; 링크를 확인해보자.&lt;/p&gt;
&lt;figure data-orig-width="1832" data-orig-height="386" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/1af8e03b639efc2c1b1a7ac0f25c0c73/tumblr_inline_pqu4km3zX41td93ol_540.png" alt="image" data-orig-width="1832" data-orig-height="386"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;위 그림의 예시처럼 환경변수는 좌측과 우측 라인에 기본적으로 표시되는 Context를 수정할 수 있게 제공해준다. 필자는 다음과 같은 내용을 .zshrc에 추가하였다.&lt;/p&gt;
&lt;br/&gt;&lt;div class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/d5658502e22a2be7e290de303e66ec66"&gt;https://gist.github.com/KennethanCeyer/d5658502e22a2be7e290de303e66ec66&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;만약 설정 방법이 이해가 안된다면 아래를 살펴보자.&lt;/p&gt;
&lt;p style="text-align: center;"&gt;&lt;a href="https://asciinema.org/a/B6LWOEJdGGWz62Koym7YNgj0x" target="_blank"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://asciinema.org/a/B6LWOEJdGGWz62Koym7YNgj0x.svg" alt="image"/&gt;&lt;/div&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
    &lt;br/&gt;&lt;/p&gt;
&lt;p&gt;설정 파일을 변경하더라도 바로 적용이 안되고 zsh 쉘을 다시 실행해야 한다. zsh 명령어를 입력하여 zsh 쉘을 다시 실행하여 보자. 설정이 잘 완료 되었다면 아래와 같이 터미널이 조금 더 간략화된다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/8c02e21b28669cee3ddbdfa5bd53a356/tumblr_inline_pqu59g5HPM1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;7. 작업 마무리하기&lt;/b&gt;
    &lt;br/&gt;&lt;/p&gt;
&lt;p&gt;여러분의 터미널은 대부분의 설정이 끝났다. 이제 iTerm의 기능과 zsh 쉘의 기능, Powelevel9k 테마의 편리한 UI들을 사용할 수 있다. 대표적인 기능들을 둘러보자.&lt;/p&gt;
&lt;p&gt;
    &lt;br/&gt;&lt;/p&gt;
&lt;p&gt;먼저 iTerm의 기능 중 Split view 기능을 살펴보자. 여러분의 iTerm 화면에서 &lt;b&gt;Command + D &lt;/b&gt;단축키를 통해 다음과 같이 Vertical View, &lt;b&gt;Command + Shift + D&lt;/b&gt;를 통해 Horizontal View로 분리할 수 있다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/86f7aa533cb4c842a598a36b2c318df0/tumblr_inline_pqu5dgXUW11td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;위 그림이 Vertical View Split,&lt;/p&gt;
&lt;p&gt;
    &lt;br/&gt;&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/80256a5f1838cd02c0dc06b22ee4f2be/tumblr_inline_pqu5efQKiQ1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;그리고 위 그림이 Horizontal Split View이다.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;커맨드 + W&lt;/b&gt; 단축키를 통해 현재 포커스가 잡힌 View를 닫을 수 있고, &lt;b&gt;Command + 방향키&lt;/b&gt;를 통해 View 포커스를 스위칭 할 수 있다.&lt;/p&gt;
&lt;p&gt;
    &lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Command + T&lt;/b&gt;를 통해 탭을 생성할 수 있고 &lt;b&gt;Command + 숫자&lt;/b&gt;로 특정 넘버의 탭으로 스위치를 할 수 있다. 마찬가지로 &lt;b&gt;Command + W&lt;/b&gt;로 탭을 닫을 수 있다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1174" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/053f2ab7b6f34ed59a2eeb51b7172c77/tumblr_inline_pqu5jkUAzo1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1174"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;더 자세한 iTerm 편의 기능은 &lt;a href="https://gist.github.com/squarism/ae3613daf5c01a98ba3a" target="_blank"&gt;https://gist.github.com/squarism/ae3613daf5c01a98ba3a&lt;/a&gt; 링크에서 잘 설명하고 있다.&lt;/p&gt;
&lt;p&gt;
    &lt;br/&gt;&lt;/p&gt;
&lt;p&gt;ZSH도 수 많은 편의 기능을 제공하고 있다. 먼저 cd 명령어를 생략하고도 특정 디렉토리로 이동할 수 있다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/6d527105cebb465eddee06fc71d87f12/tumblr_inline_pqu5m4Cl8m1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;그리고 .. (상위 폴더로 이동)에 추가적으로 점(.)을 붙여 어느 depth의 상위 디렉토리 까지 이동할지 지정이 가능하다. 예를들어 &amp;hellip;. (점이 4개 사용되었을 때)의 경우 상위 3 depth의 폴더로 이동한다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/574efa3cf58c1e27bdac40be96b60d03/tumblr_inline_pqu5us9vGu1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;그 밖에 Tab으로 자동 완성(Auto complete)을 지원하는 기능도 폭 넓게 늘어나게 되는데 대표적으로 git을 사용하는 경우 branch 명이나 origin alias도 자동 완성으로 서포트하게 된다.&lt;/p&gt;
&lt;p&gt;더 자세한 내용은 &lt;a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Cheatsheet"&gt;https://github.com/robbyrussell/oh-my-zsh/wiki/Cheatsheet&lt;/a&gt; 링크에서 살펴보자.&lt;/p&gt;
&lt;p&gt;
    &lt;br/&gt;&lt;/p&gt;
&lt;p&gt;마지막으로 Powerlevel9K 테마가 제공해줄 수 있는 기능 중 vcs에 대해서 얘기해보고 싶다. 여러분이 git을 이용한 버전 컨트롤을 할 경우 아래와 같이 보기 편한 branch 상태 정보를 제공받게 된다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="516" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/5768b5ebdd2d11116358d0c24761ab66/tumblr_inline_pqu5ziMSH61td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="516"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;위 사진에서 연두색 영역에서는 현재 git 디렉토리의 브랜치 이름을 보여주게 된다. (이 연두색 영역은 .git 디렉토리가 아니면 생략된다.)&lt;/p&gt;
&lt;p&gt;
    &lt;br/&gt;&lt;/p&gt;
&lt;p&gt;그 밖에도 각각의 git status에 따라 이 부분의 색상과 내용이 조금 씩 변경된다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="516" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/adeb9511d3fda765d153977e381d4d11/tumblr_inline_pqu61v4lKA1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="516"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;더 자세한 Powerlevel9k의 기능은 &lt;a href="https://bhilburn.org/powerlevel9k/"&gt;https://bhilburn.org/powerlevel9k/&lt;/a&gt; 링크에서  살펴보자.&lt;/p&gt;
&lt;p&gt;
    &lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;Vim 환경 준비하기&lt;/h2&gt;
&lt;p&gt;여러분의 Mac에는 대부분 vi 커맨드가 기본적으로 내장되어 있다. vi 커맨드를 이용하여 에디터를 띄울 수 있는데 기본적으로 최근의 vi 커맨드는 vim(Vi IMproved) 커맨드와 동일하게 동작한다.&lt;/p&gt;
&lt;p&gt;vi &amp;ndash;version을 이용하여 버전 정보를 조회해보자.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/8b53e35de389b9d222fb997ba1db7497/tumblr_inline_pqu6a1zmOt1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;
    &lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;vimrc 세팅하기&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/amix/vimrc"&gt;https://github.com/amix/vimrc&lt;/a&gt;를 이용하여 우리는 기본적인 vim 환경을 준비하고자 한다. 아래와 같은 명령어를 이용하여 vimrc를 세팅해보자.
    &lt;br/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;div class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/3838790aa6eb1d1a3e5e201a9fad58b5"&gt;https://gist.github.com/KennethanCeyer/3838790aa6eb1d1a3e5e201a9fad58b5&lt;/a&gt;&lt;/div&gt;
&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/78bd3313760ed7f8ec9d5026d3aa874d/tumblr_inline_pqu6ec7bAR1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;위 화면에서 처럼 Installed the Ultimate Vim configratuon successfully! Enjoy :-) 라는 문구가 보이면 정상적으로 설치된 것이다. vi 명령어를 실행해보자.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/c23dd8c21d9ea592f242f6eebc4dc022/tumblr_inline_pqu6g9hDlL1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/11c3ab86a43faee9a0734feac93ec12b/tumblr_inline_pqu6gvGL611td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;위 사진처럼 가장 기본적인 화면 구성은 vimrc가 다 세팅해주었기 때문에 어느정도 보기좋은 인터페이스로 구성이 되었다. 하지만 몇가지 추가로 기능을 이용하려면 추가적인 설정이 필요하다.&lt;/p&gt;
&lt;p&gt;아래 명령어를 이용하여 .vimrc에 추가적인 설정을 추가해주자.&lt;/p&gt;
&lt;br/&gt;&lt;div class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/3742210bfcbb34ecdf7cbb9f2524687f"&gt;https://gist.github.com/KennethanCeyer/3742210bfcbb34ecdf7cbb9f2524687f&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;이제 vi 명령어를 통해 에디터를 열면 다음과 같은 화면을 볼 수 있다.&lt;/p&gt;
&lt;figure data-orig-width="1080" data-orig-height="893" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/d718935d7a1b79fce9f02fe5a48a5230/tumblr_inline_pqu6tnntOr1td93ol_540.png" alt="image" data-orig-width="1080" data-orig-height="893"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/83aa92dee54f10e8a8f659687c314adc/tumblr_inline_pqu6ugAnck1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;이 정도면 충분하다! 여러분이 vi를 통해 텍스트 편집이나 심지어 개발을 할 경우에도 이 정도의 설정으로 최소한의 요구사항은 충족할 수 있다. 이제 vim과 함께 즐거운 해킹을 하기 바란다. 설정에 부족함을 느끼는 독자들을 위해 다른 포스트에서 vim에 플러그인을 추가하여 파워 업을 할 수 있는 방법을 설명할 예정이다.&lt;/p&gt;
&lt;p&gt;
    &lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;하나만 더! vim 테마 설정&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;이미 우리는 iTerm 컬러 스킴을 추가하여 충분한 컬러를 가지고 있지만 확실한 것을 원하는 유저를 위해 vim에 컬러 스킴을 추가하는 방법을 공유하겠다.&lt;/p&gt;
&lt;p&gt;우리는 앞서 Brogrammer 색상 테마를 사용했기 때문에 vim도 같은 색상 팔레트로 통일하는 것으로 설명한다.&lt;/p&gt;
&lt;br/&gt;&lt;div class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/fe32c8d0ead2adafc6d59dc87d324509"&gt;https://gist.github.com/KennethanCeyer/fe32c8d0ead2adafc6d59dc87d324509&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;먼저 위 명령어를 이용하여 brogrammer.vim을 ~/.vim/colors 폴더에 다운로드 한다. 그리고 아래 화면처럼 &lt;b&gt;colorscheme brogrammer&lt;/b&gt;를 ~/.vimrc에 추가한다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/7050e0722abe9ea81fd9fec835f2bc8d/tumblr_inline_pqu79n3reo1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;설정이 다 끝났으면, 아래와 같이 개발환경에서 vim의 다양한 화면 구성 및 색상 배치를 경험해볼 수 있다.&lt;/p&gt;
&lt;figure data-orig-width="1364" data-orig-height="1128" class="tmblr-full"&gt;&lt;div style="text-align: center"&gt;&lt;img style="max-width: 100%;" src="https://66.media.tumblr.com/65fecdd3aa0a710584f377ca55bda506/tumblr_inline_pqu7b2K37G1td93ol_540.png" alt="image" data-orig-width="1364" data-orig-height="1128"/&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;
    &lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;끝으로&lt;/h2&gt;
&lt;p&gt;이번 포스트는 개발 환경에 가장 기본이 되는 터미널과 vim 설정에 대해 알아봤다. 여러분은 고작 터미널 기능을 확장한 것 뿐에 불과하는데 굉장히 긴 포스트 글을 읽어보고 시행 착오를 겪어가며 고통을 느끼고 있을 것이라 생각한다.&lt;/p&gt;
&lt;p&gt;이런 고통을 줄이기 위해 이후 더 다양한 포스트를 통해 유용한 트릭들을 공유하고 가이드해줄 수 있도록 할 예정이다. 다만 여러분이 이 글을 읽으며 얻은 공유는 나중에 잊지 않고 여러분이 다른 포스트를 써서 또 다른 기술 공유라는 기여를 통해 개발자 네트워크에 보답을 해주기를 희망한다.&lt;/p&gt;
&lt;p&gt;필자는 최근 &lt;a href="https://github.com/KennethanCeyer/bire"&gt;https://github.com/KennethanCeyer/bire&lt;/a&gt; 프로젝트를 통해 이런 설치 과정을 몇줄의 커맨드로 최소화 할 수 있는 프로젝트를 기획하고 있다. 이 부분에 대해서도 경험기를 포스트로 공유할 계획이니 기대해주기를 바란다.&lt;/p&gt;</description><link>https://blog.pigno.se/post/184576332493</link><guid>https://blog.pigno.se/post/184576332493</guid><pubDate>Thu, 02 May 2019 00:54:45 +0900</pubDate><category>development</category><category>vim</category><category>vimrc</category><category>zsh</category><category>iterm2</category><category>mac</category><category>environment</category></item><item><title>다가오는 추상화의 위기 (The Looming Abstraction Crisis) 번역글</title><description>&lt;p&gt;이 글은 &lt;a href="https://bbessemer.github.io/blog"&gt;operator++&lt;/a&gt; 블로그의 

&lt;a href="https://bbessemer.github.io/blog/2018/06/18/looming-abstraction-crisis/"&gt;The Looming Abstraction Crisis&lt;/a&gt; 아티클을 번역하였습니다. &lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;역자의 말&lt;/h2&gt;&lt;p&gt;번역되는 단어 중에 Higher-level language는 고수준 언어와 고급 언어 둘중 고민을 했으나 의미상 오해의 소지가 있더라도 많이 쓰이는 고급 언어로 표현하였습니다. (뭐 오해하면 양쪽 단어 다 오해할 가능성이 있다고 판단하였습니다.)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;아티클 본문&lt;/h2&gt;&lt;p&gt;예전에, 그 때의 그 날로 되돌아가보자면 —

 `프로그래밍 언어` 라는 것이 존재하지 않았습니다. 당시 프로그래밍은 하드웨어 위에서 조작해야 했던 때였습니다. &lt;a href="https://xkcd.com"&gt;xkcd 유머&lt;/a&gt; (역자: xkcd는 미국 랜들 먼로가 NASA를 그만두고 그린 웹툰입니다, 공대생 만화라고 보시면 됩니다)에서 다루는 `&lt;a href="https://nullprogram.com/blog/2016/11/17/"&gt;A Magnetised Needle and a Steady Hand&lt;/a&gt;`는 그다지 과장된 얘기도 아니었다고 할 수 있겠네요, 하드 디스크가 여전히 비실용적인 것 빼고는요. 그 당시 천공카드 (Punch Card)는 흔한 입력매체였습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="500" data-orig-height="254" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/393df138e813edbe5f374f9b158dd0d2/tumblr_inline_pox1a6Pbbm1td93ol_540.jpg" alt="image" data-orig-width="500" data-orig-height="254"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;그 당시에는 컴퓨에 무언가를 입력할 때 카드에 구멍을 뚫어서 사용하는 천공카드가 있었습니다.&amp;gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;(천공카드도 없었을 시절에는 컴퓨터에게 명령을 내리려면 하드웨어 레벨에서 조작 따위를 했어야 했습니다. 심지어 &lt;a href="https://en.wikipedia.org/wiki/Plugboard"&gt;플러그보드&lt;/a&gt;를 사용했던 세대보다 더 예전으로 거슬러 올라가면 우리가 다루고 있는 것이 컴퓨터라는 것을 알고있음에도, 무엇을 다루고 있는지조차 정확하지 않을 수준까지 갑니다.)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="740" data-orig-height="406" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/e8ed9f896589cbb05a9ffa05e4025e8e/tumblr_inline_pomccnXAxQ1td93ol_540.png" alt="image" data-orig-width="740" data-orig-height="406"/&gt;&lt;/figure&gt;&lt;p&gt;&lt;a&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;물론 이런 종류의 프로그래밍은 굉장히 어려웠고 지루했으며 오류도 자주 발생했습니다. 텍스트 기반의 어셈블러는 천공카드 시대에서도 존재해 왔습니다. 적어도 프로그래머들에게 읽을 수 있는 무언가를 제공하긴 했습니다—제 말은 읽을 수 있는(아마도 사람이 이해할 수 있는&amp;hellip;) 최소한의 무언가를 제공했었다는 것이죠. 그렇다고 해도 여전히 개발 환경은 하드웨어와 1:1로 대응시켜야 했습니다. 그 당시 진정한 혁명할 수 있는 1957년 포트란(Fortran), 1958년 알골(ALGOL), 1964년 베이직(BASIC), 1968년 파스칼(Pascal)이 등장했었고, 마침내 1972년에 C라는 언어가 등장했습니다. 이들 중 마지막으로 등장한 C는 정말&amp;hellip; 진정한! 혁명이었습니다.&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;C는 최초의 고급 언어(Higher-level language)는 아니었지만, 오늘날 사용하는 3세대 언어 중에서는 유일한 언어라고 볼 수 있습니다. C가 성공할 수 있던 비밀은 어셈블리 언어로 작업되었던 운영체제를 대체할 수 있도록 디자인 되었기 때문입니다. 그렇기 때문에 몇가지 안되는 기본 구조로 어느정도 낮은 수준의 하드웨어 인터페이스를 구성할 수 있도록(어셈블리 코드로 쉽게 변경할 수 있는 구조) 제공되었으며 복잡한 구성을 추상화 할 수 있는 기능또한 제공되었습니다. 제가 숫자에 대해서 자세히 알지 못하고 또 그것을 추정하는 방법도 잘 모르지만, 오늘날에 돌아가는 99.999%의 대부분 코드들이 첫번째로 C, 두번째로 C로부터 파생된 언어들 (예를들어 C++) 세번째로 그런 언어들로 부터 탄생한 VM에서 돌아가는 언어들로 구성되있다고 추정하고 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;C는 훌륭한 언어임에는 틀림없지만 결국 어렵고 지루하며 자주 에러를 발생시킨다고 여겨지게 되었습니다. 그리고 누군가 그 위에 추상화 계층을 얹기 시작하였습니다. 그렇게 1985년에 C++이 등장하게 됩니다. C++은 아마 이렇게 탄생한 언어 중에서는 가장 먼저, 그리고 어쩌면 가장 단순한 언어일 것입니다. C++은 프로그래머에게 객체지향 구문을 제공하는 C언어의 파생 언어입니다. [Update: 일부는 이 주장에 대해 논쟁을 하고 있지만, 중요한건 이 언어가 그렇게 시작되었다는 것입니다.] C++은 C 언어가 하는 것처럼 동일한 기계어로 컴파일을 할 수 있고(적어도 이론상으로는) 상당히 엄격하게 C로도 컴파일 할 수 있습니다. 실제로 초기 C++ 컴파일러는 이렇게 동작되었습니다. 물론 지금의 C++은 더 이상 이러한 방식으로 동작하는 유일한 언어는 아닙니다. 소위 `시스템 프로그래밍 언어`라고 불리는 고급 언어(C보다 더 고 수준의 언어)의 범주에 속하는 언어들은 최근 C++ 표준의 막장 행보로 인해 과도기를 경험했었고 그로인해 사람들은 결국 이런 계열의 언어 또한 어렵고 지루하게 느끼기 시작했습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;성능이 중요한 응용 프로그램 (정확하게 말하자면 성능이 불충분한 장비에서 돌아가는—사람들이 체감하거나 말거나 성능은 항상 중요합니다)에서 C++은 이런 환경에서 최고존엄처럼 사용됩니다. 오늘날 어쩌면 현세대 최고의 대체 시스템 언어 러스트(Rust)도 호시탐탐 기회를 노리고 있다곤 하지만 그렇다고 C++이 어디론가 사라지거나 하진 않습니다. (적어도 Rust가 좋은 C++ 호환 기능을 제공할 때 까지는 남아있을 것입니다. 그리고 C++이 다른 언어에 대체된다고 해도, 대체 과정은 상당히 천천히 이루어질 것이고 절대 C++이 사라지거나 하진 않을 것입니다.) 대부분의 사용자 프로그램은 (게임을 제외하고, 아니, &lt;a href="https://unity.com/"&gt;심지어 게임마저도&amp;hellip;&lt;/a&gt;) 장비가 매우 빨라 성능이 거의 고려되진 않습니다. 모바일 앱 개발 방식은 마케팅과 나태함을 바탕으로 하고 있으며 최근 가시적인 성능의 변화들은 시장성 갖는다고 보기가 어렵습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;결과적으로 VM에서 돌아가는 추상화된 언어들이 폭발적으로 그리고 (제 주관으로는) 지속 불가능할 수 없는 수준으로 성장했습니다. 베이직(BASIC)을 이곳에 속하는 언어로 치지 않는다면, 1995년에 자바(JAVA)가 이 계열에서 먼저 시작되었습니다. 자바의 개념은 간단하고 훌륭했습니다: 자바가 컴파일 하는 해석문(이 경우 바이트 코드(bytecode)은 OS와 하드웨어의 세부사항을 추상화 하였고 개발자는 모든 고객들에게 결과물인 `바이너리(binary)`를 제공할 수 있었습니다. 운영체제 추상화를 통해 보안은 향상되었지만, 네트워크를 통해 넘어온 신뢰성 없는 코드를 실행할 수 있기 때문에 좋다고 보기에는 어쩌면 충분하지 않을 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;물론 단점은 성능이었습니다. 1995년대에 비해서는 오늘날은 더 나아졌지만, 오늘날에도 여전히 이클립스(Eclipse)를 여는 것은 그다지 달갑지 않습니다. (자바 기반의 커맨드라인 도구들은 더합니다, JVM의 경우 엄청 느리지는 않지만 시작하기까지 시간과 정신의 방에 갇혀있어야 합니다.)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;자바가 그렇다고 해서 C++과 비교했을때 추상화 측면에서 그다지 발전한 것도 아닙니다. 물론 여러 플랫폼에 대한 독립성 지원은 훌륭하지만 C++에서도 모던 크로스 플랫폼 라이브러리와 데브옵스(DevOps) 툴을 사용하면 플랫폼 의존성의 (미미한)비용은 거의 제로에 가깝습니다. 자바로 개발하는 것이 쉬운편도 아닙니다. 그렇다고 해서 메모리 관리가 훨씬 자동적인 것도 아닙니다 (동적으로 증가하는 배열은 어디에 있나요?) 타이핑은 C보다 강력하다 할 수 있습니다. (자바에서 클래스를 자체적으로 캐스팅하려고 할 때 오류를 받아볼 수 있습니다!). 여전히 자바는 거지같은 null 포인터(C에서 모두가 고통 받는 그것)를 가지고 있습니다. 앞서 말했듯이 보안은 20년동안 유닉스가 제공했던 때 비해서는 듣도보도 못한 `바이트 코드`를 제공하기 때문에 낫긴 합니다만 지금까지도 소름돋게도 비효율적으로 사용자가 코드를 실행하고 있습니다. (즉, 네트워크 전반에 신뢰할 수 없고, 유효성이 보장되지도 않으며 또 그 네트워크 전체에서 보이지 않는 경우도 자주 있습니다.)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;자바 쇠퇴의 결과가 오래동안 쌓아온 네이티브 표준으로 돌아가는 것이 아니었습니다. 되려 더 높은 고급 언어로 움직이기 시작 했습니다. 실제로 자바와 관련이 없는 자바스크립트(Javascript)가 1995년에 공개된거죠. 하지만 자바스크립트는 애플이 플래시를 아이폰에 넣지 않기로 결정하기 전까지, 거진 10년 반 동안 별 다른 성과없이 지진부진하였습니다. 자바스크립트가 빛을 보지 못한 그 동안 이른바 `&lt;a href="https://ko.wikipedia.org/wiki/%EC%9B%B9_2.0"&gt;Web 2.0&lt;/a&gt;`이라고 부르는 플러그인을 대체하는 표준 등이 개발에 제동을 걸었습니다. 최신 웹앱은 어떠한 의미로는 자바의 모든 문제를 해결 한 다음 완전한 크로스 플랫폼을 지원하고, 자동으로 제공되었으며 

 사용자의 시스템에 접근을 어느정도 제한하였습니다. 설령 사용자가 원한다고 하더라도 말이죠. 최종적으로 이런 방식이 쉽게 개발할 수 있게 하는 방법 중 하나였습니다. 자바스크립트는 언어 관점에서 볼 때 실수가 발생하기 쉬운 언어입니다. (올바르게 작성하는 것이 더 어렵지만, 더 이상 사람들은 올바른지는 신경을 쓰지도 않습니다)  `진정한 프로그래밍`과는 별도로 마크업 언어로 된 UI를 디자인 (특히 테마를 지정)하는 것이 실질적인 이점이라 볼 수 있는 언어입니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;지금에 와서는 웹앱이 &lt;a href="https://www.chromium.org/chromium-os"&gt;크롬 OS(Chrome OS)&lt;/a&gt;와 &lt;a href="https://electronjs.org/"&gt;일렉트론(Electron)&lt;/a&gt;이라는 산물을 남겼습니다. 또한 자바스크립트는 &lt;a href="https://nodejs.org/ko/"&gt;노드(Node.js)&lt;/a&gt;를 통해 서버 프로그래밍에서도 사용할 수 있게 되었고요. 이것이 오늘날의 모던 웹 개발 방향입니다. 우리가 좋아하건 아니건 말입니다(어쨋건 둘 모두 많은 논쟁이 있지만요). 그렇다고해서 비판을하지 말자는 것은 아닙니다: 생각해봅시다 여러분이 브라우저만 돌아가는 상용 운영체제를 가지고 있다고 가정할 때, 과연 경량화된 운영체제를 사용하고 있다고 생각하나요? 아니면 말 그대로 &lt;a href="https://josephg.com/blog/electron-is-flash-for-the-desktop/"&gt;미쳐날뛰는 브라우저&lt;/a&gt;를 가지고 있다고 생각하나요?&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="1888" data-orig-height="704" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/f3ac292c7e509c883b59d842e561dcc4/tumblr_inline_pp0jijzFcl1td93ol_540.png" alt="image" data-orig-width="1888" data-orig-height="704"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;데스크탑 환경의 어플리케이션도 웹 프론트엔드 개발자들이 진입할 수 있게 해준 일렉트론&amp;gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;크롬(Chrome)을 운영체제(OS)라고 부르는 것도 과장이 아닙니다. 코드 라인으로 보면 크롬은 리눅스 커널과 거의 동급의 크기를 자랑합니다. 마치 리눅스 커널처럼 &lt;a href="https://ko.wikipedia.org/wiki/OpenGL"&gt;OpenGL&lt;/a&gt;, &lt;a href="https://ko.wikipedia.org/wiki/%EA%B0%80%EC%83%81%ED%98%84%EC%8B%A4"&gt;VR&lt;/a&gt;, &lt;a href="https://ko.wikipedia.org/wiki/MIDI"&gt;MIDI&lt;/a&gt;와 같은 모든 종류의 하드웨어를 위한 API를 가지고 있습니다. 또한 &lt;a href="https://www.sqlite.org/index.html"&gt;SQLite&lt;/a&gt; 임베디드 copy, 메모리 관리, 자체적인 테스크 매니저와 같은기능을 탑재하고 있습니다. macOS 버전에서는 심지어 Xbox 360 컨트롤러용 사용자 영역의 USB 드라이버가 포함되어 있습니다. (제가 작성했었기 때문에 그게 거기 있는 걸 알아요. 미안해요.) &lt;a href="https://slack.com/"&gt;슬랙(Slack)&lt;/a&gt;에는 제가 작성한 Xbox 컨트롤러를 위한 코드들이 포함되어 있나요? 슬랙 팀은 혹시 알고 있나요? 혹시 아시는 분 있나요?&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;어쩌면 크롬은 대부분의 리눅스 배포판보다 우수한 운영체제라고 부를 수 있을 겁니다—적어도 개발자들은 그렇게 부를 겁니다. 크롬은 대부분의 운영체제 API를 유난히 짜증스럽게 만드는 특유의 레거시의 산물이나 &lt;a href="https://caseymuratori.com/blog_0025"&gt;특징&lt;/a&gt;이 전혀 없습니다. 더군다나 이러한 API들은 표준을 기반으로 하고 있었기에 개발자들로 하여금 부수적인 추가 작업 없이도 사용자는 자유롭게 여러 브라우저를 선택할 수 있습니다. 사용자 어플리케이션을 위한 개발 플랫폼으로서 웹은 최고의 선택이 될 수 있습니다. 물론 많은 사람들이 웹으로 넘어가고 있는 이유이기도 하고요.&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;문제는 모든 것이 자바스크립트에서 동작하고 보여지는 것입니다. 

고작 &lt;a href="https://en.wikipedia.org/wiki/JavaScript#History"&gt;10일만에 설계된 언어&lt;/a&gt;에서요. 이런 사실에도 자바스크립트 좋은 코드를 작성하는 것은 쉬운일이 아닙니다. 엄밀하게 말하자면 수용가능한(acceptable) 자바스크립트 코드를 작성하는 것은 쉽기 때문에, 좋은 코드작성이 어렵게 된 것이지요. 인터프리터 관점에서는 수용가능한 문법(acceptable )은 수용가능한 것이 아닙니다. 자바스크립트를 단지 1할만 알더라도 어느정도 돌아가는 코드를 작성할 수 있습니다. (그리고 여러분이 만약 &lt;a href="https://cdn-images-1.medium.com/max/1200/1*O5c7M-jeJ8Ht_oeEIh1IAg.jpeg"&gt;제대로 된 1할&lt;/a&gt;을 배웠다면 더 좋은 코드를 작성하겠죠) 하지만 인터프리터는 잘 작성된 코드와 안 좋은 코드, 심지어 망가진 코드도 다룰 수 있어야 합니다. 때로는 처절하리 만큼 망가진 코드가 들어와도 말입니다. 이것들이 의미하는 바는 (a) 추상화의 비용은 기하급수적으로 늘어나고 있고, (b) 이런 비용을 줄이는 것은 정말로 큰 과제가 되었다는 것입니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;figure data-orig-width="680" data-orig-height="400" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/7edfadd7e7b505ea0b68de8cd269f651/tumblr_inline_pp0j99F3ob1td93ol_540.png" alt="image" data-orig-width="680" data-orig-height="400"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;같은 V8이라도 그 구조의 복잡성은 너무나도 다를 것입니다 - 그림 출처 위키피디아&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;앞서 말씀드린 문제들을 해결하지 못한 것은 아닙니다. 오늘날에 가장 유명한, 어쩌면 가장 빠른 자바스크립트 엔진은 구글의 V8입니다. V8 엔진은 크롬에서도 사용되고 있습니다(아시다시피 노드와 일렉트론도 이 엔진을 기반으로 합니다). 이 엔진 이름은 의심의 여지도 없이 고성능 자동차 엔진을 연상시키지만, 만약 V8이 &lt;a href="https://en.wikipedia.org/wiki/V8_engine"&gt;진짜 자동차 엔진&lt;/a&gt;이라고 불리기 의도했었다면, 아이러니하게도 절대로 V8이 될 수 없을 겁니다. (역자: 이 엔진이 자동차 엔진 V8로 비유하기에는 너무.. 너무 무거워졌다는 의미를 내포합니다) 만약 당신이 중요하게 보는 것이 복잡성과 유지 보수 비용이라면 부가티 베이론(Bugatti Veyron)의 엔진인 `W16`이 될순 있을 듯 합니다. 이 엔진은 16기통 엔진에 4개의 터보 차저를 가지고 있어 마치 대형 트럭에 들어가는 엔진처럼 오일 교환 비용이 21,000 달러에 육박합니다. 아마도 구글 V8 엔진을 사용하는 것은 170만 달러짜리 슈퍼카로 심부름을 하는 것과 완전히 똑같지는 않겠지만 연비(혹은 메모리 사용율)가 굉장히 나쁜 차량을 몰고 있는 것과는 같습니다. 적어도 이 경우에 누군가 기름을 교체하고 있습니다 (역자: 메모리, CPU 성능은 계속 향상되고 있다는 의미입니다).&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;하지만 기름 (그리고 부가티)가 무료로 제공된다면 어떨까요, 우리는 매일 부가티를 몰고 기름을 사용하겠죠. 이 상황이 일반적인 무어의 법칙의 상황이라 볼 수 있습니다. 성능이나 자원 상태가 10% 가량 향상되더라도(대규모 프로젝트에서는 별반 차이가 없습니다) 3개월 뒤에는 거의 사용하지 않아 시장에서 버려집니다. 따라서 건전한 비즈니스 결정에서는 최적화를 포기하고 여러분의 소프트웨어 스택에 그냥 쓰레기를 계속 쌓아올리게 됩니다. 무어의 법칙은 아래의 &lt;a href="https://www.youtube.com/watch?v=kZRE7HIO3vk&amp;amp;feature=youtu.be"&gt;그래프에서 보이는 것&lt;/a&gt;(리눅스 커널의 코드 라인)으로부터 우리를 지켜내 주었습니다.&lt;/p&gt;&lt;figure class="tmblr-embed tmblr-full" data-provider="youtube" data-orig-width="540" data-orig-height="304" data-url="https%3A%2F%2Fyoutu.be%2FkZRE7HIO3vk"&gt;&lt;iframe width="540" height="304" id="youtube_iframe" src="https://www.youtube.com/embed/kZRE7HIO3vk?feature=oembed&amp;amp;enablejsapi=1&amp;amp;origin=https://safe.txmblr.com&amp;amp;wmode=opaque" frameborder="0" allowfullscreen="allowfullscreen"&gt;&lt;/iframe&gt;&lt;/figure&gt;&lt;p&gt;코드 양이 지금도 폭발적으로 증가하고 있지만 우리가 사용하고 있는 프로세서의 속도가 훨씬 빠른 속도로 증가하고 있기 때문에 코드 양의 증가는 더 이상 중요하지 않게 되었습니다. 그렇다곤 하지만 무어의 법칙은 영원히 유지될 수 없고, 이젠 더 이상 그런 것은 변명거리조차 되지 못합니다. 양자제한 효과로 인하여 트랜지스터 사이즈의 한계는 이미 우리 코 앞으로 들이닥쳤습니다. 그렇기에 앞으로 더 빠르고 좋은 프로세서를 만들기 위해서는 새로운 기술이 필요한 상태이며, 프로세서의 처리능력(적어도 가격 대비)은 상당히 오랜기간 정체된 상태로 있게 될 것입니다—적어도 무어의 법칙이 통했던 시대에 비하면 말입니다. 지금 이 순간 프로세서 사양이 정체로 다가오게 된다면(2021년 쯤으로 예상합니다) 폭발적이었던 코드 양의 증가가 점점 그에맞는 사양이 따라오지 못해 위험해지는 시기가 올 것입니다. 또한 무어의 법칙은 컴퓨터를 더 빠르게 그리고 저렴하게 만들 수 있었습니다. 예전에는 PC도 가질 수 없었던 사람들이 지금에 와서는 최소한 스마트 폰은 가지고 있으며 사용하고 디바이스도 굉장히 다양해졌습니다. 이러한 두가지의 변화들에 의해 앞으로는 서서히 다가오는 위기를 맞이하게 될 것입니다. 따라서 `계획적구식화(planned obsolescence)` (역자: 새 제품이 나올 때 쯤에 이전 시리즈의 제품에 고의적으로 성능을 느리게 만들거나 구식이라는 이미지를 심어주어 대체 수요를 늘리는 등의 정책을 말합니다)는 곧 붕괴하고 불타오를 것입니다. 그렇게 추상화의 위기가 찾아오고 모든 것이 붕괴한다면 당신은 어디에 있으실건가요?&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;당신이 웹 개발자라고 한다면 달리말해 준비되지 않았다고 할 수 있습니다. 그 이유는 오늘날의 웹 개발 트랜드는 간단한 코드나 더 적은 추상화 레이어로 흘러가고 있지 않기 때문입니다. 물론 여기에도 몇가지 재밌는 예외사항이 있긴 합니다. 이에반해 대부분의 웹 응용 프로그램은 더 많은 추상 레이어를 덧대고 복잡해져 거대한 프레임워크로 구축되고 그렇게 덧대진 웹 응용 프로그램은 여러분의 4개의 터보 차저를 가진 W16 위에(역자: 아까 언급한 크롬을 말한겁니다) 올라가게 됩니다. 사람들은 30분 안에 앱을 만들 수 있기를 원하고 프레임워크를 사용하면 실제로&lt;a href="https://www.youtube.com/watch?v=w2TcYP8qiRI&amp;amp;feature=youtu.be"&gt; 그렇게 할 수도 있습니다&lt;/a&gt;. 하지만 말입니다 따라오는 성능 단점들은 제외한다 치더라도 이게 정말 올바른 소프트웨어 개발이라고 불릴 수 있을까요?&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;물론 웹 프레임워크 비유가 그렇게 많은 성능에 있어 단점을 가져오지는 않습니다. 웹에서 코드를 실행하고자 한다면 코드를 그때그때 다운로드 해야 하기 때문에 심지어는 CPU 사용률도 이제 더 이상 (커다란) 문제는 아니게 되었습니다. 리액트(React) 앱은 개발자가 코딩을 시작하기도 전에 무려 &lt;a href="https://youtu.be/pBYqen3B2gc?t=110"&gt;79,905라인의 자바스트립트 코드&lt;/a&gt;를 필요로합니다. 좋습니다. 아무래도 리액트는 공평하지 않은 예시일 수 있습니다—페이스북 제품이니깐요. 페이스북은 &lt;a href="https://www.darkcoding.net/software/facebooks-code-quality-problem/"&gt;앞서언급한 것과 유사한 문제들을 가지고있기로 알려져 있습니다&lt;/a&gt;. 그렇다곤 해도 리액트는 굉장히 유명합니다, 그 말은 즉슨 로드 될 때마다 80,000 라인의 코드를 다운로드하는 수 많은 리액트 네이티브 베이스 앱들이 지천에 널려있습니다. (위에서 언급한 기사에서 말하는 통계를 바탕으로 알 수 있는 충격적인 사실은, iOS 버전의 페이스북 앱이 18,000개의 Objective-C 클래스를 포함하고 있고 이것이 리액트가 동작하는 직접적인 결과를 의미합니다. 특히 리액트 네이티브(React Native)로 알려진이 

저품질의 야매 프로젝트에서요. 하지만 이건 원 주제와 관련이 없는 이야기입니다) 다른 프레임워크는 조금 더 나을지도 모르지만 얼마나 더 나을까요? 심지어 제이쿼리(jQuery) 마저도 86 킬로바이트의 크기를 자랑합니다: 최근에는 더 작아졌겠지만 여전히 배보다 배꼽이 큰 경우가 많습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;아 그리고 우리가 엄청난 크기의 프레임워크를 논하고 있을 때 그게 엄청난 양의 &lt;b&gt;자바스크립트 코드&lt;/b&gt;라는 것을 명심하세요—그 프레임워크는 또 약 백만 라인 가까이 되는 크기의 VM 위에서 실행되고, 또 그건 크기가 무려 수천만 라인에 도달하는 OS가 실행시게 됩니다. 물론 모든 자바스크립트 코드들이 각각 한줄씩 전부 실행되는 것은 아닙니다—어쩌면 수많은 코드들이 전혀 실행되지 않을 수 도 있습니다—하지만 고작 작은 기능을 만드는데 수 많은 코드를 토해냅니다. 80,000 라인의 자바스크립트 코드와 같은 기능을 C로는 몇 줄로 대체 가능할까요? 해답을 듣고 싶으세요? 어쩌면 더 중요한 것은 얼마나 많은 라인이—아, C 대신 C++ 이라고 가정하고 생각해봅시다—간단한 UI 마크업 언어와 C++ API를 사용하여 어느정도 React.js와 동등한 앱을 만들 수 있을까요? 어쩌면 80,000 라인보다 더 많이 필요할 수도 있습니다—어쩌면요.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;(리액트에서 할 수 있는 모든 것들을 소화해낼 수 있는데도 그 단순함은 잘 알려지지 않은 

큐티(Qt)는 대략 470,000 라인의 C++ 언어로 구성되어 있습니다—이는 리액트의 80,000 라인보다 6배 가까이 많은 양에 육박하지만 V8 엔진의 크기에 비해서는 &amp;frac14; 정도의 크기이며 크롬보다는 20배 가까이 작습니다.)&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;그렇다고 해도 여전히, 주사위는 던져졌습니다. 사람들이 다시 저급언어로 앱 개발을 하면 좋겠지만 그럴 것 같지는 않아보이네요. 대신 어쩌면—아마도 어쩌면—

90년대, 심지어 2010년으로 거슬러 올라가지는 못하더라도 쓸모없는 코드들이 기하급수적으로 늘어나기 직전, 한발짝 물러설 수 있는 방법이 있을 것 같습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;우리가 가장 먼저 해야할 것은 웹 프레임워크 문화 최악의 국면을 되돌리는 것입니다. 솔직히 말하면, 앱을 라이브 환경에서 실시간으로 빌드하거나, 심지어 이를 24시간 안에 할 수 있는 능력들은 득보다 실이 많은 쓸데없는 눈속임입니다. 구글 엔지니어는 30분의 대화 속에서도 실제로 전달가능한 제품을 만들 수 있다고 생각할 만큼 어리석지는 않겠지만, 여러 개발자들 속에서 이런 컨셉을 시연해야하는 것은 어쨋거나 나의 책임감을 미치도록 건드립니다. 제 말은, 아 제발요—어디선가 &lt;a href="https://www.columbia.edu/~ng2573/zuggybuggy_is_2scale4ios.pdf"&gt;페이스북 직원&lt;/a&gt;이 보고있을지도 모른다고요. 거대한 테크 회사들이 그들의 정교한 커스텀 솔루션들을 오픈 소스로 제공하는 것과 그것들을 지루한 대학생들을 상대로 어떤 유행이나 돈 욕심으로 마케팅을 하는건 엄연히 다릅니다. 저는 잘못 만들어진 것들을 누군가 처음부터 다시 만들 수 있다고는 말하지 않을 것입니다. (꼭 그래야 하는 건 아닙니다) 하지만 모든 프로그래머가 그런식으로 생각하게 된다면 세계의 소프트웨어 품질의 평균이 어떻게 변할 것이라고 생각하시나요? &lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;그 다음으로는 OS와 브라우저 벤더사들은 그들의 API를 개선시킬 필요가 있습니다. 예를들어 제이쿼리는 일반적으로 모던 웹 표준입니다.—이런 API는 표준 DOM API와 철처하게 경쟁을 벌여왔습니다. 그리고 그건, 음, 좋진 않아요. 브라우저 제작사들은 (적어도 핵심 부분들은) 분명한 조치를 취하고 제이쿼리를 브라우저 내에 포함시킬 필요가 있습니다, 자바스크립트를 대신하여 자연스럽게 실행시키기 위한 수많은 공통 코드들을 허용하여 말 그대로 수십억개의 페이지 로드에서 페이지 각각 86 킬로바이트를 줄일 수 있습니다. 데스크탑에서 동작하는 서드파티들도 똑같이 적용할 수 있습니다—제이쿼리 처럼 분명한 예시는 없지만 &lt;a href="https://www.libsdl.org/"&gt;SDL&lt;/a&gt;과 같이 예시는 분명히 있습니다. (이건 기본적으로 &lt;a href="https://www.boost.org/"&gt;Boost&lt;/a&gt;에 대응되는 C++  표준화 도구입니다. $(&amp;hellip;) 셀렉터는이제 대부분의 브라우저에서  제이쿼리 없이도 사용할 수 있게 되었습니다. 따라서 이것이 시작이라 볼 수 있겠네요.)&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;세번째로는, 최소한 현재 형태를 유지하며 자바스크립트를 떼어내야 합니다. 대부분의 경우 자바스크립트는 구진 것이 분명하기 때문에 결코 새로운 아이디어가 아니지만, 최근에서야 이를 시작하기 위해 필요한 도구들을 만들었습니다. 웹 어셈블리(WebAssembly) 마침내 네이티브 레벨에서 지원되고 있으며-자바스크립트를 대체할 수 있도록 모든 브라우저 안에서 서포트되고 있습니다—다음 단계는 웹 어셈블리를 기본 대상으로 하도록 옮기는 것이며, 아마도 최종적으로는 유일한 선택이 될 것입니다. 최소한의 사이드 이펙트만으로 이 작업을 하려면 자바스크립트를 웹 어셈블리(WASM)로 컴파일하는 방법이 필요합니다. 결코 쉬운 작업은 아닙니다—아까전의 `W16` 문제로 돌아갑시다. 그럼에도 불구하고, 기존 자바스크립트 엔진은 자바스크립트를 컴파일 하므로 코드를 즉시 실행하는 대신 디스크에 덤프하는 것

(아마도 LLVM 바이트 코드로) 

은 그렇게 어렵지 않습니다. &lt;a href="https://github.com/AssemblyScript/assemblyscript"&gt;어셈블리 스크립트(AssemblyScript&lt;/a&gt;)는 이미 타입스크립트(Typescript)를 

(자바스크립트에 동적 타이핑을 추가한 마이크로소프트가 만든 확장형 언어)

 웹 어셈블리로 컴파일 할 수 있습니다. 거의 다왔습니다. 하지만 웹 어셈블리는 현재 너무나도 효율적으로 샌드박스화 되어 있기에 웹 어셈블리–자바스크립트 인터페이스는 거의 대부분 재설계되어야 할 것입니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;마지막으로, 하드웨어와 사용자들이 실제로 소프트웨어를 작성하는 지점 사이의 모든 쓰레기들을 치워야합니다. 게리 베른하르트(Gary Bernhardt)의 유명한 이야기 중 `&lt;a href="https://www.reddit.com/r/programming/comments/23akbx/the_birth_death_of_javascript_a_history_from_1995/"&gt;자바스크립트의 탄생과 죽음&lt;/a&gt;` (유머스럽게 `야마스크립트(YavaScript)`라고 발음합니다)는 풍자적으로 커널을 웹 어셈블리 VM으로 대체할 것을 제안했습니다. &lt;a href="https://github.com/nebulet/nebulet"&gt;실제로 이 아이디어는 시도 되었지만&lt;/a&gt; 아마 너무 멀리 갔었던 듯 합니다. 그렇다곤 해도 충분히 현실적인 아이디어로도 사용될 수 있을거라 생각합니다. 발 윈도우 매니저와 

전체 화면

데스크탑 `쉘(shell)`을 보이지 않는 브라우저의 윈도우로 대체하고, 가상 프레임 버퍼(Virtual frame buffers)와 GL 컨텍스트를 레거시 응용 프로그램과 게임에 제공하는 것입니다. 이게 오버헤드처럼 들릴 수도 있겠지만 실제로는 생각보다 더 적은 비용으로 끝나게 됩니다: 당신의 새로운 브라우저는 &amp;lt;iframe&amp;gt;이라고 볼 수 있습니다. 따라서 모든 것이 일렉트론 앱이라고 칭할 수도 있습니다. (실제로, 일렉트론 쉘은 그 자체로 그런 프로젝트의 좋은 출발점이라고 볼 수 있습니다.) 더 이상 각 응용 프로그램마다 별도의 랜더링 툴킷을 실행 시킬 필요가 없게 됩니다. 모든 것은 표준에따라 작성되고 하나의 공용 랜더러에 의해 랜더링 되며 50%의 여러분의 메모리 사용량이 그냥 사라집니다. 공통 표준은 현재 웹에서 사용되고 있는 것들처럼 될 필요조차 없습니다, 물론 웹 표준이 필요한 무수한 이유가 있고 그것이 없어져야할 이유는 극히 적다고 봅니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;제가 제시한 새로운 세계도 결국 완벽하진 않습니다. 만약 수 많은 C++ 개발자들이 겁에 질리더라도 이해합니다. 지옥, 그것이 저를 두렵게 만듭니다(C/C++ 개발자). 하지만 1972년 핵심 소프트웨어에서 부터 겹겹이 쌓아올린 거대한 양파에서 살고 있는 우리 세계보다는 두렵지는 않습니다. 오늘날 우리가 소프트웨어 스택에 쌓아올린 각각의 연속된 껍데기들은 적색거성과 같이 부풀어 오를 것이고 조만간 초신성이 되어버릴 것입니다. 소프트웨어에서 필요한 것은 

개발자가 간단한 API를 사용하여 보안이 허용하는 한 하드웨어에 가깝도록 응용 프로그램을 구성할 수 있는 시스템 수준으로1972년에 있던 것에서 그 이상 이하도 아니거나 더 적을 것입니다. 우리가 가진 문제는 실제로 하드웨어 가까이에서 실행되는 시스템이 1972년 기술로서 구축되었지만 실제로는 그 이후 제대로 다루어지지 않았습니다. 성능을 잡아먹는 추상화 계층 위에 덮히고 또 덮히고 또 덮힌 껍데기—그리고 그 결과들—오직 예측과 예방만이 가능해 왔었습니다. 그리고 이제는 고칠 수 있기를 바랍니다.&lt;/p&gt;</description><link>https://blog.pigno.se/post/183565621043</link><guid>https://blog.pigno.se/post/183565621043</guid><pubDate>Wed, 20 Mar 2019 00:40:47 +0900</pubDate><category>excerpt</category></item><item><title>Stanford CS231n(1/16) - Introduction to CS231</title><description>&lt;figure data-orig-width="1348" data-orig-height="501" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/60d66ba54120f6a341bfee42a4659d0c/tumblr_inline_po7lk4SdXf1td93ol_540.png" alt="image" data-orig-width="1348" data-orig-height="501"/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Stanford CS231n은 AI를 공부하는 연구자, 엔지니어라면 한번쯤 거쳐갈 법한 이름있는 강의입니다. 필자는 다소 늦었지만 (어쩌면 많이 늦었지만) 이 강의를 정주행하면서 여러가지 내용들을 정리하고 회고하고자 하는 목적으로 이 포스트 시리즈를 작성합니다.&lt;/p&gt;&lt;p&gt;&lt;a href="http://vision.stanford.edu/index.html"&gt;Fei-Fei Li&lt;/a&gt; 교수 및 &lt;a href="http://cs.stanford.edu/people/jcjohns/"&gt;Justin Johnson&lt;/a&gt;, &lt;a href="http://ai.stanford.edu/~syyeung/"&gt;Serena Yeung&lt;/a&gt; 강사로 이루어진 CS231n 2017 Spring 강의를 16 Lectures까지 듣고 요약 하는 것이 시리즈의 대부분입니다. 그 밖에 코드를 밑단부터 직접 짜보고 내가 짠 코드의 결과와 강의의 의도가 얼마나 비슷하고 내가 잘 이해한 것인지 회고하는 등의 활동으로,&lt;/p&gt;&lt;p&gt;우리 블로그 “PIGNOSE Barn”(연구용 목적 블로그)에 맞게 블로그를 연재해보고자 합니다. 이 포스트에서는 간단한 시리즈 서두와 비록 첫 포스트임에도 1강에 대한 요약을 진행합니다.&lt;/p&gt;&lt;!-- more --&gt;&lt;h2&gt;포스트 시리즈를 준비하며&lt;/h2&gt;&lt;p&gt;Stanford CS231n 포스트 시리즈는 다음을 염두하고 구성합니다.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;독자는 AI 필드에 초심자로 가정합니다.&lt;/li&gt;&lt;li&gt;최대한 많은 링크들을 모든 단어에 하이퍼링크로 연결해둘 것입니다. 여러분은 클릭 한번으로 자세한 자료들을 볼 수 있습니다.&lt;/li&gt;&lt;li&gt;모든 포스트는 한글로 작성됩니다. 필요에 따라 원문을 첨부하지만 이는 번역문도 같이 첨부됩니다.&lt;/li&gt;&lt;li&gt;모르는 내용이 있으면 댓글로 달아주세요, 더 자세한 내용으로 업데이트 합니다.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;래퍼런스&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="http://cs231n.stanford.edu/slides/2017/cs231n_2017_lecture5.pdf"&gt;&lt;/a&gt;&lt;a href="http://cs231n.stanford.edu/slides/2017/cs231n_2017_lecture1.pdf"&gt;http://cs231n.stanford.edu/slides/2017/cs231n_2017_lecture1.pdf&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://cs231n.stanford.edu/"&gt;http://cs231n.stanford.edu/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://aikorea.org/cs231n/"&gt;http://aikorea.org/cs231n/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=vT1JzLTH4G4&amp;amp;list=PLC1qU-LWwrF64f4QKQT-Vg5Wr4qEE1Zxk"&gt;https://www.youtube.com/watch?v=vT1JzLTH4G4&amp;amp;list=PLC1qU-LWwrF64f4QKQT-Vg5Wr4qEE1Zxk&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;이 시리즈에서 주로 다루는 것&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%EA%B3%B5_%EC%8B%A0%EA%B2%BD%EB%A7%9D"&gt;인공 신경망(Neural network)&lt;/a&gt; 흔히 말하는 &lt;a href="https://blogs.nvidia.co.kr/2016/08/03/difference_ai_learning_machinelearning/"&gt;딥러닝(Deep learning)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;특히 &lt;a href="https://kr.mathworks.com/solutions/deep-learning/convolutional-neural-network.html"&gt;컨볼루션 뉴럴넷(CNN)&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;시리즈 한눈에 보기&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://blog.pigno.se/post/183382418888/stanford-cs231n116-introduction-to-cs231"&gt;Stanford CS231n(1/16) - 현재 보고있는 포스트&lt;/a&gt;&lt;/li&gt;&lt;li&gt;TBD&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;Lecture 1: Introduction to Convolutional Neural Networks for Visual Recognition&lt;/h2&gt;&lt;figure class="tmblr-embed tmblr-full" data-provider="youtube" data-orig-width="540" data-orig-height="304" data-url="https%3A%2F%2Fyoutu.be%2FvT1JzLTH4G4"&gt;&lt;iframe width="540" height="304" id="youtube_iframe" src="https://www.youtube.com/embed/vT1JzLTH4G4?feature=oembed&amp;amp;enablejsapi=1&amp;amp;origin=https://safe.txmblr.com&amp;amp;wmode=opaque" frameborder="0" allowfullscreen=""&gt;&lt;/iframe&gt;&lt;/figure&gt;&lt;p&gt;CS231n 코스가 게시될 때마다 수강생 또한 폭발적으로 늘고 있습니다. (저번에는 약 300명이었던 수강생이 이번에는 730명의 수강생으로 확인되었다고 합니다.) 적어도 CS231n은 그런 강의이고 이번 포스팅에서 다룰 Lecture들은 2017년 봄에 녹화된 내용으로 적어도 2년이라는 시간이 흘렀습니다. 다시말해 지금은 더 많은 개발자, 리서쳐, 심지어 다른 배경에 임하는 사람들도 학구열에 불타올라 더 많은 관심을 갖는 영역이 되었습니다.&lt;/p&gt;&lt;p&gt;오늘날에는 수 많은 시각적인 이미지 데이터들이 네트워크를 넘어 웹, 모바일에 전송되고 있고. 저스틴 존슨(&lt;a href="http://cs.stanford.edu/people/jcjohns/"&gt;Justin Johnson&lt;/a&gt;)이 흥미를 가지는 통계학적 예시로는 2015년 CISCO는 2017년에 네트웍의 대략 80%의 트래픽이 비디오가 될 것으로 예상하기도 했습니다. 따라서 이런 환경에서 대부분의 업계에서 이미지와 비디오등의 시작적 이미지 처리는 상당한 수준으로 요구되었지만 흥미로운점은 이런 시각적 데이터를 이해하는 것은 기존의 컴퓨터 과학에서는 그렇게 쉬운 일이 아니었습니다.&lt;/p&gt;&lt;figure data-orig-width="1656" data-orig-height="1150" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/3883bd2e89e1979e4507cc7c6cd9e826/tumblr_inline_pp66qmnU0a1td93ol_540.png" alt="image" data-orig-width="1656" data-orig-height="1150"/&gt;&lt;/figure&gt;&lt;p&gt;컴퓨터 비전은 학계적을 많은 부분과 엮여있는 분야입니다. 서로 다른 영역에서 서로 접근할 수 밖에 없습니다. 우리 또한 이런 상황에서 학계의 여러 분야를 접근하고 있습니다. 예를 들어 물리학은 물체와 광학, 물체의 형태등을 이해할 때 필요하고, 생물학이나 심리학의 경우 동물의 뇌를 이해하거나 동물이 어떻게 실체가 있는 물질을 보고 시각적으로 그를 이해하는지의 과정을 알기 위해 요구됩니다. &lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="1652" data-orig-height="1152" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/00f47237160ec519091aca4b219a7349/tumblr_inline_pp664be0e71td93ol_540.png" alt="image" data-orig-width="1652" data-orig-height="1152"/&gt;&lt;/figure&gt;&lt;p&gt;컴퓨터 비전에 어느정도 영향력이 있는 연구 중 하나인 Hubel &amp;amp; Wiesel, 1959의 연구에 따르면, 동물이 시각적인 정보를 어떻게 처리하는지 이해하기 위해, 전기 생리학(electrophysiology)을 사용하였습니다. 인간과 유사한 뇌의 시각 처리 메커니즘 분석을 위해 고양이의 뇌의 후방의 시각정보를 관장하는 피질에 전기신호 감지 장치를 삽입하였고, 어떤 시각적인 자극이 어떤 전기신호의 변화를 주는지를 감지하고 분석하였습니다. 그 중 가장 중요한 세포들은 어떤 방향으로 이동하는 물체의 가장자리의 패턴에 반응하는 가장 단순한 형태의 세포들이었습니다. 물론 그것보다 복잡한 세포들도 존재하겠지만, 여기서 발견한 중요한 요지는 시각 처리는 가장자리의 형태와 같은 가장 작은 구조에서 시작하고 뇌는 더 복잡한 현실의 시각 정보를 인지하기 까지 이런 간단한 정보를 복잡하게 쌓아 나간다는 것을 발견한 것입니다.&lt;/p&gt;&lt;figure data-orig-width="1260" data-orig-height="878" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/48ed2d7225a5eed13c0c9e299d5c95c3/tumblr_inline_pp67d4hrIS1td93ol_540.png" alt="image" data-orig-width="1260" data-orig-height="878"/&gt;&lt;/figure&gt;&lt;p&gt;1987년 David Lowe는 면도기를 단순한 선분과 곡선으로 이루어진 정보로 부터 면도기를 구분할 수 있도록 시도했었습니다. 이런식으로 60, 70, 80년대 컴퓨터 비전에는 이런 문제들을 풀기 위한 많은 노력이 있었습니다. 그리고 솔직히 말하면 이런 물체를 인지하는 과제들은 굉장히 쉽지 않았습니다. 앞서 보여드린 이런 대담하고 야망있던 연구들은 그 연구에 비해서는 실제 우리가 사는세계에 무언가를 바꿀 수 있는 등이 아닌 몇 가지의 예시나 토이 프로젝트의 결과물만을 갖게 되었습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="1652" data-orig-height="1146" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/d6000a93604c435bb26a9fd31e75baef/tumblr_inline_pp67neNiKu1td93ol_540.png" alt="image" data-orig-width="1652" data-orig-height="1146"/&gt;&lt;/figure&gt;&lt;p&gt;사람들이 생각한 비전에 있는 문제들을 풀기 위해 있는 해법 중 하나로 물었던 중요한 질문은 “만약 물체 인식이 어렵다면 어쩌면 먼저 물체를 세그먼테이션 해보는 것은 어떨까?”였습니다.&lt;/p&gt;&lt;p&gt;이 과제는 이미지의 픽셀에서 중요한 의미를 가지는 영역등을 그룹으로 묶어줍니다. 우리는 아마 사람이라 불리는 그룹으로 픽셀을 모두 묶을 수는 없겠지만 배경으로 부터 사람에 포함되는 모든 픽셀을 추출할 수는 있습니다.&lt;/p&gt;&lt;figure data-orig-width="1656" data-orig-height="1236" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/4e71e6c8716d0046fa808002b2f9e88e/tumblr_inline_pp686nhQum1td93ol_540.png" alt="image" data-orig-width="1656" data-orig-height="1236"/&gt;&lt;/figure&gt;&lt;p&gt;또한 “얼굴 인식(Face Detection)”이라 불리는 문제가 존재했습니다. 이 문제를 통해 앞선 많은 다른 문제들의 진보도 이루어냈습니다. 사람의 얼굴은 어쩌면 사람에게서 가장 중요한 물체일 것입니다. 1999년에서 2000으로 거슬러 올라가면 머신러닝 기술은, 특히 통계적 머신 러닝 기술은 속도가 붙기 시작합니다. Support Vector Machines, Boosting, Graphical models과 첫 신경망(Neural networks)의 물결도 포함해서 말입니다. 수많은 기여자를 만들어낸 한가지 특별한 시도는 Paul Viola가 시도했던 AdaBoost 알고리즘를 사용해 실시간 사용자의 얼굴을 인식하는 것이었습니다. 이런 작업은 2001년에 끝났으며 그 때는 굉장히 느린 컴퓨터 칩만이 존재했지만 그들은 실시간 처리 환경에서 얼굴 인식을 할 수 있었습니다. 이 논문이 나오고 5년 뒤인 2006년 후지필름은 실시간 얼굴 인식이 가능한 첫 카메라를 선보였습니다. 그렇게 기존 과학 연구는 실 세계로 너무 빠르게 전환이 되기 시작했습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="1656" data-orig-height="1242" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/87e38dfb442956ff4582c760de0a7250/tumblr_inline_pp68vkoCI01td93ol_540.png" alt="image" data-orig-width="1656" data-orig-height="1242"/&gt;&lt;/figure&gt;&lt;p&gt;어떻게 물체 인식을 할 수 있는지 조금 더 따라가 보자면, 90년대에서 부터 2000년대 첫 10년간은 Feature based 물체 인식이 그 당시 가장 영향력 있는 방향이었습니다. 위 그림에서 SIFT라고도 불리는 David Lowe가 진행했던 과제를 살펴봅시다. Feature based 물체 인식의 아이디어는 간단하게도 이미지에서 보이는 모든 물체를 비교하고 매치하는 것입니다. 위 두개의 정지 표지판을 비교한다고 가정할 때 이미지 처리에서는 이 문제가 너무도 어렵다는게 느껴집니다. 아마도 카메라 각도, 물체의 가림 여부, 바라보는 방향이나, 광원등에 의한 문제일 듯 합니다. 하지만 관찰해보면 어떤 특징(Feature)들은 계속 진단을 유지할 수 있고 변화에도 불변성을 띄므로, 물체 인식은 이런 물체위의 주요 특징들을 판별하고 유사한 물체에서 이런 특징등을 찾는 테스크로 넘어가게 됩니다. 이런 작업은 모든 물체의 패턴을 매칭하는 것보다는 훨씬 문제를 쉽게 만들어줍니다.&lt;/p&gt;&lt;figure data-orig-width="1654" data-orig-height="1240" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/36ec4406f58ba8074f06b980dc1aa304/tumblr_inline_pp6aa1pFCm1td93ol_540.png" alt="image" data-orig-width="1654" data-orig-height="1240"/&gt;&lt;/figure&gt;&lt;p&gt;앞서 말한 시도들은 사람을 인식하는 곳에서도 사용되기 시작했습니다. 어떻게 사람의 신체가 사실처럼 구성되고 그걸 판별할 수 있는지에 대한 작업들 수행되었고, 이런 작업 중에 일부는 소위 “Histogram of gradients”로 불리고 있고 다른 작업은 “Deformable part models”라고 불리고 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="1656" data-orig-height="1242" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/6ace2495b5192e294bcb02b4f537c46b/tumblr_inline_pp6ay1S3cs1td93ol_540.png" alt="image" data-orig-width="1656" data-orig-height="1242"/&gt;&lt;/figure&gt;&lt;p&gt;60년, 70년, 80년대 부터 2000년 초의 10년간의 변화를 보면 크게 변한 한가지가 있는데 그건 바로 사진의 품질의 변화입니다. 인터넷과 디지털 카메라의 개선과 성장이 더 나은 데이터를 제공하고 컴퓨터 비전 학습으로 사용되어 왔습니다. 이런 변화로 인해 컴퓨터 비전 분야에서는 매우 중요한 근본 문제해결을 의해 거론하기 시작했습니다. 인식에서 풀어야 하는 가장 중요한 문제는 바로 물체 인식입니다. 2000년대 초기에 우리는 물체 인식의 현황을 측정할 수 있는 벤치마크 데이터셋을 만들기 시작했습니다. 그 중 가장 영향력 있는 벤치마크 데이터 셋 중 하나인 PASCAL Visual Object Challenge는 20 물체 클래스를 구성하고 있습니다. 그 중 3가지는 위 이미지에서도 보여지고 있습니다. (Train, Airplane, Person)&lt;/p&gt;&lt;figure data-orig-width="1658" data-orig-height="1146" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/861c39736999984b49de980022676659/tumblr_inline_pp6bw6ZR4j1td93ol_540.png" alt="image" data-orig-width="1658" data-orig-height="1146"/&gt;&lt;/figure&gt;&lt;p&gt;더 나아가 위 이미지에 나타난 세계에서 가장 큰 Visual Regnition Challenge 중 하나인 IMAGENET의 매년 이미지 인식의 에러율을 보면 보면 다행이도 에러율이 착실하게 내려가고 있는 것을 볼 수 있습니다. 여기에서 유심히 봐야할 부분은 2012년 입니다. 2010년과 2011년의 에러율에는 그렇게 큰 변화가 없었지만 2012년을 보면 약 9%의 의미있는 에러율의 가감을 보여주고 있습니다. 이 기간에 수상했던 알고리즘은 컨볼루션 신경망 모델(Convoultional Neural network model)이었습니다.&lt;/p&gt;&lt;figure data-orig-width="1654" data-orig-height="1244" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/f7d264fdfaa042020300d136378b046b/tumblr_inline_pp6c923VFD1td93ol_540.png" alt="image" data-orig-width="1654" data-orig-height="1244"/&gt;&lt;/figure&gt;&lt;p&gt;CS231n에서는 시각적 인식(Visual recognition)과 이미지 분류(Image classification)의 주요 문제들에 대해 다룹니다. 또한 물체 인식(Object detection), godehd qnsfb(Action classification), 이미지 명명법(Image captioning)과 같은 이미지 분류로 부터 오는 세부 문제에 대해서도 다루게 될 것입니다.&lt;/p&gt;&lt;figure data-orig-width="1660" data-orig-height="1242" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/f978f97ead88c5ee7debc613767b0576/tumblr_inline_pp6cu26eSn1td93ol_540.png" alt="image" data-orig-width="1660" data-orig-height="1242"/&gt;&lt;/figure&gt;&lt;p&gt;IMAGENET에서 우승했던 몇년간의 알고리즘들을 보면, 2010년 (강의에서는 2011년으로 표시됩니다.)에 Lin et al이 사용했던 방식을 볼 수 있습니다. 여전히 계층적인 구성을 가지고 있으며 다량의 레이어로 이루어져 있습니다. 여기서 알 수 있는 것은 이 방식은 여전히 계층적이고 가장자리 검출이 필요하며 이미지의 불변 영역의 개념을 가지고 있습니다.&lt;/p&gt;&lt;p&gt;하지만 2012년 토론토의 Jeff Hinton’s 그룹에서는 Alex Krizhevsky와 Ilya Sutskever는 함께 이런 상식들을 바꾸는 시도가 있었습니다. 7개로 구성 된 이 컨볼루션 신경망은 지금은 AlexNet으로 알려졌지만 당시에는 Supervision으로 불려졌습니다. 그 뒤로 매년 우승은 신경망으로 이루어져 있습니다. 그리고 트랜드는 이런 신경망의 구성을 더 깊게 만드는 것으로 변했습니다. 말했듯이 여러분이 세는 방식에 따라 다를 순 있지만 7-8개의 레이어로 구성된 AlexNet과는 다르게 2014년 (강의에서는 2015년으로 설명 함)에서 나온 구글의 GoogLeNet과 옥스포드의 VGG Net을 볼 때, 그때의 VGG는 19개의 레이어로 구성되어 있었습니다.&lt;/p&gt;&lt;p&gt;2015년에는 더 미쳐가기 시작합니다. 마이크로소프트의 Residual Network의 경우 152개의 레이어를 구성하고 있었죠.&lt;/p&gt;&lt;p&gt;여기서 알 수 있는 것은 CNN(컨볼루션 신경망)은 정말 2012년 당시 새로운 방식의 도약이었고, 많은 최적화와 튜닝 방식들에 대한 개선 노력도 있어 왔습니다. 그리고 마지막에 와서는 우리는 정말 깊이있게 딥러닝에 들어와 정확히 어떻게 모델들이 다르게 동작하는지에 대해서 이해할 수 있을 것입니다.&lt;/p&gt;&lt;figure data-orig-width="1654" data-orig-height="1238" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/4e374cad7cbb8e07095b288ef614b29f/tumblr_inline_pp6dtu7wea1td93ol_540.png" alt="image" data-orig-width="1654" data-orig-height="1238"/&gt;&lt;/figure&gt;&lt;p&gt;CNN에서 가장 기반이 되었던 작업 중의 하나였던 건, 사실은 90년대의 당시 Bell Labs에 있었던 Jan LeCun과 그의 공동 연구자들이었습니다. 1998년 해당 연구자들은 숫자를 구분하기 위한 CNN을 만들 어 낼 수 있었고, 이것을 배포하여 손글씨로 쓰여진 수표나 우체국을 위한 주소를 감지할 수 있기를 원했었습니다. 이 CNN 모델은 이미지로 부터 가져온 픽셀 데이터를 바탕으로 분류를 하여 어떤 것이 어떤 숫자로 되어 있는지, 혹은 문자로 되어 있는지 아니면 그 어떤 것도 아닌지를 분류할 수 있도록 하였습니다. 이 모델을 자세히 들여다보면 사실 AlexNet과 상당히 유사한 것을 볼 수 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;어떤 분들은 90년 대부터 있어왔던 알고리즘이 왜 갑자기 최근에 유명해지고 사용되기 시작했는지 궁금할 수도 있습니다.&lt;/p&gt;&lt;p&gt;첫번째로는 처리 능력으로 인해서입니다. 무어의 법칙 덕분에 오늘날의 컴퓨터 계산 성능은 굉장히 향상되었습니다. 또한 오늘날에 우리는 GPU의 출현을 맞이하게 되었습니다. GPU는 병렬 처리 연산을 놀라우리 만큼 훌륭하게 처리할 수 있는 완벽한 도구입니다. 이런 처리 능력의 개선들이 연구자로 하여금 더 거대한 아키텍처 구성을 할 수 있도록 길을 열어주었습니다. &lt;/p&gt;&lt;p&gt;두번째 핵심으로는 데이터가 있습니다. 이런 모델들은 데이터에 굉장한 갈증이 있고 그 때문에 우리는 수 많은 라벨링된 이미지를 준비해야 합니다. 당시 90년대에는 충분한 데이터가 없었고 아마존 Turk같은 도구도 없었고 인터넷도 지금 처럼 정말 대중적으로 사용되지 않았습니다. 때문에 다양하고 많은 양의 데이터를 구하는게 쉽지 않았습니다. 하지만 오늘날에는 PASCAL, ImageNet과 같은 비교적 큰 데이터셋이 있습니다.&lt;/p&gt;</description><link>https://blog.pigno.se/post/183382418888</link><guid>https://blog.pigno.se/post/183382418888</guid><pubDate>Tue, 12 Mar 2019 00:50:50 +0900</pubDate><category>ai</category><category>deeplearning</category><category>cs231n</category><category>cnn</category><category>stanford</category><category>ml/dl</category></item><item><title>데이터(Data)와 분석(Analysis)에는 어떤 일이 벌어지고 있느뇨?</title><description>&lt;p&gt;오랜만에 블로그 포스팅을 하는 것 같습니다. 오래전에 쓴 영양가 없는 글들도 많이 정리해서 이번에 새로운 컨텐츠 들을 많이 채워보겠습니다.&lt;/p&gt;&lt;p&gt;이번 블로그 주제는 데이터(Data)와 분석(Analysis)인데요 많은 분들이 관심가지고 있고 또 앞으로도 한동안은 이 스코프에 있는 산업군은 근심걱정이 없기도 해서 많은 주니어분들과 타 직종에 계신분들이 자주 관심가지고 보실 것 같습니다.&lt;/p&gt;&lt;figure data-orig-width="472" data-orig-height="355" data-tumblr-attribution="fuzzyghost:_aX11IKhbxGQastEZe-7YA:ZXYwBw2J9R_xE" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/158d80ef4bd646cc45cfe80782537829/tumblr_om9h4eOttb1rn5gv3o1_500.gif" alt="image" data-orig-width="472" data-orig-height="355"/&gt;&lt;/figure&gt;&lt;!-- more --&gt;&lt;h2&gt;들어가기 앞서&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;이 글에서는 빅데이터에 대해서 거론하지 않습니다.&lt;/li&gt;&lt;li&gt;이 글에서는 데이터 사이언스 기술에 대해서 거론하지 않습니다.&lt;/li&gt;&lt;li&gt;이 글의 작성자는 전문가가 아닙니다.&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;들어가며&lt;/h2&gt;&lt;p&gt;서비스 개발에 종사하시는 많은 부류의 개발자 분들은 대부분 &lt;a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4"&gt;데이터베이스(Database)&lt;/a&gt;라는 것을 들어보셨을 겁니다. 보통 서비스에 있는 동적 데이터와 사용자의 상태를 &lt;a href="https://ko.wikipedia.org/wiki/%EC%84%B8%EC%85%98_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)"&gt;세션(Session)&lt;/a&gt;으로 관리하되 이를 스토어(Store)로 연결하고자 데이터베이스를 서비스와 연결하여 사용하는 것이 일반적이지요.&lt;/p&gt;&lt;p&gt;여러분이 많이 들어보신 MySQL, MSSQL, Oracle, DB2, CosmosDB, PostgreSQL, MariaDB 등이 이러한 &lt;a href="https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84%ED%98%95_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4"&gt;관계형 데이터베이스(RDBMS)&lt;/a&gt;가 되겠습니다.&lt;/p&gt;&lt;figure data-orig-width="312" data-orig-height="161" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/80ecb6f46636d03a97ee45f7ff486ebd/tumblr_inline_oyfubsyS2a1td93ol_540.png" alt="image" data-orig-width="312" data-orig-height="161"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;그림 1.1 여러분이 사랑해주시는 우리의 MySQL 찡&amp;hellip;&amp;gt;&lt;/p&gt;&lt;p&gt;참고로 여기서 &lt;a href="https://ko.wikipedia.org/wiki/MySQL"&gt;MySQL&lt;/a&gt;을 “마이에스큐엘” 이라고 발음하시는 분들이 많으신데요 현업에서는 “마이시퀄&amp;quot;이라고 부르는 경우가 많습니다. &lt;a href="https://ko.wikipedia.org/wiki/PostgreSQL"&gt;PostgreSQL&lt;/a&gt; 또한 “포스트그레스큐엘”이 아닌 “포스트그레스퀄&amp;quot;이라고 부르는 경우가 많습니다.&lt;/p&gt;&lt;p&gt;보통 우리는 서비스단에 이러한 RDBMS를 연결할 때, RDBMS가 있는 부분을 지속 레이어 혹은 &lt;a href="http://wiki.c2.com/?PersistenceLayer"&gt;퍼시스턴스 레이어&lt;/a&gt;(Persistence Layer)라 부릅니다.&lt;/p&gt;&lt;figure data-orig-width="730" data-orig-height="752" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/6fb03867abd1220c1e662fd4c4c0f9e9/tumblr_inline_oyfuh7gXkZ1td93ol_540.png" alt="image" data-orig-width="730" data-orig-height="752"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;그림 1.2 서비스에서 구분되는 계층들&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;물론 서비스 단에서 DB를 사용할 때는 &lt;a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EB%AC%B4%EA%B2%B0%EC%84%B1"&gt;데이터 무결성&lt;/a&gt;(데이터과 일관적이고 정확함을 보증)해야 하고 또 만약 데이터 처리에 문제가 생겨도 이를 대처할 수 있어야합니다. (*&lt;a href="https://ko.wikipedia.org/wiki/%EC%9E%A5%EC%95%A0_%ED%97%88%EC%9A%A9_%EC%8B%9C%EC%8A%A4%ED%85%9C"&gt;폴트톨러런스&lt;/a&gt;) 위의 것들을 지원하기 위한 목적을 가진 데이터베이스를 일반적으로 우리는 &lt;a href="https://ko.wikipedia.org/wiki/%EC%98%A8%EB%9D%BC%EC%9D%B8_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98_%EC%B2%98%EB%A6%AC"&gt;OLTP (Online transaction processing)&lt;/a&gt; 라고 부릅니다.&lt;/p&gt;&lt;p&gt;위 설명이 다소 복잡할 수 있어서 아래에서는 사례를 하나 들어드려 보겠습니다. 여러분이 만약 여행사 API를 이용하여 사용자가 돈을 결제하면 여행사 등록을 하는 시스템을 만들어보겠습니다. 서비스 프로세스에서 처리할 것은 아래와 같습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;사용자가 특정 여행사에 신청을 넣고 크레딧을 사용&lt;/li&gt;&lt;li&gt;서버에서 여행사 API에 접근하여 정원 초과여부, 사용자 등록정보를 바탕으로 유효성 체크등을 거쳐 올바를 경우 다음 단계 진행&lt;/li&gt;&lt;li&gt;사용자의 크레딧 DB에 요금이 있는지 확인&lt;/li&gt;&lt;li&gt;사용자의 크레딧 DB에서 크레딧을 차감 (DB 작업)&lt;/li&gt;&lt;li&gt;여행사 API에 접근하여 예약 처리&lt;/li&gt;&lt;li&gt;예약이 성공적으로 성사 됨을 사용자에게 알림&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;위 시나리오대로 구현 하면 일반적인 경우에는 서버의 장애는 발견되지 않는다고 생각할 수 있을 텐데 여기에는 심각한 문제들이 여럿 있습니다. 아래는 여기서 발생할 수 있는 장애 시나리오를 간단하게 나열해봤습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;여행사 API에서 에러를 보내는 경우 (a. 여행사 서버 문제, b. 유효성 검증 이후 잠깐의 처리시간동안 다른 사용자가 예약을 진행한 경우 등)&lt;/li&gt;&lt;li&gt;사용자가 동시적인 예약처리로 인해 크레딧 체크 이후 크레딧이 줄었을 경우&lt;br/&gt;&lt;/li&gt;&lt;li&gt;서버의 장애로 인해 예약처리를 수행하지 못했을 경우 (서버의 재배포, 서버의 다운 등)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;세상은 항상 논리적이고 완벽하지 않기 때문에 우리는 이런 의도치 않은 사항을 예방해야 합니다. 다행스럽게도 우리에게는 &lt;a href="https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98"&gt;트랜잭션(Transaction)&lt;/a&gt;이 있기에 위의 문제를 아름답게 해결 할 수 있습니다.&lt;/p&gt;&lt;figure data-orig-width="2000" data-orig-height="1489" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/79ae2cad03ce2522308f913f570ced34/tumblr_inline_oyfv6xpsoU1td93ol_540.png" alt="image" data-orig-width="2000" data-orig-height="1489"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;그림 1.3 트랜잭션의 방식에 대한 그림&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;트랜잭션의 원리는 비교적 간단합니다.&lt;/p&gt;&lt;p&gt;트랜잭션 컨텍스트를 정의하고 (Begin transaction 혹은 &lt;a href="https://ko.wikipedia.org/wiki/SAVEPOINT"&gt;savepoint&lt;/a&gt;) 그 컨텍스트 안에 있는 처리들을 마지막에 반영(Commit)하거나 취소(Rollback) 하실 수 있습니다. Auto Commit이 설정되있지 않으면 서버에서 피치 못하게 처리 응답을 못할 경우 데드맨스위치와 유사하게 자동으로 취소(Rollback)합니다.&lt;/p&gt;&lt;p&gt;우리는 아까의 시나리오를 트랜잭션을 이용하여 아래처럼 처리 할 수 있습니다.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;사용자가 특정 여행사에 신청을 넣고 크레딧을 사용&lt;/li&gt;&lt;li&gt;서버에서 여행사 API에 접근하여 정원 초과여부, 사용자 등록정보를 바탕으로 유효성 체크등을 거쳐 올바를 경우 다음 단계 진행&lt;/li&gt;&lt;li&gt;&lt;b&gt;트랜잭션 시작&lt;/b&gt;&lt;/li&gt;&lt;li&gt;사용자의 크레딧 DB에 요금이 있는지 확인&lt;/li&gt;&lt;li&gt;사용자의 크레딧 DB에서 크레딧을 차감 (DB 작업)&lt;/li&gt;&lt;li&gt;여행사 API에 접근하여 예약 처리&lt;/li&gt;&lt;li&gt;&lt;b&gt;만약 이 과정중 어떤 에러라도 있다면 트랜잭션 취소(Rollback)&lt;/b&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;트랜잭션 종료 및 반영(Commit)&lt;/b&gt;&lt;/li&gt;&lt;li&gt;예약이 성공적으로 성사 됨을 사용자에게 알림&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;물론 위의 시나리오에서도 사용자가 동시적으로 크레딧을 결제할 경우는 막을 수 없습니다.&lt;/p&gt;&lt;p&gt;이를테면 동시간대에 2개 이상의 트랜잭션이 동시에 작동하여, 5만원의 크레딧 중 한곳은 5만원을 사용하고 또 한곳은 3만원을 사용하여 둘중 하나는 취소되어야 함에도 불구하고 두 처리 모두 조회단계에서 5만원이 조회되고 처리 단계는 그 이후 수행되기에 총 8만원이 소진되는 현상 (이때도 둘 중 어떤 트랜잭션이 먼저 실행되었냐에 따라 잔금이 2만원이 남아버리기도 하는 엄청난 사태)&lt;/p&gt;&lt;p&gt;이를 완벽하게 처리하고자 한다면 &lt;a href="http://www.dbguide.net/db.db?cmd=view&amp;amp;boardUid=148217&amp;amp;boardConfigUid=9&amp;amp;boardIdx=138&amp;amp;boardStep=1"&gt;비관적 동시성 제어 처리&lt;/a&gt;를 위해 &lt;a href="http://www.dbguide.net/db.db?cmd=view&amp;amp;boardUid=148215&amp;amp;boardConfigUid=9&amp;amp;boardIdx=138&amp;amp;boardStep=1"&gt;읽기 락&lt;/a&gt;을 걸거나 다중 체크를 통해 결제를 보장해야 합니다. 일단 이 설명은 &lt;strike&gt;모두와 나를 위해&lt;/strike&gt; 생략합니다!&lt;/p&gt;&lt;p&gt;우리는 한때 RDBMS와 트랜잭션만을 이용해서도 서비스 제공하기에는 큰 지장이 없었습니다. (&lt;strike&gt;물론 확장성과 가용성은 여기서 빼도록 합시다!&lt;/strike&gt;)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;여기까지 읽으셨다면 아래 문서도 같이 살펴보세요&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84_(%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)"&gt;관계 - 데이터베이스 (위키피디아)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://d2.naver.com/helloworld/407507"&gt;DBMS는 어떻게 트랜잭션을 관리할까? (Naver D2)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://devkingsejong.tistory.com/m/13"&gt;OLTP와 OLAP (devkingsejong&amp;rsquo;s dev life)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://www.mimul.com/pebble/default/2012/07/03/1341276539423.html"&gt;클라우드 환경에서 새로운 ACID, BASE 그리고 CAP (미물의 개발 세상)&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;h2&gt;커넥션 풀 (Connection Pool)&lt;/h2&gt;&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Connection_pool"&gt;커넥션 풀 (Connection Pool - DBCP)&lt;/a&gt; 없이는 당장에는 서비스 테스트에 큰 문제가 없겠지만 서비스를 런칭하고 유저가 다수 붙으면 차차 문제가 발생하기 시작합니다.&lt;/p&gt;&lt;p&gt;데이터베이스를 모니터링 해보면 Current 커넥션은 요동치기 시작하며 데이터베이스는 불필요한 CPU Latency를 가지게 됩니다.  여러분의 서비스는 홈페이지 처음 입장 시 DB에서 사용자 세션 정보를 가지고오고 (이를테면 메모리 스토리지에서), 추가적으로 메인 페이지의 최신뉴스를 DB에서 가져온다고 치자면 여러분은 DB에 2개의 쿼리 요청(트랜잭션)을 시도하게 됩니다.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;유저의 세션 정보 조회 쿼리&lt;/li&gt;&lt;li&gt;최신 뉴스를 가져오는 쿼리&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;보통 유저의 세션 정보를 가져오는 처리와 최신 뉴스를 가져오는 처리는 기능상으로 분리되기 때문에 서로 다른 DB 커넥션이 발생하게 되는데 이를 그림으로 표현하면 아래와 같습니다.&lt;/p&gt;&lt;figure data-orig-width="1920" data-orig-height="1080" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/49fc28eb474c4091f1ce398bf923b7cb/tumblr_inline_oyg4t0g4Wk1td93ol_540.jpg" alt="image" data-orig-width="1920" data-orig-height="1080"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;그림 2.1 유저 별 트랜잭션 별 쿼리 생성&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;문제는 각 요청 별로 DB에 커넥션을 새로 얻어와서 (그림상의 빨간부분) 쿼리를 진행하는데 커넥션을 얻어오는 과정이 오래걸리기 때문에 사용자는 그동안 대기하게 되며 또 이러한 처리는 DB 서버에 있어서도 어느정도 CPU 연산이 필요하기에 전체적으로 비효율적으로 작업이 돌아가게 됩니다.&lt;/p&gt;&lt;figure data-orig-width="1920" data-orig-height="1080" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/d2ac091c335d5986e1238eae84cfe6b8/tumblr_inline_oyg52kngpf1td93ol_540.jpg" alt="image" data-orig-width="1920" data-orig-height="1080"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;그림 2.2 커넥션 풀의 관리&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;위의 그림처럼 커넥션 풀을 이용할 경우 서버가 초기에 커넥션을 커넥션 풀에 설정된 용량 (Max connection)만큼 연결해놓고 사용자가 실제로 트랜잭션을 진행 할 때는 이렇게 미리 연결된 커넥션을 잠시 빌려 사용하고 돌려주는(Release) 하는 방식으로 돌아가기 때문에 실제로 DB에는 커넥션이 안정적으로 유지되고 또 CPU 부하가 줄어들게 됩니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;커넥션 풀에 대한 정보를 모아봤습니다!&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.holaxprogramming.com/2013/01/10/devops-how-to-manage-dbcp/"&gt;DB Connection Pool에 대한 이야기 (안녕 프로그래밍)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://d2.naver.com/helloworld/5102792"&gt;Commons DBCP 이해하기 (Naver D2)&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;확장성 그리고 고 가용성&lt;/h2&gt;&lt;p&gt;여러분이 신입에서 조금씩 걸어 올라오다 보면 서비스를 준비하는 단계에서 무결성(일관성과 정확성, 원자성 등) 다음으로 확장성과 가용성이 굉장히 중요한 요소인 것을 점차 느끼게 되는데 둘에 대한 간략한 설명은 아래와 같습니다.&lt;/p&gt;&lt;p&gt;&lt;b&gt;확장성(Scalability)&lt;/b&gt;: 사용자가 많아지고(커넥션, 트랜잭션 증가) 처리해야 할 데이터의 양이 많아 지면서(인덱스 증가,&lt;a href="http://estenpark.tistory.com/339"&gt; 카디널리티 &lt;/a&gt;증가, 스캔용량 증가) 물리적인 서버의 성능을 향상 스킬 수 있는 능력이나 방법.&lt;/p&gt;&lt;p&gt;&lt;b&gt;가용성(Availability)&lt;/b&gt;: 주어진 환경에서 어떠한 문제(서비스의 장애) 없이 유지시킬 수 있는가에 대한 정도. (i.e 가동률)&lt;/p&gt;&lt;p&gt;만약 여러분이 서비스를 잘 만들고 라이브 서비스로 오픈 했는데 하루만에 DB 서버가 뻗고 (일반적인 장애 혹은 스팩 자체의 문제) 이를 복구하는데도 수시간이 걸린다면 가용성이 심각한 문제가 있는 것이게 됩니다. 또한 서비스의 성능이 느려 이를 개선하는데에 있어 시간적 비용이나 공간적 비용(서버공간 추가, 서버 이전), 인적비용(마이그레이션 담당자 투입, DBA 투입, 서버엔지니어 투입)이 발생한다면 확장성이 낮은 것이지요.&lt;/p&gt;&lt;p&gt;DBMS 종류마다 이러한 가용성, 확장성을 SW 레벨에서 지원하기 위한 기능도 있으며 이런 차이 때문에 많은 데이터 관련 엔지니어나 종사자들이 많은 공부를 하고 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;확장성을 깊게 들여다보며&lt;/h2&gt;&lt;figure data-orig-width="1920" data-orig-height="1080" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/20d9927d2535bb590886c4648ffa0e6c/tumblr_inline_oyg3mcQFVW1td93ol_540.jpg" alt="image" data-orig-width="1920" data-orig-height="1080"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;그림 3.1 확장성에 대한 간단한 그림 (scale-out 측면)&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;아까는 확장성에 대해 간단하게만 서술 했는데 이번에는 조금 더 깊이있게 얘기해 보겠습니다. 데이터베이스 서버가 느려 이를 확장하는 경우 간단하게 두개로 나뉘게 됩니다.&lt;/p&gt;&lt;p&gt;SW 레벨에서의 확장 (논리적인 확장)&lt;/p&gt;&lt;p&gt;HW 레벨에서의 확장 (물리적인 확장)&lt;/p&gt;&lt;p&gt;당연하게도 HW쪽이 비용과 시간은 더 많이 소모되겠죠.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;SW 레벨에서의 확장을 하는 케이스 사실 확장이라 칭하기보다 최적화가 더 맞는 말일 듯 합니다. 보통 로그테이블이 많이 쌓여서 로우가 추가될 때마다 인덱싱도 느리고 또 서치를 해도 불필요하게 스캔 코스트가 많이 들기 때문에 테이블 파티셔닝을 하게 됩니다.&lt;/p&gt;&lt;p&gt;HW 레벨에서의 확장은 경우의 수가 많습니다만 크게 아래와 같이 또 한번 분류 할 수 있습니다.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;수직 확장의 측면(Scale-up)&lt;br/&gt;&lt;/li&gt;&lt;li&gt;수평 확장의 측면(Scale-out)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="1920" data-orig-height="1080" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/038d0b3b3254befebc927b9476c78dc9/tumblr_inline_oyfxo0XbDu1td93ol_540.png" alt="image" data-orig-width="1920" data-orig-height="1080"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;그림 3.2 수직확장(scale-up)과 수평확장(scale-out)에 대한 설명&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;수직 확장&lt;/b&gt;은 쉽게 얘기하여 서버 자체의 성능을 늘리거나 처리 방식을 개선하여 알고리즘을 효율적으로 돌아가게 하는 등으로 개선이 필요한 인스턴스 자체를 조정하는 것이라 보면 됩니다.&lt;/p&gt;&lt;p&gt;&lt;b&gt;수평 확장&lt;/b&gt;은 그와 다르게 서버의 수를 늘려 분산을 하거나 스캔 대상의 파일을 쪼개어 분산하거나 혹은 연산 프로세싱 만을 분산하는 등 하나의 커다란 문제를 쪼개어 해결하는 것으로 초점이 맞춰져 있습니다.&lt;/p&gt;&lt;p&gt;수직 확장의 경우에는 보통 서버의 스팩을 올리거나, 랜 공사를 해서 데이터 서버가 사용하는 랜 성능을 키운다거나 디스크를 증설하여 저장공간을 키우는 형태로 보통 서버가 정지됩니다.&lt;/p&gt;&lt;p&gt;수평 확장은 클러스터를 구성하여 서버 노드를 늘리거나, 디스크 노드를 늘리거나 마이크로 서버를 띄워 프로세싱을 맡기는 등의 처리를 통하여 성능을 늘리며 보통 이런 처리가 무정지로 이루어지거나 Write Lock만을 통하여 진행합니다.&lt;/p&gt;&lt;p&gt;확장성의 경우 이렇다 저렇다 얘기가 많지만 주관적으로 수평확장이 수직확장에 비해 안전하고 요금 측면에서 효율적이며 각종 위험에 대하여 안전합니다. (&lt;a href="https://ko.wikipedia.org/wiki/%EC%9E%A5%EC%95%A0_%EA%B7%B9%EB%B3%B5_%EA%B8%B0%EB%8A%A5"&gt;Fail-over&lt;/a&gt;, &lt;a href="https://docs.vmware.com/kr/VMware-vSphere/6.5/com.vmware.vsphere.storage.doc/GUID-DD2FFAA7-796E-414C-84CE-1FCC14474D5B.html"&gt;Multi region&lt;/a&gt;)&lt;/p&gt;&lt;p&gt;수평 확장을 통하여 데이터를 분산 할 경우 &lt;a href="http://d2.naver.com/helloworld/14822"&gt;샤딩(Sharding 혹은 Horizontal Partitioning)&lt;/a&gt;을 하게 되는데 이를 통해 데이터의 저장소를 분배하고 실제로 데이터를 수집하고 집계 할 때,  리더 역할을 하는 컴퓨터에 조회 요청을 보내고 리더 컴퓨터에서 분산된(샤딩된) 데이터를 각각의 목적 노드에서 추출하고 집계하여 반환하게 됩니다. 물론 이런 리더-컴퓨터 구성처럼 &lt;a href="https://www.service-architecture.com/articles/object-oriented-databases/middle_tier_architecture.html"&gt;미들티어(Middle-tier)&lt;/a&gt; 형태로 작동하는 것도 있지만 &lt;a href="http://hibernate.org/others/"&gt;Hibernate Shards&lt;/a&gt;와 같이 &lt;a href="https://en.wikipedia.org/wiki/Application_layer"&gt;어플리케이션 레벨&lt;/a&gt;에서 동작하는 경우도 있으며 이마저도 아닌 데이터베이스 자체에서 지원하는 케이스도 있습니다.&lt;/p&gt;&lt;figure data-orig-width="1920" data-orig-height="1080" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/a451dde7cf1f1503e1f4984fac5f6fc2/tumblr_inline_oyg3xhVdeo1td93ol_540.jpg" alt="image" data-orig-width="1920" data-orig-height="1080"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;그림 3.3 파티셔닝에 대한 간단한 설명 그림&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;가용성을 깊게 살펴보며&lt;/h2&gt;&lt;p&gt;이번에는 아까 말씀드린 가용성을 깊게 살펴봅시다.&lt;/p&gt;&lt;p&gt;가용성은 다시말해 “서버가 얼마나 안정적으로 오랫동안 운영되고 있나&amp;quot;를 알려주는 성질입니다. &lt;a href="https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%9A%B4%ED%83%80%EC%9E%84"&gt;서버가 정지되는 시간(다운타임)&lt;/a&gt;을 최소화 하는 것이 궁극적으로 고 가용성을 제공하는 방법입니다.&lt;/p&gt;&lt;p&gt;수직 확장의 경우에는 이런 처리가 다소 난해한 요소로 자리 잡고 있습니다. 서버 자체가 문제가 발생 할 때 이를 대체 해 줄 수 있는 서버가 존재하지 않으면 마땅한 방법이 없기 때문인데 이 때문에 별도의 모니터링이나 &lt;a href="https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C_%EC%84%9C%EB%B2%84"&gt;대리자(Proxy)&lt;/a&gt;를 두게 됩니다.&lt;/p&gt;&lt;p&gt;수직 확장의 경우에도 데이터 디스크와 데이터서버를 분리하고 데이터서버 앞에 로드밸런서를 붙여 &lt;a href="https://en.wikipedia.org/wiki/Health_Check"&gt;상태검사(Health Check)&lt;/a&gt;이후 문제가 발생하면 후차 데이터베이스 (Secondary or Slave or Stand by)를 활성화(Idle, Promote to master)하여 자동으로 정상화 합니다. 이렇다 하더라도 데이터센터가 지역적으로 한곳에 있다면 천재지변이 발생할 경우 서비스는 다운됩니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;후후.. 이제 조금만 더 읽으면 끝납니다! 복습 차원에서 아래 관령 링크를 살펴보세요!&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="http://www.dbguide.net/db.db?cmd=view&amp;amp;boardUid=148188&amp;amp;boardConfigUid=9&amp;amp;boardIdx=133&amp;amp;boardStep=1"&gt;분산 데이터베이스와 성능 (DBGuide)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://d2.naver.com/helloworld/14822"&gt;NHN의 안과 밖: Sharding Platform (Naver D2)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.networkworld.com/article/2232296/microsoft-subnet/dfs--not-a-distributed-database.html"&gt;DFS: Not a Distributed Database&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://d2.naver.com/helloworld/258077"&gt;어떤 분산 파일 시스템을 사용해야 하는가? (Naver D2)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://www.mysqlkorea.com/gnuboard4/bbs/board.php?bo_table=community_03&amp;amp;wr_id=1504"&gt;클러스터와 리플리케이션의 차이가 뭔가요?&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;figure data-orig-width="1920" data-orig-height="1080" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/137befb4d5967772d360a1bff9115175/tumblr_inline_oyfy4da6sB1td93ol_540.jpg" alt="image" data-orig-width="1920" data-orig-height="1080"/&gt;&lt;/figure&gt;&lt;p&gt;&amp;lt;그림 4.1 slave 관점에서의 failover 예시&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;Fail-over 전략에 대해서도 워낙 다양하기에 여기서 모든 것을 설명 드릴 수는 없고, 기회가 되면 추가 포스팅을 하고 링크를 이곳에 연결해드리겠습니다.&lt;/p&gt;&lt;p&gt;조금 특이한 fail-over 전략으로는 &lt;a href="https://namu.wiki/w/%EB%8D%B0%EB%93%9C%EB%A7%A8%20%EC%8A%A4%EC%9C%84%EC%B9%98"&gt;데드맨 스위치(Deadman switch)&lt;/a&gt;가 있습니다. 전략이라기 보다는 일반적인 fail-over가 이에 근거하여 돌아간다라고 설명드릴 수 있을 것 같은데요 DB 앞에 &lt;a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)"&gt;Load Balencer&lt;/a&gt;가 붙어 이상점을 감지하여 레플리카를 대체하건 &lt;a href="https://en.wikipedia.org/wiki/Multi-master_replication"&gt;M-M 구성&lt;/a&gt;에서 Master의 이상점을 감지하여 승격과정을 거치건 둘 이상의 노드간에 약속된 패킷과 발송 시간을 정하여 그것이 도착하지 않으면 이상으로 감지하여 데드맨 스위치가 켜지는 방식입니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;퍼포먼스&lt;/h2&gt;&lt;p&gt;서비스의 안정성이 가장 중요하지만 두번째로 중요한 것은 성능입니다. 사용자는 점점 즉각적이고 신속한 응답을 바라고 있고 우리는 더 많은 양의 정보를 바탕으로 질 높은 정보 얻어 다른 업체와 경쟁해야 합니다.&lt;/p&gt;&lt;figure data-orig-width="250" data-orig-height="250" data-tumblr-attribution="justalittletumblweed:952-RpBfjIklC34vZU535Q:Zaq0_w2MU0rcE" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/c8771963d5c44402c541fa083386e8bc/tumblr_or7f372dh01r2pp2to1_250.gif" alt="image" data-orig-width="250" data-orig-height="250"/&gt;&lt;/figure&gt;&lt;p&gt;퍼포먼스(Performance)를 향상시키는 전략도 여러가지가 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;일반적으로는 &lt;a href="https://dev.mysql.com/doc/refman/5.7/en/using-explain.html"&gt;Explain&lt;/a&gt;과 &lt;a href="http://zetawiki.com/wiki/MySQL_%EC%8A%AC%EB%A1%9C%EC%9A%B0_%EC%BF%BC%EB%A6%AC_%EB%A1%9C%EA%B7%B8_%EC%84%A4%EC%A0%95"&gt;slow query&lt;/a&gt; 로그 분석을 통해 &lt;a href="https://en.wikipedia.org/wiki/Query_plan"&gt;쿼리 플랜&lt;/a&gt;을 최적화 하는 것이 있으며 이는 많은 비용이 들지도 않습니다. 물론 이것도 방법론이 많습니다. (&lt;a href="http://greenhappy.tistory.com/entry/Mysql-Query-Optimization-using-Covering-Index-%EC%BB%A4%EB%B2%84%EB%A7%81-%EC%9D%B8%EB%8D%B1%EC%8A%A4"&gt;커버링 인덱스&lt;/a&gt;를 사용하거나 &lt;a href="http://d2.naver.com/helloworld/1155"&gt;컬럼 자체의 인덱스를 관리하는 관점&lt;/a&gt;, &lt;a href="http://use-the-index-luke.com/sql/sorting-grouping/order-by-asc-desc-nulls-last"&gt;recency score&lt;/a&gt;를 두거나 등)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;두번째는 &lt;a href="https://en.wikipedia.org/wiki/Database_tuning"&gt;튜닝(Tuning)&lt;/a&gt;이 있습니다. 너무 당연하겠지만 제일 효율적인 성능을 위해서는 서비스에 특성이 맞게 DB가 세팅되고 돌아가야 합니다. 서비스에 맞게 &lt;a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%97%94%EC%A7%84"&gt;스토리지 엔진&lt;/a&gt; 타입을 바꾸거나 인덱스를 새롭게 설정하거나 &lt;a href="https://en.wikipedia.org/wiki/B-tree"&gt;인덱스 알고리즘을&lt;/a&gt; 바꾸거나,&lt;a href="http://docs.aws.amazon.com/redshift/latest/dg/c_Compression_encodings.html"&gt; 압축 방식&lt;/a&gt;을 바꾸거나 &lt;a href="https://docs.oracle.com/database/121/TGDBA/tune_buffer_cache.htm"&gt;버퍼 캐시&lt;/a&gt;를 수정하는 등의 방법이 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;세번째는 &lt;a href="https://ko.wikipedia.org/wiki/%EB%B6%84%EC%82%B0_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4"&gt;서비스 분산 아키텍처&lt;/a&gt;를 설계하실 수도 있습니다. 여기서 부터는 비용이 눈에띄게 발생하게 됩니다. 서비스의 특성에 따라 &lt;a href="http://www.dbguide.net/db.db?cmd=view&amp;amp;boardUid=186813&amp;amp;boardConfigUid=9&amp;amp;categoryUid=216&amp;amp;boardIdx=152&amp;amp;boardStep=1"&gt;정형화된 데이터&lt;/a&gt;를 하나의 데이터소스에서 관리하고 싶다면 &lt;a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%9B%A8%EC%96%B4%ED%95%98%EC%9A%B0%EC%8A%A4"&gt;DW(Data warehouse)&lt;/a&gt;를, 비정형화 정형화 관계없이 여러 방식으로 데이터 플로우를 구축해야 한다면 &lt;a href="https://ko.wikipedia.org/wiki/%EC%95%84%ED%8C%8C%EC%B9%98_%ED%95%98%EB%91%A1"&gt;하둡 레이어&lt;/a&gt;를, 비정형화 데이터를 관계처리 없이 사용하고자 한다면 &lt;a href="https://www.mongodb.com/"&gt;MongoDB&lt;/a&gt;를, 수많은 데이터를&lt;a href="https://en.wikipedia.org/wiki/Key-value_database"&gt; K-V(Key-Value) &lt;/a&gt;형태로 확장성있게 분산기반 위에서 가져오고 싶다면 &lt;a href="http://cassandra.apache.org/"&gt;카산드라&lt;/a&gt;를 고려하실 수도 있습니다. 이러한 선택의 경우에는 각 요구사항에 여러 제품군이 있으며 각각의 대조군을 각 플랜에 맞게 테스트 하신 후 사용하시는 것을 권장합니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;네번째는 서비스에 맞게끔 추가 서비스를 붙여 데이터 처리 플로우를 개선하는 방법이 있습니다. 여기서 부터는 하나의 데이터베이스 서비스가 아닌 다양한 서비스를 연구하고 조합해야 합니다. 예를들어 성능이 피크타임에 치솟고(보통 스파이크 친다고 합니다.) 데이터 삽입이 많이 발생하지만 관계형 쿼리를 많이 사용하지 않는 서비스에서는 (채팅 서비스: 챗봇, 메시지등의 대화형 서비스)에서는 &lt;a href="https://ko.wikipedia.org/wiki/NoSQL"&gt;nosql&lt;/a&gt;이나 앞단에 &lt;a href="https://en.wikipedia.org/wiki/Message_queuing_service"&gt;queue&lt;/a&gt;를 붙인 서비스를 고려하실 수 있습니다. 읽기 빈번하고 수정이 간간히 발생한다면 &lt;a href="https://redis.io/"&gt;Redis&lt;/a&gt;나 &lt;a href="https://memcached.org/"&gt;Memcached&lt;/a&gt; 캐시 레이어를 앞단에 붙이는 구성을 고려 해 보실 수도 있습니다. 서비스 작업에 즉시성이 요구되지 않는다면 &lt;a href="https://ko.wikipedia.org/wiki/%EB%A7%B5%EB%A6%AC%EB%93%80%EC%8A%A4"&gt;MapReduce&lt;/a&gt;를 통한 &lt;a href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B4%84_%EC%B2%98%EB%A6%AC"&gt;배치 방식을&lt;/a&gt; 고려하실 수도 있습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;NoSQL, DW, RealtimeDB, Serverless QueryEngine, Graph Database?!!!!?!&lt;/h2&gt;&lt;figure data-orig-width="364" data-orig-height="338" data-tumblr-attribution="haidaspicciare:Vvry4LUoHrTPODcAw0X2rg:ZZ1zKu2Hr30w2" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/8ef0c7e5a0228e26cce0489456dffa5b/tumblr_okll4zJZMo1rfd7lko1_400.gif" alt="image" data-orig-width="364" data-orig-height="338"/&gt;&lt;/figure&gt;&lt;p&gt;* 경고&lt;/p&gt;&lt;p&gt;모든 자료가 그렇듯이 모든 데이터베이스 엔진 혹은 쿼리 엔진의 장단점을 딥 다이브하여 검증하지 못하기 때문에 이 포스트를 통해 “우리 서비스는 ~~에 맞겠다&amp;quot; 라는 평가자료로 쓰일 수 없습니다. &lt;a href="https://lazygyu.net/blog/hype_driven_development"&gt;HDD를 주의 해주세요.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;필자도 이런 부분에 전문가가 아니고 모든 레이어를 다 사용할 정도로 프로젝트의 규모가 거대하지도 않기 때문에 사실상 프로덕션에 적용해보지 않고 내리는 막연한 평가에 불가합니다.&lt;/p&gt;&lt;p&gt;&lt;b&gt;1. NoSQL (Not only SQL)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;전통적인 RDBMS 서비스를 이용하면서 생긴 불편사항들 (복잡한 관계 구조로 인해 생긴 제약들 - 분산, 열 용량 제약, 테이블 용량제약, 확장제약, 스키마로 인한 데이터 형식제약 등)을 벗어나고자 관계에 얼메여 있지 않은, 그리고 SQL외에 다른 표현식을 지원하는 새로운 데이터베이스가 나오게 되었는데 이를 NoSQL (Not only SQL)이라 부릅니다.&lt;/p&gt;&lt;p&gt;NoSQL 데이터베이스는 여러 종류가 있는데 일반적으로 RDBMS 처럼 기본 구조는 같은데 세부적으로 각각의 기능이 차이가 나는 것이 아니라 정말 핵심 기술부터 그 기능이 다른 종류들이 많습니다.&lt;/p&gt;&lt;p&gt;일반적으로 알려진 데이터베이스로는 &lt;a href="https://www.mongodb.com/"&gt;MongoDB&lt;/a&gt;, &lt;a href="http://cassandra.apache.org/"&gt;Cassandra&lt;/a&gt;, &lt;a href="https://hbase.apache.org/"&gt;HBase&lt;/a&gt;, &lt;a href="https://redis.io/"&gt;Redis&lt;/a&gt; 등이 있으며 클라우드 환경에서는 AWS DynamoDB, Google Cloud BigTable 등이 있고 IBM도 &lt;a href="https://www-01.ibm.com/software/kr/data/db2/linux-unix-windows/nosql-support.html"&gt;DB2에서 NoSQL을 부분적으로 지원&lt;/a&gt;한다고 하는데 제가 사용안해봐서 잘 모르겠습니다.&lt;/p&gt;&lt;p&gt;NoSQL은 &lt;a href="https://ko.wikipedia.org/wiki/ACID"&gt;ACID&lt;/a&gt;를 지원하기 어렵습니다. 따라서 이를 완전히 지원해야하는 서비스에 적용하기 어렵습니다. &lt;a href="https://en.wikipedia.org/wiki/CAP_theorem"&gt;CAP&lt;/a&gt; 이론으로 볼 때 보통 확정성(Scalability)을 위해 일관성(Consistency)을 보장하지 않습니다.&lt;/p&gt;&lt;p&gt;요새의 NoSQL에서는 &lt;a href="http://graphql.org/learn/"&gt;GraphQL&lt;/a&gt; 지원을 하나 둘 하기 시작하여 이를 사용하기를 고려하는 업체에서는 테스트를 진행해보는 것이 좋을 것 같습니다.&lt;/p&gt;&lt;p&gt;각각의 NoSQL별 차이점이 존재하는데 간략히 작성하면 아래와 같습니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href="https://www.mongodb.com/"&gt;MongoDB&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;라이센스&lt;/b&gt;: &lt;a href="http://www.gnu.org/licenses/agpl-3.0.html"&gt;GNU AGPL v3.0 (Free, and Commercial)&lt;/a&gt;, Open source&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;업체&lt;/b&gt;: &lt;a href="https://www.mongodb.com/"&gt;MongoDB Inc&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;리플리케이션:&lt;/b&gt; 지원 (M-S)&lt;/li&gt;&lt;li&gt;&lt;b&gt;샤딩:&lt;/b&gt; 지원 (해시기반)&lt;/li&gt;&lt;li&gt;&lt;b&gt;주관적 내용&lt;/b&gt;: 몽고 디비는 AGPL 라이센스를 가지고 있는데 (물론 커머셜 라이센스도 있습니다.) &lt;b&gt;AGPL 라이센스는 상업적으로 사용이 가능하지만.. 모든 소스코드를 공개해야 하는 의무&lt;/b&gt;가 있습니다. (GPL의 경우 서버 통신을 하는 경우 회피 할 수 있는데, AGPL은 얄짤없이 공개해야 합니다.) 이는 사업에 있어 많이 고민해야 할 항목입니다. 그 밖에 기술적으로는 몽고 디비 파일이 깨지는 이슈라던가 복잡한 조인 구현 코드가 거의 살인급 코드라 그런 부분만 감당이 가능하면 사용하는 데 큰 지장은 없다고 봅니다. (겁나 겁주고 사용해도 좋다로 끝내는 훈훈함)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;&lt;a href="http://cassandra.apache.org/"&gt;Cassandra&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;라이센스&lt;/b&gt;: &lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache License 2.0&lt;/a&gt; (Free), Open source&lt;/li&gt;&lt;li&gt;&lt;b&gt;업체&lt;/b&gt;: &lt;a href="https://www.apache.org/"&gt;Apache Software Foundation&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;리플리케이션&lt;/b&gt;: 지원 (replication_factor)&lt;/li&gt;&lt;li&gt;&lt;b&gt;샤딩&lt;/b&gt;: 지원 (해시기반)&lt;/li&gt;&lt;li&gt;&lt;b&gt;주관적 내용&lt;/b&gt;: 카산드라는 분산을 지정하는 옵션이 비교적 간단하고 이를 설정해 놓기만 해도 고가용성 분산 서비스로 동작되어 상당히 편리하긴 하지만 트랜잭션도 미지원, Secondary Index는 Range쿼리를 미지원 추가 Index 미지원 등등의 Trade Off 해야할 사항이 있으니 도입 시 충분히 검토해야 합니다.&lt;br/&gt;&lt;br/&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;&lt;a href="https://hbase.apache.org/"&gt;HBase&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;라이센스:&lt;/b&gt; &lt;a href="https://www.apache.org/licenses/LICENSE-2.0"&gt;Apache License 2.0&lt;/a&gt; (Free), Open source&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;업체:&lt;/b&gt; &lt;a href="https://www.apache.org/"&gt;Apache Software Foundation&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;리플리케이션:&lt;/b&gt; 지원&lt;/li&gt;&lt;li&gt;&lt;b&gt;샤딩:&lt;/b&gt; 지원&lt;/li&gt;&lt;li&gt;&lt;b&gt;주관적 내용:&lt;/b&gt; 하둡 스택을 사용하는 업체라면 안쓸 이유가 더 없을 정도로 워낙 범용적으로 사용 되는 엔진입니다. HBase를 사용하는 이유야 뭐 &lt;a href="https://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-hdfs/HdfsUserGuide.html#Overview"&gt;하둡 분산파일시스템(HDFS)&lt;/a&gt; 위에 존재하는 거대한 데이터에서 빠르게 원하는 데이터를 뽑아낼 때 이기 때문에 특징이 뚜렷하다고 볼 수 있습니다. 당연하겠지만 HBase를 사용하기 위해서는 기본적인 하둡스택의 이해는 필요하기 때문에 진입장벽은 상대적으로 높습니다. 신기한 것은 HBase에서는 TTL을 지원하기 때문에 데이터의 만료시간을 관리할 수 있습니다. 마지막으로 HBase는 secondary index를 지원하지 않습니다. 따라서 일반적으로 RDBMS에서 사용하는 복잡한 관계 쿼리를 구현하실 수 없습니다.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;&lt;a href="https://redis.io/"&gt;Redis&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;라이센스:&lt;/b&gt; &lt;a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause"&gt;BSD 3-Clause&lt;/a&gt; (Free and Commercial), Open source&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;업체:&lt;/b&gt; Salvatore Sanfilippo&lt;/li&gt;&lt;li&gt;&lt;b&gt;리플리케이션:&lt;/b&gt; 지원 (M-S)&lt;/li&gt;&lt;li&gt;&lt;b&gt;샤딩:&lt;/b&gt; 미지원 (어플리케이션 레벨에서 Hash를 통해 지원해야 함)&lt;/li&gt;&lt;li&gt;&lt;b&gt;주관적 내용: &lt;/b&gt;Redis는 &lt;a href="https://ko.wikipedia.org/wiki/%EC%9D%B8%EB%A9%94%EB%AA%A8%EB%A6%AC_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4"&gt;인메모리 캐시 DB&lt;/a&gt;이기 때문에 역할군이 뚜렷합니다. 우선 안타까운 점은 &lt;a href="https://redis.io/topics/faq#redis-is-single-threaded-how-can-i-exploit-multiple-cpu--cores"&gt;Redis는 싱글 쓰레드 기반&lt;/a&gt;으로 설계되어 있습니다. 따라서 Redis 명령 중 일부는 블러킹을 걸도록 동작하기 때문에 프로덕션 레벨에서 운영할 때 치명적일 수 있습니다. &lt;a href="https://redis.io/topics/cluster-tutorial"&gt;Redis도 클러스터&lt;/a&gt;를 통한 분산과 &lt;a href="https://redis.io/topics/sentinel"&gt;센티넬&lt;/a&gt;을 통한 Fail-over를 제공하고 있으며 &lt;a href="https://redis.io/topics/data-types"&gt;K-V, Hash, List, Set 등의 자료구조를 가지고 있습니다.&lt;/a&gt; &lt;a href="https://redis.io/topics/persistence#rdb-advantages"&gt;RDB&lt;/a&gt;랑 &lt;a href="https://redis.io/topics/persistence#aof-advantages"&gt;AOF&lt;/a&gt;라는 연동 방식을 가지고 있는데 둘 모두 많은 수의 데이터를 관리하고 있다면 레디스 재시작에 많은 시간이 소요 될 수 있습니다. (저장의 경우 &lt;a href="https://en.wikipedia.org/wiki/Child_process"&gt;childProcess&lt;/a&gt;를 &lt;a href="https://en.wikipedia.org/wiki/Fork_(system_call)"&gt;fork&lt;/a&gt;하여 진행합니다. // AOF는 rewrite의 경우에만 이렇게 동작합니다.) 같은 캐시 DB 레벨에 있는 Memcached랑 비교해보면 대부분의 응답속도와 성능의 경우 크게 차이는 없습니다. Redis는 replication에 에러에 대해서 처리 에러를 핸들링 할 수 있으며 동시에 여러 리플리케이션 구현이 가능합니다. 또한 아까 말씀드렸듯 Redis는 Memcached와 비교하였을 때 많은 데이터 타입을 제공하고 있는 장점을 가지고 있습니다. 다만 Flush 호출시 Memcached 동작방식과 전혀 다르기 때문에 &lt;a href="http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/"&gt;블럭킹&lt;/a&gt;이 걸려 때문에 많은 양의 데이터를 Flush 할 경우 서비스 자체 동작에 문제가 발생할 수 있습니다. 그 밖에도 Redis는 Memcached에 비해 기존 저장된 데이터 유지를 위한 기능이 많습니다.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;&lt;a href="https://memcached.org/"&gt;Memcached&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;라이센스:&lt;/b&gt; &lt;a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause"&gt;BSD 3-Clause&lt;/a&gt; (Free), Open source&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;업체:&lt;/b&gt; Danga_Interactive&lt;/li&gt;&lt;li&gt;&lt;b&gt;리플리케이션: &lt;/b&gt;지원 (repcached)&lt;/li&gt;&lt;li&gt;&lt;b&gt;샤딩:&lt;/b&gt; 미지원 (어플리케이션 레벨에서 Hash를 통해 지원해야 함)&lt;/li&gt;&lt;li&gt;&lt;b&gt;주관적 내용:&lt;/b&gt; Memcached는 Redis와 마찬가지로 인메모리 캐시 DB 영역에서 존재하고 있습니다. Redis와는 다르게 메모리 본연의 목적에 맞는 간단한 K-V 형태입니다. Redis와 비교 할 경우 크게&lt;a href="https://github.com/memcached/memcached/wiki/Commands#flush_all"&gt; Flush all&lt;/a&gt;의 동작방식이 다르며 Memcached에서 훨씬 빠르게 동작합니다. (Memcached에서는 실제로 데이터 Flush를 일으키지 않고 timestamp를 기록하고 있다가 나중에 GET 되었을 때 이를 비교하여 삭제합니다.) 따라서 이러한 차이점이 오히려 동작처리에 있어 의도치 않을 실행을 하는 경우도 있습니다. Memcached에서는 flush all에 expired time을 옵션으로 줄 수 있는데 사전에 flush all로 삭제했다 하더라도 이후 flush all [exptime] 옵션을 통해 아직까지 &lt;a href="https://charsyam.wordpress.com/2012/05/19/%EB%B6%84%EC%82%B0-%EC%BA%90%EC%8B%9Cmemcached-%EC%9D%98-flush_all%EC%9D%98-%EC%A3%BC%EC%9D%98-%EC%82%AC%ED%95%AD%EC%9D%84-%EC%9D%BD%EA%B3%A0/"&gt;삭제되지 않은 데이터를 재생 시킬 수 있습니다.&lt;/a&gt; (물론 exptime에 의해 언젠가는 삭제됩니다.)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;&lt;a href="http://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/Introduction.html"&gt;DynamoDB&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;라이센스: &lt;/b&gt;유료 라이센스 (&lt;a href="https://aws.amazon.com/ko/dynamodb/pricing/"&gt;요금보기&lt;/a&gt;)&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;업체: &lt;/b&gt;&lt;a href="https://aws.amazon.com"&gt;Amazon Web Service (AWS)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;리플리케이션:&lt;/b&gt; 지원 (Server-less 구성, 자체 내결함성 지원)&lt;/li&gt;&lt;li&gt;&lt;b&gt;샤딩:&lt;/b&gt; 지원 (Server-less 구성, 자체 분산)&lt;/li&gt;&lt;li&gt;&lt;b&gt;주관적 내용: &lt;/b&gt;DynamoDB는 AWS에서 제공하는 클라우드 환경 베이스의 NoSQL DB 입니다. 여기서 큰 특징은 DynamoDB는 &lt;a href="https://en.wikipedia.org/wiki/Serverless_computing"&gt;Server-less&lt;/a&gt; 환경이기 때문에 용량, 물리적 스팩 제한이 없으며 용량 크기, 사용자가 지정한 &lt;a href="http://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/HowItWorks.ProvisionedThroughput.html"&gt;처리량(Through-put)&lt;/a&gt;에 맞게 알아서 확장되고 클러스터로 관리됩니다. 따라서 가용성, 확장성에 있어서 사용자로 하여금 귀찮은 작업이 많이 생략되며 Server-less이기 때문에 초기에 많은 비용이 나갈 우려가 사라집니다. 또한 &lt;a href="http://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/GSI.html"&gt;Secondary index 지원을 Global, Local로 각각 지원하고 있습니다.&lt;/a&gt; 다만&lt;a href="https://en.wikipedia.org/wiki/Managed_services"&gt; 관리형 서비스&lt;/a&gt;라 그런지 갑자기 많은 처리량이 발생할 때 &lt;a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html#default-limits-capacity-units-provisioned-throughput"&gt;DynamoDB에서 즉시 처리량을 늘릴 수 없는 문제, 그리고 이렇게 높아진 처리량을 다시 낮추는 경우에도 마찬가지로 제약이 있습니다.&lt;/a&gt; 따라서 이런 문제를 해결할려면 Warming up 작업을 해야하고 이로 인해 불필요한 비용이 발생할 수 있습니다. 마지막으로 놀라운 점이 하나 있는데 DynamoDB에서는 &lt;a href="https://github.com/awslabs/dynamodb-transactions"&gt;트랜잭션을 지원하기 위한 Java 코드가 올라와 있습니다.&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;&lt;a href="https://cloud.google.com/datastore/docs/concepts/overview"&gt;Cloud Datastore&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;라이센스:&lt;/b&gt; 유료 라이센스 (&lt;a href="https://cloud.google.com/datastore/pricing"&gt;요금보기&lt;/a&gt;)&lt;/li&gt;&lt;li&gt;&lt;b&gt;업체:&lt;/b&gt; &lt;a href="https://cloud.google.com/"&gt;Google Cloud Platform (GCP)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;리플리케이션:&lt;/b&gt; 지원 (Server-less 구성, 자체 내결함성 지원)&lt;/li&gt;&lt;li&gt;&lt;b&gt;샤딩:&lt;/b&gt; 지원 (Server-less 구성, 자체 분산)&lt;/li&gt;&lt;li&gt;&lt;b&gt;주관적 내용:&lt;/b&gt; Google Cloud Datastore는 AWS DynamoDB보다 약 4년정도 일찍 나온 서비스입니다. 가장 큰 차이로는 당연하게도 요금청구 방식이 다릅니다. (AWS DynamoDB는 Throughput 단위 청구, Google Cloud Datastore는 요청당 과금) 완전 정량적 과금이라 초기 비용이 적게 드는 합리적인 구성이지만 DynamoDB와 비교 할 때 요청이 많아질 수록 Google Cloud Datastore 요금이 더 비쌉니다.&lt;strike&gt; (읍읍 당신 누구야!?)&lt;/strike&gt; 다만 secondary index라던지 &lt;a href="https://cloud.google.com/datastore/docs/reference/gql_reference"&gt;Query 지원(GQL)&lt;/a&gt;이라던지 &lt;a href="https://cloud.google.com/datastore/docs/tools/indexconfig"&gt;탈 NoSQL 요소들이&lt;/a&gt; &lt;a href="https://cloud.google.com/datastore/docs/concepts/transactions"&gt;다분해서&lt;/a&gt;  이를 알고 사용하면 정말 유용하지만 신은 완벽을 내리지 않았다는 말이 증명되듯 이런 좋은 기능들에 대한 자료가 한없이 부족한 상태입니다.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;&lt;a href="https://firebase.google.com/docs/firestore/"&gt;Cloud Firestore&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;라이센스:&lt;/b&gt; 유료 라이센스 (&lt;a href="https://firebase.google.com/pricing/"&gt;요금보기&lt;/a&gt;)&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;업체:&lt;/b&gt; &lt;a href="https://firebase.google.com/"&gt;Google Cloud Platform (GCP) Firebase&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;b&gt;리플리케이션:&lt;/b&gt; 지원 (Server-less 구성, 자체 내결함성 지원)&lt;/li&gt;&lt;li&gt;&lt;b&gt;샤딩:&lt;/b&gt; 지원 (Server-less 구성, 자체 분산)&lt;/li&gt;&lt;li&gt;&lt;b&gt;주관적 내용:&lt;/b&gt; 최근에 새롭게 출시된 (베타로) 데이터베이스로 필자는 Google Cloud Datastore와 대체 어떤 차이가 있는지 많이 혼동 되었습니다. 엄밀하게 Google Cloud Firestore의 경우에는 Firebase의 불편함 점 (Query의 불편함, 데이터 계층적 문제 등)을 보완하기 위한 부분이 있으며 Firebase의 목적 (Web, App의 지원)을 상속받기 때문에 Google Cloud Datastore 차이가 있습니다. (더군다나 Cloud Firestore는 Realtime을 지원합니다!) 따라서 &lt;a href="https://firebase.google.com/docs/firestore/rtdb-vs-firestore?hl=ko"&gt;Firebase Realtime Database와 비교하는 것이 더 바람직합니다. &lt;/a&gt;Cloud Firestore는 Firebase 및 Cloud Function 과 같은 GCP 제품을 호환할 수 있게 만들어 졌습니다.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;2. DW (Data Warehouse)&lt;/b&gt;&lt;/p&gt;&lt;p&gt;예전에는 컴퓨터 하드웨어의 컴퓨팅 파워도 약했고 그렇기 때문에 수많은 데이터를 빠르게 분석 할 수 있는 환경도 여건도 없었습니다. 오늘 날에서는 컴퓨팅 파워도 높아졌고 또한 컴퓨팅 유닛도 굉장히 저렴해졌으며 가상화 기술과 분산 기술도 나날히 높아졌기 때문에 분산 환경에서 데이터를 실시간 분석하는 것이 가능해졌습니다. DW는 보통 &lt;a href="https://ko.wikipedia.org/wiki/%EC%98%A8%EB%9D%BC%EC%9D%B8_%EB%B6%84%EC%84%9D_%EC%B2%98%EB%A6%AC"&gt;OLAP&lt;/a&gt;을 위해 사용됩니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;3. Realtime DB&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Realtime DB는 실시간성 특징을 데이터베이스에 녹여 얻어낸 결과물이라 볼 수 있습니다. 일반적인 특징으로는 데이터베이스에서 수정이 발생하면 이를 클라이언트에 푸시하여 동기화 하는 기능이 들어가 있습니다. 대게의 Realtime DB는 NoSQL 기반이기 때문에 ACID를 요구하는 서비스에서 적용하기는 어렵습니다. 보통 실시간성이 요구되는 게임(진짜로 정말로 실시간 DB로 게임을 만드는 사례들이 있습니다.), 메시지 플랫폼(채팅, 챗봇, CS 등)에서 사용됩니다.&lt;/p&gt;&lt;p&gt;대표적인 Realtime DB 종류&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://firebase.google.com/docs/database/?hl=ko"&gt;Firebase Realtime DB&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://firebase.google.com/docs/firestore/"&gt;Cloud Firestore&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.rethinkdb.com/"&gt;RethinkDB&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;strike&gt;&lt;a href="http://druid.io/"&gt;Druid (검토가 필요함)&lt;/a&gt;&lt;/strike&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;4. Serverless query engine&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Serverless라는 얘기는 서버가 진짜로 없는게 아니라 사용자 (엔지니어)에 있어서 서버가 가려져 있고 또 그것을 알 필요가 없도록 관리되고 있는 완전 관리형 서비스 입니다. 보통 이런 Serverless DB는 Cloud 환경에서 제공되고 있으며 해당 환경에 파일시스템(FS)에 쿼리를 요청하면 거기에 최적화된 코어 유닛의 서버를 런치하여 연산을 분산하기 때문에 상당히 빠른 쿼리 조회 시간을 제공합니다. 다만 코어 유닛의 조작이 불가능 하기 때문에 Scale 조정을 통해 성능을 개선 할 수 없습니다. &lt;/p&gt;&lt;p&gt;대표적인 Serverless query engine의 종류&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://aws.amazon.com/ko/athena/"&gt;AWS Athena&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://aws.amazon.com/ko/redshift/spectrum/"&gt;AWS Spectrum (*반 Serverless라고 해야 할듯 합니다.)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://aws.amazon.com/ko/dynamodb/"&gt;AWS DynamoDB&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://developers.google.com/bigquery/?hl=ko"&gt;Google BigQuery&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://cloud.google.com/datastore/docs/concepts/overview"&gt;Google Cloud Datastore&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://firebase.google.com/docs/database/?hl=ko"&gt;Firebase Realtime Database&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;5. Query engine&lt;/b&gt;&lt;/p&gt;&lt;p&gt;데이터베이스라고 불리우긴 어려우나 분명 쿼리를 통해 집계, 조건 등을 이용하여 결과 데이터를 산출하는 엔진을 칭합니다. 보통 따라붙는 수식어가 “Interactive Query”이며 공용 분산 파일시스템에서 &lt;a href="https://en.wikipedia.org/wiki/Data_lake"&gt;데이터 레이크(Data lake)&lt;/a&gt; 역할을 하고 그를 조회하여 결과데이터를 뽑는 엔진을 Query engine이라 부릅니다.&lt;/p&gt;&lt;p&gt;대표적인 Query engine 종류&lt;/p&gt;&lt;ul&gt;&lt;li&gt;앞서 거론한 모든 Serverless query engine&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://impala.apache.org/"&gt;Apache Impala&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://hive.apache.org/"&gt;Apache Hive&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://pig.apache.org/"&gt;Apache Pig&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://drill.apache.org/"&gt;Apache Drill&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.ibm.com/us-en/marketplace/big-sql"&gt;IBM BigSQL&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://tajo.apache.org/"&gt;Apache Tajo&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://prestodb.io/"&gt;Facebook Presto&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;6.Graph Database&lt;/b&gt;&lt;/p&gt;&lt;p&gt;최근에 자주보이는 데이터베이스입니다. 필자는 새롭게 나오는 논문을 살펴보는 스타일은 아닌지라 이것이 어디에서 따와서 점차 출시되고 있는지 잘 모르겠습니다. &lt;a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph"&gt;DAG(Directed Acyclic Graph)&lt;/a&gt; 기반의 그래프 데이터베이스 형태로 출시되고 있습니다.&lt;/p&gt;&lt;p&gt;대표적인 Graph Database의 종류&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://docs.microsoft.com/ko-kr/sql/relational-databases/graphs/sql-graph-overview"&gt;SQL Server 2017&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://kr.teradata.com/products-and-services/teradata-analytics-platform"&gt;Teradata Aster&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.sap.com/products/hana.html"&gt;SAP HANA&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://neo4j.com/"&gt;Neo4j&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://aws.amazon.com/ko/about-aws/whats-new/2015/08/amazon-dynamodb-titan-graph-database-integration/"&gt;&lt;strike&gt;DynamoDB Titan (검증 후 재 업데이트 예정)&lt;/strike&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://s2graph.apache.org/"&gt;Apache S2Graph&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;참고하거나 연관 된 포스팅 목록&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.slideshare.net/AmazonWebServices/amazon-redshift-performance-tuning-and-optimization"&gt;Amazon Redshift: Performance Tuning and Optimization (Slideshare)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.slideshare.net/deview/135-80845610"&gt;오픈소스 데이터베이스, 은행 서비스에 첫발을 내밀다. (Slideshare)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.slideshare.net/sublee/spof-mmorpg"&gt;[야생의 땅: 듀랑고] 서버 아키텍처 - SPOF 없는 분산 MMORPG 서버 (Slideshare)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://meetup.toast.com/posts/58"&gt;Apache Cassandra 톺아보기 - 1편 (NHN-Enter Toast)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://meetup.toast.com/posts/60"&gt;Apache Cassandra 톺아보기 - 2편 (NHN-Enter Toast)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://meetup.toast.com/posts/65"&gt;Apache Cassandra 톺아보기 - 3편 (NHN-Enter Toast)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://research.google.com/pubs/pub36632.html"&gt;Dremel: Interactive Analysis of Web-Scale Datasets (Research at Google)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://readme.skplanet.com/?p=13042"&gt;Kafka New Producer API를 활용한 유실 없는 비동기 데이터 전송 (SK플래닛 기술 블로그)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://www.nurinamu.com/trans/2016/04/03/balancing-strong-and-eventual-consistency-with-google-cloud-datastore/"&gt;구글 클라우드 데이터스토어에서 스트롱 컨시스턴시와 이벤츄얼 컨시스턴시의 균형잡기 (nurinamu‘s the BLACK BOOK)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://charsyam.wordpress.com/2012/05/17/%EB%B6%84%EC%82%B0%EC%BA%90%EC%8B%9C-redis-%EC%99%80-memcache%EC%9D%98-flush%EB%8A%94-%EC%99%9C-%EB%8B%A4%EB%A5%BC%EA%B9%8C/"&gt;[분산캐시] Redis 와 memcache의 flush는 왜 다를까? (Charsyam&amp;rsquo;s Blog)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://d2.naver.com/helloworld/294797"&gt;ZooKeeper를 활용한 Redis Cluster 관리 (Naver D2)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://d2.naver.com/helloworld/151047"&gt;Memcached의 확장성 개선 (Naver D2)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://d2.naver.com/helloworld/216593"&gt;글로벌 분산 데이터베이스 Spanner (Naver D2)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.slideshare.net/curioe_/lezhincomics-google-appengine-30453946"&gt;왜 레진코믹스는 구글앱엔진을 선택했나 (Slideshare)&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="http://www.zdnet.co.kr/news/news_view.asp?artice_id=20131119174125"&gt;카카오 “레디스, 잘못쓰면 망한다&amp;quot; (ZDNet Korea)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://www.slideshare.net/KangDognhyun/apache-spark-70360736"&gt;Apache spark 소개 및 실습&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;&lt;/ul&gt;</description><link>https://blog.pigno.se/post/166818737958</link><guid>https://blog.pigno.se/post/166818737958</guid><pubDate>Fri, 27 Oct 2017 02:01:15 +0900</pubDate><category>데이터베이스</category><category>분석아키텍처</category><category>개발</category><category>서버</category><category>백엔드</category><category>engineering</category></item><item><title>자바스크립트 부분 탄성충돌 구현하기</title><description>&lt;p&gt;오늘은 조금 별난 주제에 대해서 얘기해볼까 한다.&lt;/p&gt;&lt;p&gt;필자는 전에 자바스크립트로 여러가지 물체가 서로 충돌하고 중력이 적용되는 아주 간단한 로직을 작성한적이 있는데 아래에서 볼 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;iframe height="480" scrolling="no" title="Physics - Inelastic Collision And COR (Circle Animation)." src="//codepen.io/PIGNOSE/embed/ENMqLK/?height=480&amp;amp;theme-id=0&amp;amp;default-tab=result&amp;amp;embed-version=2" frameborder="no" allowfullscreen="allowfullscreen" style="width: 100%;"&gt;See the Pen &lt;a href="http://codepen.io/PIGNOSE/pen/ENMqLK/"&gt;Physics - Inelastic Collision And COR (Circle Animation).&lt;/a&gt; by Kenneth Ceyer (&lt;a href="http://codepen.io/PIGNOSE"&gt;@PIGNOSE&lt;/a&gt;) on &lt;a href="http://codepen.io"&gt;CodePen&lt;/a&gt;.
&lt;/iframe&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;이 프로젝트는&lt;strike&gt; 정말 아무 의미없이&lt;/strike&gt; 계속적으로 새로운 원형 물체가 생성되고 그것이 중력에 의해 떨어지면서 튕겨지며, 이 원형 물체는 같은 원형 물체에 의해서 혹은 벽면(아래, 좌우)에 의해서 충돌 처리가 발생한다. 충돌 처리가 발생 될때는 원형은 순간적으로 붉게 바뀌고 충돌 이후에는 물체는 반대편으로 튕겨나가게 된다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;필자는 과거에 만든 이 코드를 지금은 왜 만들었는지 전혀 기억을 못하고 있지만 최근에서 이 코드를 사용 할 날이 왔었다.&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;배경&lt;/h2&gt;&lt;p&gt;필자는 여러가지 자바스크립트 오픈소스 기여를 하고있다. &lt;a href="https://github.com/KennethanCeyer/PIGNOSE-Calendar/issues/27"&gt;이 이슈를 보시면 아시겠지만&lt;/a&gt;, 가끔 열정 가득한 컨트리뷰터는 오픈소스 기여를 통해 더 좋은 소스코드를 만들 수 있는 기회를 제공하고. 필자는 그것이 너무나 고마워서 최대한 컨트리뷰터가 원하는 그림을 만들어주고는 한다.&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;컨트리뷰터에게 어떻게든 보상을 해주고 싶었기에 README.MD에 컨트리뷰터 목록을 추가하였지만 가끔 많은 것을 기여해주는 컨트리뷰터들도 존재했기 때문에 그런 컨트리뷰터들에게 어떤 방법이든 나의 고마움을 표현하고 싶었다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;이상한 발상&lt;/h2&gt;&lt;p&gt;이것이 사건의 발단이었던 것 같다. 필자는 컨트리뷰터들을 위해 인터렉티브하고 재미있는 요소를 통해 컨트리뷰터들의 프로필 이미지(아바타)를 라이브러리의 공식 페이지에 넣어주고 싶었고 그것을 위해서 아래와 같은 코드를 짜게 되었다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;iframe height="480" scrolling="no" title="bqEyjR" src="//codepen.io/PIGNOSE/embed/bqEyjR/?height=480&amp;amp;theme-id=0&amp;amp;default-tab=result&amp;amp;embed-version=2" frameborder="no" allowfullscreen="allowfullscreen" style="width: 100%;"&gt;See the Pen &lt;a href="http://codepen.io/PIGNOSE/pen/bqEyjR/"&gt;bqEyjR&lt;/a&gt; by Kenneth Ceyer (&lt;a href="http://codepen.io/PIGNOSE"&gt;@PIGNOSE&lt;/a&gt;) on &lt;a href="http://codepen.io"&gt;CodePen&lt;/a&gt;.
&lt;/iframe&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;눈치가 빠른 분들은 이미 감지하셨겠지만 위에 게시한 코드와 방금전 게시한 코드 두개는 버그가 존재한다. (사실 버그는 한두개가 아니다.) 이 버그들은 &lt;a href="http://krdic.naver.com/detail.nhn?docid=676901"&gt;간헐적&lt;/a&gt;으로 발생하는 버그들로 아래의 케이스에 버그들이 발생하게 된다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;원형 물체가 생성될 때 동시에 같은 위치에 두개 이상의 물체가 생성되는 경우.&lt;br/&gt;&lt;/li&gt;&lt;li&gt;원형 물체가 충돌될 때 3개 이상이 동시에 충돌되는 경우.&lt;br/&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;위 두개의 케이스에서 해당 코드는 정말 물리적으로는 말도안되는 모습을 보이게된다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="801" data-orig-height="438" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/68f4b54e936a05266c13223f1fe5ff22/tumblr_inline_ome9axazqE1td93ol_540.gif" alt="image" data-orig-width="801" data-orig-height="438"/&gt;&lt;/figure&gt;&lt;p&gt;두개의 원형 물체가 겹칠 수 밖에 없도록 생성되었을 경우 두개가 완전히 겹쳐서 같이 내려가게 된다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;문제&lt;/h2&gt;&lt;p&gt;이런 현상이 발생하는 원인을 분석할려면 이 코드가 지금 어떤 방식으로 작성되고 있는지 알아야한다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="380" data-orig-height="300" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/1ef486d9d5621d9a0634f6d18cdebfc0/tumblr_inline_omebpwO7P91td93ol_540.jpg" alt="image" data-orig-width="380" data-orig-height="300"/&gt;&lt;/figure&gt;&lt;p&gt;여러분의 이해를 돕기 위해 아주 쉬운 이미지로 만들어보았다. 먼저 g1이라고 불리는 도형 하나가 있다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="600" data-orig-height="480" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/19252c8de7a2db82fb447a45921378f0/tumblr_inline_omebqrIzX01td93ol_540.jpg" alt="image" data-orig-width="600" data-orig-height="480"/&gt;&lt;/figure&gt;&lt;p&gt;프로그래밍으로 가상의 중력을 구현했기 때문에 지정한 중력 상수에 의해 y축 가속도는 영향을 받는다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="776" data-orig-height="465" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/974f713300020154c7a0d7429d1ff0b5/tumblr_inline_omebu2NmtH1td93ol_540.jpg" alt="image" data-orig-width="776" data-orig-height="465"/&gt;&lt;/figure&gt;&lt;p&gt;충돌이 발생 했을 때 &lt;a href="https://ko.wikipedia.org/wiki/%EB%B0%98%EB%B0%9C_%EA%B3%84%EC%88%98"&gt;반발계수&lt;/a&gt;를 기준하여 연산하여 반사각을 처리하게 된다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="421" data-orig-height="358" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/25c116f58661096e2f2d36e2e207fa80/tumblr_inline_omebv07UDH1td93ol_540.jpg" alt="image" data-orig-width="421" data-orig-height="358"/&gt;&lt;/figure&gt;&lt;p&gt;하나의 물체는 다른 물체랑 충돌 할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="649" data-orig-height="436" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/1af37504546940477fffa9327081a432/tumblr_inline_omebvjk1Hs1td93ol_540.jpg" alt="image" data-orig-width="649" data-orig-height="436"/&gt;&lt;/figure&gt;&lt;p&gt;만약 두개의 물체가 충돌이 발생하게 된다면 위와 같은 시나리오 처럼 두개의 물체는 특정 시간이 지나 만나게되는 지점까지 운동을 하게 된다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="500" data-orig-height="380" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/21fd80c20ccc56d919e2272b83063829/tumblr_inline_omebwrotKb1td93ol_540.jpg" alt="image" data-orig-width="500" data-orig-height="380"/&gt;&lt;/figure&gt;&lt;p&gt;충돌 여부를 검증하는 것은 어렵지 않다. 두 물체의 반지름 값을 합한 수치가 두 물체의 중심점 좌표간의 거리보다 작으면 충돌로 인식한다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="750" data-orig-height="550" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/78cd094a36045c3c4526f3b9bead148d/tumblr_inline_omebxyNMpM1td93ol_540.jpg" alt="image" data-orig-width="750" data-orig-height="550"/&gt;&lt;/figure&gt;&lt;p&gt;충돌이 발생 했을 경우에는 M(질량변수)과 v(가속도 변수) 그리고 &lt;a href="https://ko.wikipedia.org/wiki/%EB%B0%98%EB%B0%9C_%EA%B3%84%EC%88%98"&gt;COR(반발계수)&lt;/a&gt;를 이용하여 반사각 계산 알고리즘이 실행된다. 앞서봤던 예제 코드들도 이런 방식으로 동작된다. 중요한 것은 이런 방식에서 발생하는 문제들이 있다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="960" data-orig-height="578" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/80ee4f32facae968e965583a317e97d8/tumblr_inline_omecuyt9p01td93ol_540.png" alt="image" data-orig-width="960" data-orig-height="578"/&gt;&lt;/figure&gt;&lt;p&gt;현실세계와 다르게 코드는 각각의 물체마다 반복문을 통해서 각각의 충돌여부 감지와 충돌 연산이 들어가는데 이 연산은 두개의 물체에 대해서는 문제없이 동작한다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="779" data-orig-height="650" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/b782aebd73df0c5874d870fe878b0718/tumblr_inline_omecwjr1iT1td93ol_540.png" alt="image" data-orig-width="779" data-orig-height="650"/&gt;&lt;/figure&gt;&lt;p&gt;하지만 만약 3개 이상의 물체가 동시에 충돌했다면 어떨까? g1은 g2 물체와 충돌을 감지하고 충돌 연산을 마쳐 반사된 속도 값을 구했다. 그리고 다음 물체로 넘어가게 된다. 이것이 이 소스코드의 문제점이다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;이 문제점을 해결하기 위해서는 g1은 g2와의 충돌 연산을 마치고 &lt;b&gt;g3와의 충돌을 감지하여 방금전의 속도에 간섭을 발생시켜야 한다. &lt;/b&gt;지금 코드는 g1은 g2와의 충돌만을 g2는 g1과의 충돌만을 계산했기 때문에 반사되는 각도는 정확하지 않고 심지어는 물체가 겹치게되는 문제점마저 가지게 된다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="631" data-orig-height="393" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/0b1d17820d897092f42305f4997f934c/tumblr_inline_omed0mzmt61td93ol_540.png" alt="image" data-orig-width="631" data-orig-height="393"/&gt;&lt;/figure&gt;&lt;p&gt;또한 현실에서는 일어나지 않을 법한 문제도 발생할 수 있다. 위 사진을 보면 물체 두개가 겹친 상태로 존재한다. 이런 현상을 &lt;b&gt;랜덤한 좌표에 물체를 생성할 때 우연히도 그 자리 근처에 다른 물체가 존재하는 경우&lt;/b&gt;다. 그렇다고 개발자가 생성하기 전에 그 주변에 물체가 있는지 검증하는 것도 무언가 깔끔하지 않다. 마치 문제를 회피해나가는 기분이든다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="529" data-orig-height="320" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/a9263ed352b1eba014a8ffdceddcedd1/tumblr_inline_omed34uW5f1td93ol_540.png" alt="image" data-orig-width="529" data-orig-height="320"/&gt;&lt;/figure&gt;&lt;p&gt;이럴 때는 두개의 물체는 각각의 물체를 바라보는 방향의 반대의 각도를 구해 그곳으로 일정량 지속적으로 밀어내어 문제를 해결해야 한다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="578" data-orig-height="357" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/70f4e2342b5639477c01a775e1f76235/tumblr_inline_omed49YWgn1td93ol_540.png" alt="image" data-orig-width="578" data-orig-height="357"/&gt;&lt;/figure&gt;&lt;p&gt;문제는 3개 이상의 물체가 겹칠 경우 이 밀어내는 방향에 대해서도 간섭이 발생해야 하는 것이다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="553" data-orig-height="449" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/736c9c6098de56ecef08d69f8626ca23/tumblr_inline_omedcsroeD1td93ol_540.png" alt="image" data-orig-width="553" data-orig-height="449"/&gt;&lt;/figure&gt;&lt;p&gt;무수히 많이 겹쳐서 안쪽에 물체가 빠져나가기 위해서는 바깥의 물체가 먼저 충돌처리를 완료해야 하는 문제도 있다. 이 경우 안쪽과 바깥의 사이 (중간 영역)에 있는 물체는 안쪽 방향으로 속도가 발생 할 수 있다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;이런 문제를 &lt;a href="https://en.wikipedia.org/wiki/N-body_problem"&gt;다체문제 혹은 N-Body problem&lt;/a&gt;이라고 불린다. 심지어 이것과 관련된 &lt;a href="https://www.ceremade.dauphine.fr/~fejoz/Articles/Fejoz_2014_nbp.pdf"&gt;논문들도 다수 존재한다.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;이미 &lt;a href="https://www.google.co.kr/?gfe_rd=cr&amp;amp;ei=inG9WOKIC7DEXuTVlJAJ#q=multiple+circle+collision+issue&amp;amp;*"&gt;multiple circle collision issue&lt;/a&gt;라는 키워드로 구글에 검색하면 많은 질문글과 해결방법이 존재하고 있으며 &lt;a href="http://ericleong.me/research/circle-circle/"&gt;이렇게 친절하게 작성된 &lt;strike&gt;(이 블로그보다 더)&lt;/strike&gt;&lt;/a&gt; 문서들도 있다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;

이런 문제를 어떻게 깔끔하고 효율적으로 해결 할 수 있을지 필자는 앞으로 조사를 할 계획이다. 앞으로 이 문제를 해결하고 위 샘플 코드를 업데이트한 코드를 공개할 예정이다.

&lt;br/&gt;&lt;/p&gt;</description><link>https://blog.pigno.se/post/158065572438</link><guid>https://blog.pigno.se/post/158065572438</guid><pubDate>Mon, 06 Mar 2017 21:45:34 +0900</pubDate><category>다체문제</category><category>물리법칙</category><category>탄성충돌</category><category>비탄성충돌</category><category>충돌알고리즘</category><category>N-Body problem</category><category>반사각</category><category>canvas</category><category>frontend</category></item><item><title>자바스크립트 모듈 제공을 위한 AMD, CommonJS 그리고 RequireJS 소개</title><description>&lt;p&gt;&lt;figure data-orig-width="840" data-orig-height="840" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/1d8e3b3d016542e53b51355238347647/tumblr_inline_omb2xpYKF01td93ol_540.png" alt="image" data-orig-width="840" data-orig-height="840"/&gt;&lt;/figure&gt;&lt;/p&gt;&lt;p&gt;자바스크립트는 편리한 언어이다.&lt;/p&gt;
&lt;p&gt;필자는 자바스크립트의 유연함과 고차함수, 익명함수 사용의 편리함과 직관적은&lt;/p&gt;
&lt;p&gt;정말이지 엄청난 매력을 가지고 있다고 생각한다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;이번 포스팅에는 자바스크립트가 모듈을 제공하기 위해서&lt;/p&gt;
&lt;p&gt;AMD, CommonJS를 알아보고 RequireJS에 대해서도 소개하고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;서론&lt;/h2&gt;
&lt;p&gt;필자는 오픈소스를 자주 사용한다.&lt;/p&gt;
&lt;p&gt;그리고 오픈소스 기여도 자주 하는편이라고 생각된다.&lt;/p&gt;
&lt;figure data-orig-width="1200" data-orig-height="630" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/aceb0b9afd79f851bf834227c962dfb9/tumblr_inline_omb300n7bl1td93ol_540.png" alt="image" data-orig-width="1200" data-orig-height="630"/&gt;&lt;/figure&gt;&lt;p&gt;오픈소스 참여를 할 때, 깃허브를 많이 사용하는데&lt;/p&gt;
&lt;p&gt;여러분도 이 고양문어(옥토캣)을 많이 보셨을 거라 생각한다.&lt;/p&gt;
&lt;p&gt;필자가 기여하는 프로젝트 중에&lt;/p&gt;
&lt;p&gt;달력 컴포넌트를 만들어주는 자바스크립트 프로젝트가 있다.&lt;/p&gt;
&lt;figure data-orig-width="1724" data-orig-height="1672" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/ee66bd68839ef307e6418ebed8a08a92/tumblr_inline_omb3g0Fq4K1td93ol_540.png" alt="image" data-orig-width="1724" data-orig-height="1672"/&gt;&lt;/figure&gt;&lt;p&gt;&lt;a href="https://github.com/KennethanCeyer/PIGNOSE-Calendar"&gt;이 곳에서 해당 프로젝트를 확인 할 수 있다.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 코딱지 만한 프로젝트도 점점 사용자들이 이용해주면서&lt;/p&gt;
&lt;p&gt;기능을 확장하고 있는데&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;최근에 AMD, CommonJS 지원 작업을 한 적이 있는데&lt;/p&gt;
&lt;p&gt;작업을 진행하면서 발생한 크고작은 이슈에서 얻은 경험을 공유하고자 한다.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://d2.naver.com/helloworld/12864"&gt;시작하기 앞서 이 글을 읽어보면 좋을 것 같다. (4년도 더 된 글이다..)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;배경&lt;/h2&gt;
&lt;figure data-orig-width="280" data-orig-height="280"&gt;&lt;img src="https://66.media.tumblr.com/64934485a3c925f59b9f0be04c5207fc/tumblr_inline_omb3hvEGCa1td93ol_540.png" alt="image" data-orig-width="280" data-orig-height="280"/&gt;&lt;/figure&gt;&lt;p&gt;자바스크립트는 파이썬, 루비, 다른 스크립트 언어 계열과 차이점이 존재한다.&lt;/p&gt;
&lt;p&gt;바로 모듈 사용의 표준이 존재하지 않다는 것이다. (ECMA5 기준)&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/6d6ba68b76354398f770b1e0adc0b8e2"&gt;https://gist.github.com/KennethanCeyer/6d6ba68b76354398f770b1e0adc0b8e2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;파이썬 모듈 사용&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/7d02f92ba85c16533668bfe6cdd6e4a5"&gt;https://gist.github.com/KennethanCeyer/7d02f92ba85c16533668bfe6cdd6e4a5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;루비 모듈 사용&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Node.js를 사용하고 있는 개발자들은 module.exports를 통해 모듈을 정의하고&lt;/p&gt;
&lt;p&gt;require() 함수를 통해 정의한 모듈을 불러와 사용하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://nodejs.org/docs/latest/api/modules.html"&gt;이곳을 통해 Node.js에서 모듈을 어떤식으로 사용하는 지 알 수 있다.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이러한 방식을 &lt;b&gt;CommonJS&lt;/b&gt;로 불린다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/d4848af11711a3ab3f65653449b32c43"&gt;https://gist.github.com/KennethanCeyer/d4848af11711a3ab3f65653449b32c43&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Node.js 모듈 형태를 보면 다른언어에 비해 모듈제공이 조금 차이가 있다.&lt;/p&gt;
&lt;p&gt;module.exports와 exports 두개를 사용하는데&lt;/p&gt;
&lt;p&gt;이런 제공방식은 혼동을 초래하기도 한다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;필자는 그래도 Node.js의 모듈 형식에 대해서 크게 불만을 가지고 있지 않다.&lt;/p&gt;
&lt;p&gt;문제는 프론트엔드에서는 이런 모듈 제공방식이 없었다는 것이다!!&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/609879cb173368093316eb7de667f54b"&gt;https://gist.github.com/KennethanCeyer/609879cb173368093316eb7de667f54b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그나마 비슷하게 모듈 제공방식을 따라해봤다.&lt;/p&gt;
&lt;p&gt;프론트엔드에서 사용하는 자바스크립트는 DOM 오브젝트를 사용하고 있다.&lt;/p&gt;
&lt;p&gt;전역 오브젝트인 window를 사용하면 다른 자바스크립트 파일에 리소스를 전달 할 수 있다.&lt;/p&gt;
&lt;p&gt;하지만 이것도 사용하는 HTML에서 불러오는 모듈 파일을 먼저 로드해야&lt;/p&gt;
&lt;p&gt;문제가 없이 작동된다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;즉 대상 모듈이 존재 할 수도, 존재하지 않을 수도 있는 상태가 벌어진다. (으아아악!)&lt;/p&gt;
&lt;p&gt;하지만 프론트엔드에서 사용하는 프로젝트도 규모 커지면 커질수록&lt;/p&gt;
&lt;p&gt;모듈의 필요성은 커져갔고&lt;/p&gt;
&lt;p&gt;그렇게 AMD 방식과 CommonJS 방식 두개의 모듈 정의 규칙이 생기게 되었다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;사실 두개 말고도 ES2016, ES6, System.register 등등의 모듈제공 방식도 있지만&lt;/p&gt;
&lt;p&gt;여러분의 정신건강을 위해 비밀로한다&amp;hellip; &lt;strike&gt;(이미 비밀이 아니잖아!!)&lt;/strike&gt;&lt;/p&gt;
&lt;p&gt;&lt;strike&gt;&lt;br/&gt;&lt;/strike&gt;&lt;/p&gt;
&lt;h2&gt;AMD&lt;/h2&gt;
&lt;p&gt;AMD는 Asynchronous Module Definition (비동기 모듈 정의) 규칙이다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/amdjs/amdjs-api/wiki/AMD"&gt;https://github.com/amdjs/amdjs-api/wiki/AMD&lt;/a&gt;에서 자세한 내용을 확인 할 수 있다.&lt;a href="https://github.com/amdjs/amdjs-api/wiki/AMD"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/3c78f7c18c3519355509e2174103d633"&gt;https://gist.github.com/KennethanCeyer/3c78f7c18c3519355509e2174103d633&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AMD의 규칙을 이용해서 정의해봤다.&lt;/p&gt;
&lt;p&gt;브라우저에서 모듈을 정의하고 불러오는 기능을 사용하기 위해서는&lt;/p&gt;
&lt;p&gt;AMD의 규칙을 따르는 도구를 사용해야 하는데,&lt;/p&gt;
&lt;p&gt;위의 코드에서는 RequireJS를 사용했다.&lt;/p&gt;
&lt;p&gt;(RequireJS에 대한 설명은 &lt;a href="http://requirejs.org/"&gt;http://requirejs.org/&lt;/a&gt;에서 확인 할 수 있다.)&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;figure data-orig-width="2560" data-orig-height="588" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/b122bea30345370c77951e28d2793473/tumblr_inline_omb7haoJie1td93ol_540.png" alt="image" data-orig-width="2560" data-orig-height="588"/&gt;&lt;/figure&gt;&lt;p&gt;위 사진에서 math.js는 main.js의 require 함수에 의해 &lt;b&gt;동적으로&lt;/b&gt; 로딩되었다.&lt;/p&gt;
&lt;p&gt;AMD 관련한 글 중에&lt;/p&gt;
&lt;p&gt;&lt;a href="http://tomdale.net/2012/01/amd-is-not-the-answer/"&gt;AMD is Not the Answer(AMD는 해답이 아니다.)&lt;/a&gt;라는 글이 있다.&lt;/p&gt;
&lt;p&gt;여기서는 AMD의 정의구조와 HTTP 동적 로딩을 비판하고 있는데 관심있는 분들은&lt;/p&gt;
&lt;p&gt;한번 읽어보시길 바란다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;필자는 이렇게 생각한다.&lt;/p&gt;
&lt;p&gt;AMD와 CommonJS 둘 모두 프론트엔드 브라우저에서 동적 로딩을 할 경우&lt;/p&gt;
&lt;p&gt;페이지가 열리기 전까지 수많은 JS를 사용자가 페이지를 열어볼 때 불러오므로&lt;/p&gt;
&lt;p&gt;부하가 발생하게 된다. (캐시를 해도 느린건 마찬가지)&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;여러분이 생각하는 1~20개의 자바스크립트 파일 로딩이 아니다.&lt;/p&gt;
&lt;p&gt;몇 백개의 자바스크립트를 매 사용자가 페이지를 전환할 때마다 불러 온다고 생각해보자&amp;hellip;&lt;/p&gt;
&lt;figure data-orig-width="308" data-orig-height="214" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/09c4866fe1ec6a1b286d2f2dfd9dd639/tumblr_inline_omb9nlZ9VR1td93ol_500.gif" alt="image" data-orig-width="308" data-orig-height="214"/&gt;&lt;/figure&gt;&lt;p&gt;AMD, CommonJS 모두 비동기 통신을 통해 파일을 동적으로 불러오는 경우&lt;/p&gt;
&lt;p&gt;성능의 이슈가 있기 때문에&lt;/p&gt;
&lt;p&gt;보통 프로덕션 서버로 배포 할 때 &lt;a href="https://www.sitepoint.com/javascript-modules-bundling-transpiling/"&gt;번들링(Bundling)&lt;/a&gt; 작업을 진행하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;번들링은 이후 섹션에서 자세히 설명하도록 하겠다.&lt;/p&gt;
&lt;p&gt;아까전에 얘기했던 오픈소스 프로젝트 &lt;a href="https://github.com/KennethanCeyer/PIGNOSE-Calendar"&gt;PIGNOSE Calendar&lt;/a&gt;는&lt;/p&gt;
&lt;p&gt;AMD 스타일로 모듈을 정의한다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/KennethanCeyer/PIGNOSE-Calendar/blob/master/src/js/main.js"&gt;소스코드를 통해 확인이 가능하다.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;그렇다고 RequireJS를 사용하지 않는 프로젝트에서&lt;/p&gt;
&lt;p&gt;해당 프로젝트 소스를 불러와도 (이를테면 &amp;lt;script&amp;gt; 태그를 통해 로딩 시)&lt;/p&gt;
&lt;p&gt;소스는 문제없이 작동해야한다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;AMD는 define 함수와 require 함수를 통해 모듈 정의와 로딩을 진행하는데&lt;/p&gt;
&lt;p&gt;이 두가지 함수 모두 브라우저에서 인식 할 수 있는 함수가 아니다.&lt;/p&gt;
&lt;p&gt;따라서 아까 우리는 require.js 스크립트를 추가적으로 불러와&lt;/p&gt;
&lt;p&gt;브라우저에서도 모듈 정의와 로딩이 동작하도록 했다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;하지만 라이브러리에서 require.js 파일을 의존하여&lt;/p&gt;
&lt;p&gt;같이 빌트-인 하기에는 require.js 소스코드 용량이 크다.. (18KB)&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;RequireJS 측에서는 이렇게 AMD를 사용하지만 라이브러리 형태로 제공해야하는&lt;/p&gt;
&lt;p&gt;프로젝트를 위하여 RequireJS의 미니마이즈 버전인 &lt;a href="https://github.com/requirejs/almond"&gt;Almond(아몬드)&lt;/a&gt;를 제공한다.&lt;/p&gt;
&lt;p&gt;아몬드의 설명에 따르면 gzip과 클로저 컴파일러를 이용할 때 약 1킬로바이트의 용량이 된다고 한다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;필자는 RequireJS를 번들링 하기 위해 Grunt Task(그런트 테스크)를 사용하는데&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/gruntjs/grunt-contrib-requirejs#usage-examples"&gt;그런트 RequireJS 테스트 설명을 보면&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;almond 빌트 인이 명시되어있다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;여러가지 유명 자바스크립트 라이브러리를 살펴봐도&lt;/p&gt;
&lt;p&gt;대부분 아몬드를 빌트인 하여 제공하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;CommonJS&lt;/h2&gt;
&lt;p&gt;아까 설명한 것과 같이 Node.js 진영에서는 CommonJS를 기본으로 사용하고 있다.&lt;/p&gt;
&lt;p&gt;그 외에도 tsconfig에서 commonjs로 모듈을 정의해도 CommonJS로 정의가 된다.&lt;/p&gt;
&lt;p&gt;CommonJS 제공이 중요한 이유가&lt;/p&gt;
&lt;p&gt;당연하게도 Node.js에서 모듈을 불러오는 기본 스타일이 CommonJS이기 때문에&lt;/p&gt;
&lt;p&gt;프론트엔드 라이브러리일지라도 Node.js 코드를 통해 유닛 테스팅을 하는 경우&lt;/p&gt;
&lt;p&gt;혹은 &lt;a href="https://momentjs.com/"&gt;moment&lt;/a&gt;, &lt;a href="http://underscorejs.org/"&gt;underscore&lt;/a&gt;처럼 Node.js에서도 사용 가능해야하는 라이브러리 일 경우&lt;/p&gt;
&lt;p&gt;&lt;b&gt;CommonJS 모듈 형태도 제공해야 한다.&lt;/b&gt; &lt;strike&gt;(맙소사, 저 울어도 되요?)&lt;/strike&gt;&lt;/p&gt;
&lt;p&gt;&lt;strike&gt;&lt;br/&gt;&lt;/strike&gt;&lt;/p&gt;
&lt;h2&gt;번들링&lt;/h2&gt;
&lt;p&gt;번들링을 쉽게 설명하자면&lt;/p&gt;
&lt;p&gt;여태까지 여러분이 모듈들을 &lt;strike&gt;싸질러놓은 똥을&lt;/strike&gt; 하나의 단일 파일로 취합하는 과정이다.&lt;/p&gt;
&lt;p&gt;앞서 말씀드린 모듈 타입(AMD, CommonJS, ES2015, ES6 etc)을&lt;/p&gt;
&lt;p&gt;분석하고 거기서 불러오는 파일을 파악하여&lt;/p&gt;
&lt;p&gt;하나로 모아주는 번들러(Bundler)가 필요한데.&lt;/p&gt;
&lt;figure data-orig-width="840" data-orig-height="400" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/eead7f8d0e7bf6f9c511c480339ab4e1/tumblr_inline_ombdfrSTF91td93ol_540.png" alt="image" data-orig-width="840" data-orig-height="400"/&gt;&lt;/figure&gt;&lt;p&gt;많이 사용하는 번들러 종류는 아래와 같다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://webpack.github.io/"&gt;Webpack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://rollupjs.org/"&gt;Rollup.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://jspm.io/"&gt;Jspm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://browserify.org/"&gt;Browserify&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gruntjs.com/"&gt;Grunt&lt;/a&gt;와 &lt;a href="http://gulpjs.com/"&gt;Gulp&lt;/a&gt;와 같은 빌드테스크 도구에서도 플러그인을 연결하여&lt;/p&gt;
&lt;p&gt;번들링을 진행 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;PIGNOSE Calendar는 앞서 말했듯 Grunt를 사용하여&lt;/p&gt;
&lt;p&gt;RequireJS를 번들링하고 Almond를 묶어서&lt;/p&gt;
&lt;p&gt;&amp;lt;script&amp;gt; 태그를 통해 불러오더라도 문제없이 작동한다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;번들러의 선택은 여러분의 자유지만&lt;/p&gt;
&lt;p&gt;여러분의 정신건강 상 웹팩(Webpack) 번들러를 사용하시기를 권장드린다.&lt;/p&gt;
&lt;p&gt;필자는 &lt;a href="https://angular.io/docs/ts/latest/cookbook/aot-compiler.html"&gt;AngularJS 2 AOT&lt;/a&gt; 를 사용할 때 그곳에 명시된 롤업JS(Rollup.js)를 사용했으나&lt;/p&gt;
&lt;p&gt;무수한 경고(Warning)이 표시되었고&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;AngularJS2에서는 무슨일에선지 그것을 무시하는 코드를 넣어 공식페이지에 공개했다.&lt;/p&gt;
&lt;p&gt;그 때문에 필자는 웹팩(Webpack) 버전 2로 교체하고 잘 쓰고 있다.&lt;/p&gt;
&lt;p&gt;참고로 Webpack 1에서는 AngularJS AOT를 번들링 할 때 Uglify에서 에러가 발생한다.&lt;/p&gt;
&lt;p&gt;아무도 해결방법을 공유안해서 필자가 직접 했다고 한다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/angular/angular/issues/11555"&gt;혹시 같은 문제를 겪는 분은 이 링크를 살펴보시길 바란다.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AngularJS 2 AOT를 적용하시고자 하신다면 Webpack 2를 사용하시는 게 정신건강에 좋다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;배포&lt;/h2&gt;
&lt;p&gt;좀 전에 얘기드린바와같이&lt;/p&gt;
&lt;p&gt;우리의 아름다운 자바스크립트 프론트엔드 환경에서는&lt;/p&gt;
&lt;p&gt;제공하는 라이브러리를 어떤식으로 호출 할지 모른다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;require([&amp;ldquo;], function(module) {})로 사용 할 수도 있고. (AMD)&lt;/p&gt;
&lt;p&gt;var module = require(&amp;rdquo;)로 사용 할 수도 있다. (CommonJS)&lt;/p&gt;
&lt;p&gt;심지어 import { module } from &amp;ldquo;; 형태로 사용 할 수도 있다. (ES6)&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;우리는 이런 모듈 방식을 모두 제공하는 팩토리 형태를 만들어야 한다.&lt;/p&gt;
&lt;p&gt;심지어 이 팩토리 표현에 대해서는 마땅한 표준도 없다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;(세상에 마상에)&lt;/p&gt;
&lt;p&gt;표준은 아니지만 UMD라는 친구가 있는데&lt;/p&gt;
&lt;p&gt;Universal Module Definition의 약자이다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/umdjs/umd/blob/master/templates/returnExports.js"&gt;여기서 제공하는 템플릿이 그래도 많이 사용되고 있는 듯 보인다.&lt;/a&gt;&lt;/p&gt;
&lt;figure data-orig-width="236" data-orig-height="226"&gt;&lt;img src="https://66.media.tumblr.com/e6eaac6b3540a64e894fed3535604a21/tumblr_inline_ombcrfwgPU1td93ol_540.jpg" alt="image" data-orig-width="236" data-orig-height="226"/&gt;&lt;/figure&gt;&lt;p&gt;힘내세요 프론트엔드 라이브러리/프레임워크 개발자 여러분..&lt;/p&gt;
&lt;p&gt;피토하셔도 이해합니다..&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ifandelse.com/its-not-hard-making-your-library-support-amd-and-commonjs/"&gt;이 글을 읽어보자&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;글의 제목은&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s Not Hard: Making Your Library Support AMD and CommonJS&lt;/p&gt;
&lt;p&gt;(여러분의 라이브러리가 AMD와 CommonJS를 지원하는 것은 결코 어렵지 않습니다.)&lt;/p&gt;
&lt;p&gt;인데 이 글의 분량이 어느정도인지 파악이 되는가?&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;여러분은 고작 다른언어에서는 기본적으로 제공하는 모듈 지원을 위해&lt;/p&gt;
&lt;p&gt;이 정도의 글을 더 읽어야한다.&lt;/p&gt;
&lt;p&gt;(모듈 지원도아니다, 지원하고 있는 모듈 외에 모듈 정의 호환 지원이다.)&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;본론으로 돌아와서,&lt;/p&gt;
&lt;p&gt;앞서 말했던 PIGNOSE Calendar 플러그인은 AMD 모듈을 사용하고 있지만&lt;/p&gt;
&lt;p&gt;CommonJS, Plaintype(&amp;lt;script&amp;gt;를 통해서 불러오는 경우)를 지원해야 했다.&lt;/p&gt;
&lt;p&gt;이를 위해 하나의 Factory를 정의하게 되는데&lt;/p&gt;
&lt;p&gt;기초 원리는 간단하다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;우선 아래 코드를 먼저 살펴보자.&lt;/p&gt;
&lt;p class="gist"&gt;&lt;a href="https://gist.github.com/KennethanCeyer/19402abf4901a833052319ece54119d4"&gt;https://gist.github.com/KennethanCeyer/19402abf4901a833052319ece54119d4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트를 조금 공부하신분은 IIFE에 대해서 들어보셨을 것이다.&lt;/p&gt;
&lt;p&gt;IIFE는 Immediate Invoked Function Expression의 약자로 즉시 함수 호출 표현식이다.&lt;/p&gt;
&lt;p&gt;이걸 왜 사용하는지는 &lt;a href="http://chanlee.github.io/2014/01/11/understand-javascript-iife/"&gt;이곳에서&lt;/a&gt; 자세히 살펴보실 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;이것을 사용하는 주요 이유는 전역 함수와 지역 함수 구분을 위한 클로저 정의를 위해 사용한다.&lt;/p&gt;
&lt;p&gt;아까 보여드린 Factory에서도 IIFE 형태의 호출 표현식을 사용하는데&lt;/p&gt;
&lt;p&gt;root, factory 매개변수를 IIFE 형태로 전달한다.&lt;/p&gt;
&lt;p&gt;root는 this가 전달되며 factory는 모듈로 제공될 함수가 전달된다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;IIFE에서는 각 모듈을 사용하는지 검사 한후 factory를 호출하게 된다.&lt;/p&gt;
&lt;p&gt;PIGNOSE Calendar는 module.export (CommonJS) 형태에서&lt;/p&gt;
&lt;p&gt;&lt;a href="https://mochajs.org/"&gt;Mocha&lt;/a&gt;를 통한 Unit Test를 제공해야 하기 때문에&lt;/p&gt;
&lt;p&gt;각종 의존라이브러리를 추가하여 부르게 된다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;그리고 Node.js 환경에서는 window, document가 존재하지 않기 때문에&lt;/p&gt;
&lt;p&gt;window와 document를 &lt;a href="https://github.com/tmpvar/jsdom"&gt;jsdom&lt;/a&gt;을 통해 &lt;a href="http://stackoverflow.com/questions/2665812/what-is-mocking"&gt;Mocking&lt;/a&gt; 하고있다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h2&gt;결론&lt;/h2&gt;
&lt;p&gt;결론적으로 아직 자바스크립트의 &lt;b&gt;모듈링 표준은 걸음마 단계이다.&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;아직 ECMA 6가 모든 브라우저에서 채택되지 않았기 때문에 &lt;a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/import#AutoCompatibilityTable"&gt;(채택상태 보기)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;과도기적인 면모를 보인다.&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;ECMA 6가 AMD와 CommonJS 스타일을 사용하지 않기 때문에&lt;/p&gt;
&lt;p&gt;나중에는 AMD와 CommonJS 모두가 버려지는 아름다운 현상이 일어나진 않을지..&lt;br/&gt;&lt;/p&gt;
&lt;figure data-orig-width="271" data-orig-height="169"&gt;&lt;img src="https://66.media.tumblr.com/b73272a9ab69cea5debb698128493ef8/tumblr_inline_ombd2lqGtF1td93ol_500.gif" alt="image" data-orig-width="271" data-orig-height="169"/&gt;&lt;/figure&gt;&lt;p&gt;&lt;a href="https://github.com/KennethanCeyer/PIGNOSE-Calendar/blob/master/Gruntfile.js"&gt;이곳에서 RequireJS를 지원하는 Grunt 설정을 볼 수 있다.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PIGNOSE Calendar는 모듈 호환을 제공하고 브라우저에서도 정상 동작한다.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.pigno.se/barn/PIGNOSE-Calendar/"&gt;이곳에서 확인해보자&lt;/a&gt;&lt;/p&gt;
&lt;figure data-orig-width="331" data-orig-height="197" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/7b498b1e0a02c00986c886d00f67d82c/tumblr_inline_ombdy9ZsOB1td93ol_500.gif" alt="image" data-orig-width="331" data-orig-height="197"/&gt;&lt;/figure&gt;&lt;p&gt;여러분도 자바스크립트 모듈을 사용하고&lt;/p&gt;
&lt;p&gt;빈틈 없는 멋진 개발자가 되보자.&lt;/p&gt;
&lt;p&gt;&lt;strike&gt;(모듈 모르는 뇌 삽니다.)&lt;/strike&gt;&lt;/p&gt;</description><link>https://blog.pigno.se/post/157992405313</link><guid>https://blog.pigno.se/post/157992405313</guid><pubDate>Sun, 05 Mar 2017 04:34:30 +0900</pubDate><category>개발</category><category>commonjs</category><category>requirejs</category><category>amd</category><category>es2015</category><category>es6</category><category>import</category><category>exports</category><category>module</category><category>almond</category><category>factory</category><category>webpack</category><category>rollupjs</category><category>angularjs</category><category>angularjs2</category><category>ahead of time</category><category>aot</category><category>bundler</category><category>frontend</category></item><item><title>Angular 2 그리고 웹 프론트엔드 (2/3)</title><description>&lt;p&gt;&lt;figure data-orig-width="1698" data-orig-height="938" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/6edfb72cc673862709f07f700e6eb823/tumblr_inline_ol0l6tmAVE1td93ol_540.png" alt="image" data-orig-width="1698" data-orig-height="938"/&gt;&lt;/figure&gt;&lt;/p&gt;&lt;p&gt;이번 시간에는 Angular가 무엇인지 알아보도록 하자&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;연관된 글 목록&lt;/p&gt;&lt;p&gt;&lt;a href="http://blog.pigno.se/post/156765466858/angularjs-2-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%9B%B9-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-13"&gt;Angular 2 그리고 웹 프론트엔드 (1/3)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Angular 2 그리고 웹 프론트엔드 (2/3) - 현재 글&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;!-- more --&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;설명하기 앞서&lt;/h2&gt;&lt;p&gt;이 글은 Angular의 특징을 최대한 간략하게 설명한다.&lt;/p&gt;&lt;p&gt;따라서 앵귤러 코드를 자세히보고 싶은 분들&lt;/p&gt;&lt;p&gt;Angular 코드를 보며 하악하악 하고싶어하시는 분들을 위한 글이 아니다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;간단하게 자바스크립트와 Angular 코드를 비교해보고&lt;/p&gt;&lt;p&gt;차이점을 설명하는 정도로 코드 첨부는 끝날 것이다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;협업에서 Angular 도입을 고려하거나,&lt;/p&gt;&lt;p&gt;이제 Angular가 무엇인지 알아보려는 독자를 위해 글을 작성하고 있다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;만약 여러분이 Angular에 대해 자세히 알아보고 싶다면&lt;/p&gt;&lt;p&gt;Angular 2 그리고 웹 프론트엔드 (3/3)을 읽어보시기 바란다.&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure class="tmblr-embed tmblr-full" data-provider="youtube" data-orig-width="540" data-orig-height="304" data-url="https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DzC9_0V9ong4"&gt;&lt;iframe width="540" height="304" id="youtube_iframe" src="https://www.youtube.com/embed/zC9_0V9ong4?feature=oembed&amp;amp;enablejsapi=1&amp;amp;origin=https://safe.txmblr.com&amp;amp;wmode=opaque" frameborder="0" allowfullscreen=""&gt;&lt;/iframe&gt;&lt;/figure&gt;&lt;p&gt;영상에서 Angular에 대해 &lt;strike&gt;간단하게(30분)&lt;/strike&gt; 설명한다.&lt;/p&gt;&lt;p&gt;동영상이 길기 때문에 &lt;a href="https://www.slideshare.net/KennethCeyer/angularjs-2-version-1-and-reactjs-69546904"&gt;슬라이드 자료를 보는 것을 권장한다.&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;프레임워크 vs 라이브러리&lt;/h2&gt;&lt;p&gt;한때 필자가 운영하던 페이스북 페이지에서&lt;/p&gt;&lt;p&gt;라이브러리와 프레임워크 프로젝트를 비교하면서 프레임워크 프로젝트에서&lt;/p&gt;&lt;p&gt;더 많은 기능을 제공한다고 올렸던 적이 있는데.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="300" data-orig-height="225" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/14d82b31044d1a35bc3f43c05db14c8c/tumblr_inline_omayqblJvF1td93ol_500.gif" alt="image" data-orig-width="300" data-orig-height="225"/&gt;&lt;/figure&gt;&lt;p&gt;결과적으로&lt;strike&gt; 가루가 되도록 털렸다. (엉엉)&lt;/strike&gt;&lt;/p&gt;&lt;p&gt;프레임워크와 라이브러리가 가끔 혼용되어 사용되면서 오해가 생겼다고 생각한다.&lt;/p&gt;&lt;p&gt;둘의 개념은 엄연히 다른 개념이기 때문에 이 자리를 빌어 간단한게 설명을 해볼까 한다.&lt;/p&gt;&lt;figure data-orig-width="600" data-orig-height="990" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/ed08181de5186c8dffcaf995eed94924/tumblr_inline_ol0lixhkFL1td93ol_540.png" alt="image" data-orig-width="600" data-orig-height="990"/&gt;&lt;/figure&gt;&lt;p&gt;(사진출처: 트위터 &lt;a href="https://twitter.com/jaffathecake/status/495128859919261696"&gt;@jaffathecake&lt;/a&gt;)&lt;/p&gt;&lt;p&gt;&lt;b&gt;프레임워크(Framework):&lt;/b&gt; &lt;/p&gt;&lt;p&gt;큰 틀(Frame)안에서 그 규칙에 맞게 정의된 기능과 라이프사이클을 지키며 기능을 개발할 수 있는 도구.&lt;/p&gt;&lt;p&gt;&lt;b&gt;라이브러리(Library):&lt;/b&gt; &lt;/p&gt;&lt;p&gt;기존 개발된 기능은 지키면서 라이브러리가 제공하는 기능을 추가적으로 사용하여 파워업 할 수 있는 도구.&lt;/p&gt;&lt;p&gt;대게 라이브러리보다 프레임워크가 제공하는 기능이 더 큰 편이며&lt;/p&gt;&lt;p&gt;러닝커브도 프레임워크가 더 높은 편이다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;Angular&lt;/h2&gt;&lt;p&gt;자 그럼 주제로 돌아와서 Angular를 알아보자.&lt;/p&gt;&lt;p&gt;Angular는 Google에서 2009년 Feedback 서비스를 개발하는 도중 탄생된 자바스크립트 프레임워크이다.&lt;/p&gt;&lt;p&gt;당시만해도 화면(View)이 동적으로 바뀌는 페이지를 만들고&lt;/p&gt;&lt;p&gt;그곳에 이벤트 함수들을 바인딩(이벤트를 연결하는 과정)하는 로직을 추가하는 것을 짜는 과정을&lt;/p&gt;&lt;p&gt;고스란히 순수 자바스크립트 혹은 라이브러리로 작성했기 때문에 굉장히 &lt;b&gt;코드라인이 길었다&lt;/b&gt;.&lt;/p&gt;&lt;p&gt;그 높으신 &lt;strike&gt;최고존엄&lt;/strike&gt; 구글 엔지니어들도 이런 개발방식에 피곤함을 느꼈을테고&lt;/p&gt;&lt;p&gt;그렇게 조금 더 편리한 방법을 모색하는 도중 Angular가 만들어졌다.&lt;/p&gt;&lt;figure data-orig-width="1911" data-orig-height="497" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/167e29995c0d0e3bf2f2d1b2a48c4681/tumblr_inline_ol0lw0VtCj1td93ol_540.png" alt="image" data-orig-width="1911" data-orig-height="497"/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;br/&gt;본격적으로&lt;/h2&gt;&lt;p&gt;그래서 결국 앵귤러라는 친구는 무엇일까?&lt;/p&gt;&lt;p&gt;과거에 필자는 앵귤러를 &lt;b&gt;개발 생산성을 극대화시켜주는 프레임워크&lt;/b&gt;라고 설명했다.&lt;/p&gt;&lt;p&gt;물론 맞는 말이다. 하지만 앵귤러를 사용해오지 않았던 사람들은 이것이 도대체 어떤 방법으로 생산성을 극대화 시켜주는 것인지 와닿지 않는다.&lt;/p&gt;&lt;p&gt;앵귤러는 기존 방식과는 너무나도 다른 방향을 가지고 있다.&lt;/p&gt;&lt;p&gt;그래서 앵귤러를 실제로 사용해보지 않은 분들에게 이를 설명하는 것이 너무나 힘들다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;필자는 앞으로 앵귤러를&lt;/p&gt;&lt;p&gt;“&lt;b&gt;자바스크립트의 문제를 다 덮어주는 프레임워크&lt;/b&gt;&amp;ldquo;라고 설명하고 싶다.&lt;/p&gt;&lt;p&gt;여러분은 이 다음 섹션에서 구체적으로 자바스크립트가 어떤 문제를 가지고 있는지 알게 될 것이다. &lt;/p&gt;&lt;p&gt;다소 글이 길어질 수 있으니 우리 블로그 &lt;a href="http://blog.pigno.se"&gt;피그노즈&lt;/a&gt; 스타일대로 많은 링크와 그림을 첨부한다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;예를들어보자,&lt;/p&gt;&lt;p&gt;필자는 IT 개발관련 분야에서 솔루션을 개발하고 있는 개발자이다. &lt;/p&gt;&lt;p&gt;C#으로 ASP.NET을 이용하여 웹 서비스를 개발하고 있으며&lt;/p&gt;&lt;p&gt;내가 속한 팀 외에도 회사에서는 메이저언어는 C#을 주로 이룬다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;물론 JAVA도 사용하고 있지만 결과적으로 &lt;b&gt;객체 중심의 개발&lt;/b&gt;이 주로 이루어진다.&lt;/p&gt;&lt;p&gt;내 입장에서 볼 때 객체 중심 개발은 협업에 있어 상당히 적응력을 높여주고&lt;/p&gt;&lt;p&gt;개발에 대한 관점을 직접적으로 알려 준다.&lt;/p&gt;&lt;figure data-orig-width="480" data-orig-height="480" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/c2d61df73c351cc1a35964f7eb9927f1/tumblr_inline_omati3TwAP1td93ol_540.png" alt="image" data-orig-width="480" data-orig-height="480"/&gt;&lt;/figure&gt;&lt;p&gt;다시 자바스크립트로 주제를 옮겨보자 &lt;/p&gt;&lt;p&gt;필자는 프론트엔드 개발도 같이 하고있고 자바스크립트를 사랑하고 자주 사용하고 있는 언어이다.&lt;/p&gt;&lt;p&gt;(필자는 이전 직장에서는 Node.js로 웹서비스를 개발하고 있었다.)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;하지만 자바스크립트에는 굉장한 문제점들이 있었으니!!&lt;/h2&gt;&lt;figure data-orig-width="346" data-orig-height="236" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/f32eaa68f9f8e8fd7e5bec83f585dbf6/tumblr_inline_omato31lBW1td93ol_500.gif" alt="image" data-orig-width="346" data-orig-height="236"/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;첫 번째로 협업이 어렵다.&lt;/b&gt;&lt;/p&gt;&lt;p&gt;앞서 거론한 C#과 같은 타입을 제공하는 객체지향 프로그래밍은 &lt;/p&gt;&lt;p&gt;다른 프로그래밍 언어에서 익히 사용하는 클래스, 상속, 추상화개념을 받아들이기 때문에 협업에서 사용하는 형태가 유사하다. &lt;/p&gt;&lt;p&gt;(따라서 다른사람의 코드를 쉽게 이해 할 수 있고 이로인해 협업에 용이하다.)&lt;/p&gt;&lt;p&gt;하지만 우리의 자바스크립트는 변수에 대한 타입을 제공하지 않는다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;figure data-orig-width="960" data-orig-height="720" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/87bedc7497759ef29844afab67f4c478/tumblr_inline_omax3xoz0S1td93ol_540.png" alt="image" data-orig-width="960" data-orig-height="720"/&gt;&lt;/figure&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;마찬가지로 자바스크립트는 클래스를 사용하지 않고&lt;/p&gt;&lt;p&gt;&lt;b&gt;프로토타입&lt;/b&gt;이라는 자바스크립트 고유의 객체 사용 형태를 제공하고 있다.&lt;/p&gt;&lt;p&gt;그리고 C#과 같이 객체 사용에 무조건 프로토타입을 제공하는 것도 아니다.&lt;/p&gt;&lt;p&gt;(&lt;a href="http://webclub.tistory.com/390"&gt;리터럴 오브젝트&lt;/a&gt;를 사용한다.)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://scotch.io/bar-talk/4-javascript-design-patterns-you-should-know"&gt;자바스크립트 디자인패턴&lt;/a&gt;을 보자&lt;/p&gt;&lt;p&gt;우리의 자바스크립트는 &lt;a href="https://en.wikibooks.org/wiki/JavaScript/Anonymous_functions"&gt;익명함수&lt;/a&gt;로 수많은 디자인패턴을 성공적(?)으로 제공한다!&lt;/p&gt;&lt;p&gt;이런 무수한 익명함수와 사용형태는&lt;/p&gt;&lt;p&gt;다른 협업에 있어 가독성을 떨어트리게 되고 심지어 &lt;a href="https://en.wikipedia.org/wiki/Intelligent_code_completion"&gt;코드 인텔리전트&lt;/a&gt; 기능으로도 확인 할 수 없어 혼란을 야기한다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;여러분이 협업 개발을 하지 않는다고 해도&lt;/p&gt;&lt;p&gt;여러분은 여러분이 짠 코드 가독성을 중요하게 생각한다면&lt;/p&gt;&lt;p&gt;자바스크립트가 얼마나 많은 가독성 문제가 있는지 알고 계실 것이다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://www.barbarianmeetscoding.com/blog/2015/05/26/mastering-the-arcane-art-of-javascript-mancy-for-c-sharp-developers-chapter-5-more-useful-function-patterns-function-overloading/"&gt;더 자세한 사항은 이 글을 보시길(원문)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;두 번째로 코스트가 발생한다.&lt;/b&gt;&lt;/p&gt;&lt;p&gt;우리의 자바스크립트는 &lt;a href="http://usejsdoc.org/"&gt;JSDoc&lt;/a&gt;과 &lt;a href="https://ko.wikipedia.org/wiki/%EC%9C%A0%EB%8B%9B_%ED%85%8C%EC%8A%A4%ED%8A%B8"&gt;단위테스트&lt;/a&gt;, &lt;a href="http://www.jslint.com/"&gt;JSLint&lt;/a&gt;와 같이 개발 도구를 이용하여&lt;/p&gt;&lt;p&gt;앞서 설명한 문제를 막고 프로토타입 기반으로 개발코드를 작성하면 협업문제가 개선된다.&lt;/p&gt;&lt;p&gt;필자도 그렇게 생각하고 있고 그렇게 개발하고 있다.&lt;/p&gt;&lt;p&gt;이미 이러한 문제는 오래전부터 거론되어 왔고&lt;/p&gt;&lt;p&gt;그것을 해결하기 위한 솔루션도 있는데 왜 이용을 안하는가?&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;결론은 그런 것을 알지도 못하고 그런것을 알기도 싫어하는 개발자가 존재하기 때문이다. &lt;/b&gt;(ㅁ..뭐?)&lt;/p&gt;&lt;figure data-orig-width="500" data-orig-height="375" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/5329a4f19e751629a064841a1cb91343/tumblr_inline_omatsvcaoW1td93ol_500.gif" alt="image" data-orig-width="500" data-orig-height="375"/&gt;&lt;/figure&gt;&lt;p&gt;우리는 경건하게(?) 두손을 모아 바르게(현실적으로) 생각해볼 필요가 있다.&lt;/p&gt;&lt;p&gt;실무에서 개발자의 역할 중 가장 중요한 것은 서비스를 성공적으로 완성시키는 것이다.&lt;/p&gt;&lt;figure data-orig-width="920" data-orig-height="1150" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/2114f86e9b0ead458a759bffa8531b32/tumblr_inline_omatvgJFI01td93ol_540.png" alt="image" data-orig-width="920" data-orig-height="1150"/&gt;&lt;/figure&gt;&lt;p&gt;위 사진은 “Done is better than perfect”&lt;/p&gt;&lt;p&gt;(단지 끝내는 것이 완벽한 것보다 낫다.)&lt;/p&gt;&lt;p&gt;어느 웹 서비스 회사(페이스북)에 걸려있는 문구이다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;이 글을 읽는 여러분은 너무나도 똑똑하기 때문에&lt;/p&gt;&lt;p&gt;업무를 하는 본질은 이미 알 것이기 때문에 설명은 생략한다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;통합 개발환경(IDE) 기본옵션에서 어느정도 빌드과정에서 런타임에서 발생할만한 문제를 잡아주는 언어(C#, JAVA, C, C++, go, rust, haskell etc)는&lt;/p&gt;&lt;p&gt;협업에서도 그 규칙을 지키면 되기에 안정적인 개발을 수행 할 수 있다.&lt;/p&gt;&lt;p&gt;다만 변수 타입제한이 없고 개발자 스타일별로 코딩방식이 아에 나눠져있는 언어들(Javascript, PHP, ruby etc)는 결국 성숙한 개발환경이 아니면 협업 불가능한 코드양산이 가능하다.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;앞서 말했듯이 성숙한 개발환경을 만들기 위해서는 이미 안정적인 서비스 운영을 하고 있는 업체에서 실행이 가능하다.&lt;/p&gt;&lt;p&gt;따라서 그 이전에 단계에 있는 업체들은 자바스크립트로 개발하는 모든 프로젝트에서 하나의 룰을 정하고 그것을 따르게 강제해야한다.&lt;/p&gt;&lt;p&gt;관리자 입장에서는 다른언어와 비교할 때 그것이 불필요한 코스트가 될 수 있다.&lt;/p&gt;&lt;p&gt;그리고 개발 안정화를 위한 시스템 도입또한 코스트로 산정이 될 수 있다.&lt;/p&gt;&lt;p&gt;(이것이 자바스크립트의 단점으로 지목 될 수 있다.)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;모던 프레임워크&lt;/h2&gt;&lt;p&gt;앵귤러를 설명하기 위해서는 결국 자바스크립트의 본질적인 문제를 파악 할 필요가 있었다.&lt;/p&gt;&lt;p&gt;&lt;b&gt;앵귤러는 프레임워크이다.&lt;/b&gt;&lt;/p&gt;&lt;p&gt;프레임워크는 모두 그 프레임워크의 규칙내에서 개발을 진행 하게 되어있다.&lt;/p&gt;&lt;p&gt;프레임워크답게 여러 개발 패턴들을 제공하고 있는데&lt;/p&gt;&lt;p&gt;버전 1에서는 &lt;a href="http://www.haruair.com/blog/3223"&gt;service, provider, factory&lt;/a&gt;와 같이&lt;/p&gt;&lt;p&gt;일반적으로 많이 사용하는 디자인패턴을 아에 앵귤러 자체 정의형식으로 제공한다. &lt;a href="https://blog.thoughtram.io/angular/2015/07/07/service-vs-factory-once-and-for-all.html"&gt;이곳에서 확인하세요&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;심지어 앵귤러 버전 2에서는 타입스크립트(Typescript)를 지원한다.&lt;/p&gt;&lt;p&gt;기존의 자바스크립트에서는 불가능 한 &lt;a href="https://www.typescriptlang.org/docs/handbook/decorators.html"&gt;데코레이터&lt;/a&gt;, &lt;a href="http://www.typescriptlang.org/docs/handbook/classes.html"&gt;클래스&lt;/a&gt;, &lt;a href="https://www.typescriptlang.org/docs/handbook/basic-types.html"&gt;변수타입&lt;/a&gt; 등을 사용 할 수 있다.&lt;/p&gt;&lt;figure data-orig-width="720" data-orig-height="405" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/90096d55ce5d7928d0df36ac39ff2285/tumblr_inline_omavsc0vSM1td93ol_540.png" alt="image" data-orig-width="720" data-orig-height="405"/&gt;&lt;/figure&gt;&lt;p&gt;위 사진은 자바스크립트로 Ajax 기능을 이용해서&lt;/p&gt;&lt;p&gt;원격지 JSON 파일에 맞는 UI를 반영하는 기술에 대한 도식이다.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;JSON 파일을 파싱해서 for in 형태의 반복문으로&lt;/p&gt;&lt;p&gt;각각의 아이템에 맞는 엘리먼트 요소를 생성하여 그 엘리먼트에 맞는 이벤트를 연결해야 한다.&lt;/p&gt;&lt;figure data-orig-width="720" data-orig-height="405" class="tmblr-full"&gt;&lt;img src="https://66.media.tumblr.com/ffb9854fdd6c02779de84f2f6b022996/tumblr_inline_omavsd44Qz1td93ol_540.png" alt="image" data-orig-width="720" data-orig-height="405"/&gt;&lt;/figure&gt;&lt;p&gt;제이쿼리로 사용해도 메소드 사용이 조금 편리해지는 점 외에 큰 변화는 없다.&lt;/p&gt;&lt;p&gt;여태껏 개발자들은 이런 개발방법에 대해서 크게 불편사항을 느끼지 못했다.&lt;/p&gt;&lt;p&gt;하지