<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jei&#39;s blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://jae-kwang.github.io/blog/"/>
  <updated>2019-03-17T09:10:42.231Z</updated>
  <id>https://jae-kwang.github.io/blog/</id>
  
  <author>
    <name>Jei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>브라우저 렌더링 최적화(1)</title>
    <link href="https://jae-kwang.github.io/blog/2019/03/17/browser-rendering-optimization/"/>
    <id>https://jae-kwang.github.io/blog/2019/03/17/browser-rendering-optimization/</id>
    <published>2019-03-17T07:59:39.000Z</published>
    <updated>2019-03-17T09:10:42.231Z</updated>
    
    <content type="html"><![CDATA[<p>Udacity의 Browser Rendering Optimization 강의를 수강하고 나서 정리해보았습니다.<br>1, 2, 3 강의 내용입니다.</p><a id="more"></a><p>이 과정은 브라우저의 렌더링 파이프 라인을 파악하여 고성능 웹 응용 프로그램을 쉽게 만들 수 있도록 도와줍니다.</p><h3 id="1-The-Critical-Rendering-Path"><a href="#1-The-Critical-Rendering-Path" class="headerlink" title="1. The Critical Rendering Path"></a>1. The Critical Rendering Path</h3><p>오늘날 디바이스들은 <strong>초당 60번</strong> 화면을 다시 그립니다.</p><p>서비스 사용자들은 이 프레임 중 하나가 늦어진다는 것을 쉽게 알아챕니다. (화면이 버벅대는 현상)</p><p>이런 결과는 서비스의 평가를 낮출 뿐만 아니라 실제로 서비스가 멈출 수 있는 가능성까지 있습니다.</p><p>1000ms당 60프레임을 렌더링하려면 단일 프레임을 렌더링하기 위해선 약 16ms(1000/60)가 필요합니다.<br>즉, 유려하고 버벅대지 않는 자연스러운 화면을 만들기 위해서는 16ms 미만으로 프레임이 구성되도록 작업이 되어야 합니다.</p><p>우선 프레임이 구축되는 순서를 살펴보겠습니다.<br>처음 브라우저는 서버에 GET 요청을 하고 서버는 응답으로 HTML을 보냅니다.</p><p>이때, 브라우저는 해당 HTML을 파싱하는데 이 단계를 <strong>Chrome Dev Tools</strong> 에서는 <span class="highlight-text blue">Parse HTML</span>로 나타내며, CSS 파싱은 <span class="highlight-text blue">Parse Stylesheet</span>, DOM과 CSS 결합은 <span class="highlight-text purple">Recalculate Styles</span>로 표현하고 있습니다.<br><br>이렇게 DOM과 CSS가 결합하면 Render Tree를 구축합니다.Render Tree는 Dom Tree와 비슷해 보이지만 CSS를 통해 보이지 않는 요소는 제거됩니다.즉, 페이지에 실제로 보이는 요소만 Render Tree에 표시됩니다.<br><br>브라우저가 요소에 적용되는 규칙(공간을 얼마나 차지하고, 어디에 있는지 등)을 알게 되면, 레이아웃 계산을 시작할 수 있습니다.이는 <span class="highlight-text purple">Layout</span>으로 표현하고 있습니다. 다음 해당 픽셀에 색을 채우는 Rasterizer 단계인데 이는 <span class="highlight-text green">Paint</span>로 표현됩니다.<br><br>브라우저는 레이어라는 불리는 여러 표면을 만들고 그것들을 개별적으로 그릴 수 있습니다. 이러한 개별적인 레이어를 합치는 단계는 <span class="highlight-text green">Composite</span>로 표현합니다.</p><p>이렇게 브라우저는 렌더링 파이프라인을 가지고 있습니다.<br>Javascript로 위의 파이프라인을 제어할 수 있는 경우는 3가지의 경우있습니다.</p><div class="figure " style="width:;"><img class="fig-img" src="rendering-pipline.jpg" alt=""></div><p>첫째, Javascipt로 요소에 변형을 가했을 경우 Style, Layout, Paint, Composite단계가 모두 발생합니다.<br>둘째, 색상만 변경했을 경우에는 Layout이 발생하지 않고 Style, Paint, Composite만 발생합니다.<br>셋째, 위치 및 색상 모두 변경되지 않는 것을 수정 했을 경우에는 Style, Composite만 발생합니다. (transform, opacity는 요소가 레이어를가지고 있을경우 Composite에서 만 처리됩니다.)</p><blockquote><p><a href="https://developers.google.com/web/fundamentals/performance/rendering/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/rendering/</a></p></blockquote><h3 id="2-App-Lifecycles"><a href="#2-App-Lifecycles" class="headerlink" title="2. App Lifecycles"></a>2. App Lifecycles</h3><p>웹 앱 라이프 사이클은 Load, Idle, Animation, Response로 4가지의 영역이 존재합니다.</p><p>사용자는 언제나 페이지가 빠르게 Load 되기를 원합니다. 이때에는 처음 페이지가 보이기 위해 꼭 필요한 것들만 필요로 합니다. 모든 방법을 써서 1초 안에 이 과정을 완료되도록 최적화하는 것은 매우 중요합니다. (파일 크기 축소, CDN 활용 등)</p><p>앱이 완전히 Load 된 후는 보통 Idle 상태입니다. 이것은 사용자가 상호작용하기를 기다린다는 의미로, 이때는 Load 시간을 1초로 맞추기 위해 뒤로 미뤄두어야 했던 작업들을 수행할 수 있습니다. 예들 들자면, 곧바로 보여게 될 수도 있는 이미지, 비디오, 다른 섹션의 내용을 호출하는 동작들입니다.</p><p>이후 사용자의 상호작용을 기다리는데 이때 1장에서 알아본 것처럼 16ms 미만의 시간 안에 처리해야 유려하게 보일 수 있습니다. 이때 opacity, transform을 사용할 경우 composite만 trigger 되기 때문에 다른 layout이나 paint가 발생하여 다시 렌더링을 해야 하는 것을 막을 수 있습니다.</p><p>즉, 요약하자면. 사용자에게 유려한 페이지를 제공하는 방법은 아래와 같습니다.</p><ol><li>Load : 사용자에게 보이는 페이지는 1초 이내에 렌더링 되어서 나와야 한다.</li><li>Idle : Load의 시간을 맞추기 위해 뒤로 미루었던 작업이나 미리 해두어야 할 작업을 선택적으로 수행한다.</li><li>Animation : 사용자 상호작용에 대한 프레임 렌더링은 16ms(초당 60프레임이내로 제공되어야 한다.</li><li>Response : 사용자 입력에 대해 100ms 이내에 어떤 방식으로든 응답한다.</li></ol><p>어떤 시점에서 무엇을 할 수 있는지, 언제 할 수 있는지를 알면 성능개선에 도움이 됩니다. </p><h3 id="3-Weapons-of-Jank-Destruction"><a href="#3-Weapons-of-Jank-Destruction" class="headerlink" title="3. Weapons of Jank Destruction"></a>3. Weapons of Jank Destruction</h3><p>Chrome Dev Tools에서 <strong>Performance 탭</strong>에서 변화를 레코드 할 수 있습니다.</p><p>이는 초당 프레임 수와 프레임마다 어떤 작업이 포함되었는지 알려줍니다.</p><p>여기에는 단계별로 색상 코드가 존재합니다.</p><p>파란색은  <span class="highlight-text blue">Parse HTML</span>입니다.<br>보라색은 <span class="highlight-text purple">Recalculate style</span>과 <span class="highlight-text purple">Layout</span>입니다.<br>녹색은 <span class="highlight-text green">Paint</span>와 <span class="highlight-text green">Composite</span>입니다.</p><p>초당 60프레임이 넘어가는 작업을 확인하고 개선할 수 있습니다.<br>확인 전에 현재의 값을 측정하는 작업은 중요합니다.<br>만약 측정을 하지 않고 수정한다면 수정 후 실제로 얼마나 개선되었는지 알 수 없습니다.<br>차이를 비교하기 위해 사전에 값을 측정해 놓는 것은 매우 중요합니다.</p><p><strong>Performance 탭</strong>에서 빨간색 삼각형을 성능에 문제가 있을 수 있는 부분에서 경고해줍니다.</p><p>해당 영역을 클릭하면 어디에서 시간을 오래 소비하고 있는지 코드 위치까지 찾아볼 수 있습니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Udacity의 Browser Rendering Optimization 강의를 수강하고 나서 정리해보았습니다.&lt;br&gt;1, 2, 3 강의 내용입니다.&lt;/p&gt;
    
    </summary>
    
      <category term="Browser" scheme="https://jae-kwang.github.io/blog/categories/Browser/"/>
    
    
      <category term="Browser" scheme="https://jae-kwang.github.io/blog/tags/Browser/"/>
    
      <category term="Rendering" scheme="https://jae-kwang.github.io/blog/tags/Rendering/"/>
    
      <category term="Optimization" scheme="https://jae-kwang.github.io/blog/tags/Optimization/"/>
    
  </entry>
  
  <entry>
    <title>첫 이직을 뒤돌아보며</title>
    <link href="https://jae-kwang.github.io/blog/2019/03/03/retrospect(03.03)/"/>
    <id>https://jae-kwang.github.io/blog/2019/03/03/retrospect(03.03)/</id>
    <published>2019-03-03T10:17:30.000Z</published>
    <updated>2019-03-04T13:16:11.820Z</updated>
    
    <content type="html"><![CDATA[<p>18.12.03 이직 후 3개월이 지났다. 많은 생각을 하게 되는 의미 있는 기간이었다.</p><a id="more"></a><h3 id="목표"><a href="#목표" class="headerlink" title="목표"></a>목표</h3><p>첫 직장에서의 목표는 배운 지식이 실제 사회에서 어떻게 사용되는지를 알고자 하는 것이 가장 큰 목표였다. 아무래도 학문과 실제는 차이가 있기 때문이다. 그 결과 목표보다 더 많은 것들을 얻었다. 사회생활, 좋은 동료들, 나만의 가치관을 얻었으며 자연스럽게 나의 두 번째 목표를 가지게 되었다.<br><br></p><ul><li>같은 관심사를 갖는 동료들</li><li>더 많은 사용자</li><li>프로란 무엇인가?</li></ul><p>처음엔 혼자 이런저런 시도를 하면서 개발을 하는 것이 나만의 무언가를 만든다는 생각에 재미있고 만족스럽지만, 시간이 흐르면 혼자 아둥바둥한다는 느낌과 함께 막막하다는 생각을 하게 된다. 이때, 가장 많이 하는 생각 중에 하나는 “이게 맞는 건가?” 라는 것이다. 이런 문제에 대한 해결방법은 사람마다 다양하다. 오픈소스를 찾아보면서 자신을 고취하는 사람도 있을 테고, 아예 이런 생각을 하지 못할 환경에 놓여 있을 수 있다. 하지만 나는 같은 고민을 나눌 동료가 필요했다. </p><p>3개월 동안 지내보면서 이곳에는 같은 목표를 가진 동료들도, 같은 고민을 나눌 동료들도, 동기부여를 주는 동료들도 많다. 이런 환경에서 일할 수 있다는 점만으로 목표 중 하나는 이루었다. 이제는 이러한 긍정적인 환경을 잘 흡수할 내 노력만 남았다.</p><p>작은 회사에서 알지 못하는 것 중 하나는 많은 사용자들을 대응하는 방법이다. 소수의 사용자들을 대응하는 방법은 그리 많지 않다. 하지만 사용자 수가 많다면 얘기가 달라진다. 실제 서비스 구현 이외에도 네트워크, 브라우저의 렌더링 속도, 리소스 관리 등에도 더 많은 관심을 기울여야 한다. 그러한 부분을 제어 하는 부분에서 많은 니즈를 느끼고 있었다.</p><p>현재는 구현은 기본이고 이런 부분들을 같이 의논하고 피드백을 주고 받고며, 전혀 몰랐던 부분에 대하여 정보를 얻고 익히는 자리가 자연스럽게 생기고 있어서 좋다.</p><p>마지막은 프로다움이다. 이제 개발을 업무로써 4년 정도 하고 있는데 아직도 프로다운 태도에는 많은 궁금증을 가지고 있다. 프로다운 것은 무엇일까? 모르는 것이 없고, 계획에 빈틈이 없고 철두철미함을 말하는 걸까? 지금까지 여러 가지 본보기가 있었지만, 동료가 많은 이곳에서는 그 답을 좀 더 명확히 얻을 수 있으리란 기대가 있다.</p><h3 id="기억하자"><a href="#기억하자" class="headerlink" title="기억하자"></a>기억하자</h3><p>이곳에 있으면서 지금까지 짧은 기간 이지만 여러 가지를 알게 되었는데, 그중에 기억하고 싶은 것은 키워, 네이밍, 설계이다.</p><p>개발 용어, 줄임말, 업무용 언어 등 다양한 용어들이 쏟아졌다. 용어를 모르니까 전체적인 그림이 그려지지 않았기에 그것들을 하나씩 익히는데 많은 시간과 노력을 기울였다. 비록 아직 완전히 커버하지는 못해서, 아직 빈틈이 많지만 하나씩 그 퍼즐들을 맞춰가면서 적응하고 있는 게 재미있기만 하다.</p><p>알지 못했던 개발 용어를 배우는 건 정말 좋다. 용어를 아는 것 자체가 사고의 확장이기 때문이다. 모두 놓치지 말고 내것으로 만들고 싶다.</p><p>네이밍의 중요성은 익히 알고 있다. 하지만 내가 알고 있던 부분은 가독성에만 영향을 미친다는 작은 부분만을 생각하고 있었다. 네이밍은 가독성을 포함하여 시스템 전체, 기능, 구조에도 영향을 미칠 정도로 중요하다. 이름에는 그 이름이 포함하고 있는 여러 가지 의미가 있기에 아주 작은 단위의 이름이 아니라면, 그 이름이 가지고 있는 의미를 신중히 생각하지 않으면 코드의 의미가 혼란스러울 가능성이 있다. (Event, Bridge, Listener, Emit, Action, Request … )</p><p>지금까지 나는 프로젝트 설계에 있어서 패턴과 및 구현에 집중했었다. 특별한 제약이 있지 않았다. 하지만 지금의 환경에는 다양한 제약사항들 있다. 제약이 많은 환경에서 훌륭하게 돌아가는 설계를 하는 것은 또 다른 도전이다. 비록 이 과정에서 동료분들의 많은 도움을 받았지만 스스로 얻은것도 정말 많았다.</p><h3 id="앞으로"><a href="#앞으로" class="headerlink" title="앞으로"></a>앞으로</h3><p>이곳에서는 내 노력 여하에 따라 많은 기회가 주어진다. 그것을 내 것으로 만들려면 준비가 되어있어야 한다. 여전히 영어, 개발실력, 업무 디테일이 부족하지만, 충분히 성장시킬 수 있고 반드시 그렇게 할 것이다. 그리고 기회를 잡을 것이다. 스스로 자신 있게 나를 믿고 조금씩, 꾸준히 진행해보자.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;18.12.03 이직 후 3개월이 지났다. 많은 생각을 하게 되는 의미 있는 기간이었다.&lt;/p&gt;
    
    </summary>
    
      <category term="article" scheme="https://jae-kwang.github.io/blog/categories/article/"/>
    
    
      <category term="article" scheme="https://jae-kwang.github.io/blog/tags/article/"/>
    
  </entry>
  
  <entry>
    <title>requestAnimationFrame() 개념 정리하기</title>
    <link href="https://jae-kwang.github.io/blog/2019/01/28/requestAnimationFrame/"/>
    <id>https://jae-kwang.github.io/blog/2019/01/28/requestAnimationFrame/</id>
    <published>2019-01-28T12:18:25.000Z</published>
    <updated>2019-01-28T13:32:55.269Z</updated>
    
    <content type="html"><![CDATA[<p>부드러운 인터렉션을 제공하기 위한 첫걸음.</p><a id="more"></a><p>사용자들이 서비스를 선택할 때에는 여러 가지 기준이 있습니다. 그중에 하나는 부드러운 인터렉션 입니다. 오늘날의 기기들은 그러한 시각적인 효과를 위해 초당 60번 화면을 다시 그립니다. 그러므로 우리는 이 60개의 화면(프레임) 안에서 시각적인 효과를 표현해야 합니다.<br><br></p><div class="figure center" style="width:;"><img class="fig-img" src="final-fps.gif" alt="출처 : https://dribbble.com/shots/1945400-FPS-frames-per-second"><span class="caption">출처 : https://dribbble.com/shots/1945400-FPS-frames-per-second</span></div><p>사용자들은 이 프레임 중에 하나라도 놓치면 그것을 쉽게 알아챕니다. 초당 60개의 프레임을 렌더링하려면 1개의 단일 프레임은 16ms(1,000ms/60frame)안에 수행해야 합니다. 즉, 초당 60개의 프레임을 부드러운 속도로 보여주기 위해서는 약 16ms 미만으로 프레임을 유지하는 것이 좋습니다.</p><hr><p>브라우저가 화면에 무언가를 그리기까지는 여러 단계가 존재합니다.<br><br><br><div class="figure center" style="width:;"><img class="fig-img" src="frame-full.jpg" alt="출처 : https://developers.google.com/web/fundamentals/performance/rendering/?hl=ko"><span class="caption">출처 : https://developers.google.com/web/fundamentals/performance/rendering/?hl=ko</span></div></p><p>애니메이션 및 기타 작업들을 수행하는 <span class="highlight-text primary">Javascript</span>, CSS 규칙을 어떤 요소에 적용할지 계산하는 프로세스인 <span class="highlight-text primary">Style</span>, 브라우저가 요소에 어떤 규칙을 적용할지 알게 되면 화면에서 얼마의 공간을 차지하고 어디에 배치되는지 계산하는 프로세스인 <span class="highlight-text primary">Layout(reflow)</span>, 픽셀을 채우는 프로세스인 <span class="highlight-text primary">Paint(redraw)</span>, 이전의 작업들이 개별적인 레이어에서 진행되고 이를 합치는 프로세스인 <span class="highlight-text primary">Composite</span> 로 진행됩니다.</p><p>때에 따라 다르지만 기본적으로 한번에 그림을 그리기 위해서는 위와 같은 랜더링 파이프라인을 호출하게 됩니다. 우리는 흔히 애니메이션을 수행하기 위해 setTimeout() 또는 setInterval()을 사용합니다. 하지만 이와 같은 함수들은 주어진 시간내에 동작을 할 뿐 위에서 언급한 프레임을 전혀 고려하지 않습니다.<br><br><br><div class="figure center" style="width:;"><img class="fig-img" src="settimeout.jpeg" alt="출처 : https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution?hl=ko"><span class="caption">출처 : https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution?hl=ko</span></div></p><p>그래서 종종 프레임이 누락되고 사용자게 버벅거리는 인터렉션을 제공할 수 있습니다.</p><h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame()"></a>requestAnimationFrame()</h2><p>화면에서 변화가 발생할 때 개발자는 브라우저에서 정확한 시간(프레임 시작 시)에 작업을 수행해야 매끄러운 움직임을 수행할 수 있습니다.</p><p>이 메소드는 실제 화면이 갱신되어 표시되는 주기에 따라 함수를 호출해주기 때문에 자바스크립트가 프레임 시작 시 실행되도록 보장합니다.</p><p>보통 1초에 60회 정도 실행이 되지만 대부분의 브라우저는 W3C 권장사항에 따라 디스플레이 주사율과 일치하도록 실행됩니다.</p><p>setTimeout(), setInterval()은 보이지 않은 곳에서도 수행되지만, requestAnimationFrame()는 현재 창에 표시 되지 않으면 애니메이션을 중지하여 배터리 수명과 성능향상에 도움이 됩니다</p><p>즉, requestAnimationFrame()을 사용하면 브라우저가 리소스 사용을 더욱 최적화하고 애니메이션을 더욱 부드럽게 만들 수 있습니다.</p><blockquote><p>참고 :<br><a href="https://flaviocopes.com/requestanimationframe/" target="_blank" rel="noopener">REQUEST ANIMATION FRAME</a><br><a href="https://developer.mozilla.org/ko/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">MDN - window.requestAnimationFrame()</a><br><a href="https://classroom.udacity.com/courses/ud860" target="_blank" rel="noopener">udacity</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;부드러운 인터렉션을 제공하기 위한 첫걸음.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="animation" scheme="https://jae-kwang.github.io/blog/categories/js/animation/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="window" scheme="https://jae-kwang.github.io/blog/tags/window/"/>
    
  </entry>
  
  <entry>
    <title>MVC &amp; 옵저버 패턴 적용하기</title>
    <link href="https://jae-kwang.github.io/blog/2018/09/22/mvc_observer/"/>
    <id>https://jae-kwang.github.io/blog/2018/09/22/mvc_observer/</id>
    <published>2018-09-22T03:29:20.000Z</published>
    <updated>2019-01-28T13:33:56.496Z</updated>
    
    <content type="html"><![CDATA[<p>ES6를 활용하여 MVC 및 옵저버 패턴을 적용한 프로젝트를 진행하면서 느꼈던 작업과 과정을 정리했습니다.</p><a id="more"></a><h2 id="패턴의-필요성"><a href="#패턴의-필요성" class="headerlink" title="패턴의 필요성"></a>패턴의 필요성</h2><p>돌이켜보면 가장 난감한 경우는 의존성이 고려되지 않은 프로젝트를 였습니다. 의존성이 고려되지 않고 작업 된 프로젝트는 유지보수에 많은 시간이 필요했습니다.</p><p>이에 못지않게 또 한 가지 어러운 일 중의 하나는 바로 데이터 변경에 따른 뷰 변경 작업이라고 생각합니다. 데이터가 많고 복잡할수록 뷰 또한 많은 변화가 있어 일일이 대응하기가 쉽지 않습니다.</p><p>그래서 이러한 문제들을 개선해보고자 MVC 및 옵저버 패턴을 도입해 해당 문제들을 개선한 프로젝트를 진행하기로 했습니다.</p><h2 id="구조-설계하기"><a href="#구조-설계하기" class="headerlink" title="구조 설계하기"></a>구조 설계하기</h2><p>MVC 패턴은 담당하려는 역할별로 나누어서 각각에 대한 의존성을 낮출 수 있는 패턴입니다. 우선 패턴에 대한 학습 및 래펀런스로 아래 자료에서 도움을 많이 받았습니다.</p><blockquote><p><a href="https://www.youtube.com/watch?v=LJhkPP0E6dw" target="_blank" rel="noopener">코드스피츠75 - ES6+ 디자인패턴과 뷰패턴 #5</a></p></blockquote><h3 id="Model의-역할"><a href="#Model의-역할" class="headerlink" title="Model의 역할"></a>Model의 역할</h3><p>해당 기능에서 사용되는 데이터에 대한 참조는 모두 Model에서 담당합니다. Model은 다른 것들과 다르게 의존성이 전혀 존재하지 않는 독립적인 개체입니다. </p><h3 id="View의-역할"><a href="#View의-역할" class="headerlink" title="View의 역할"></a>View의 역할</h3><p>View는 Model 기반으로 렌더링할 DOM을 구축하는 역할을 맡습니다. 추가로 View에서 조금 더 복잡한 요구될 경우 하위에 <code>Template</code>을 두어서 복잡도를 낮추도록 하였습니다. DOM이 있기 때문에 직접 이벤트를 바인딩하는 부분도 포함됩니다.</p><h3 id="Controller의-역할"><a href="#Controller의-역할" class="headerlink" title="Controller의 역할"></a>Controller의 역할</h3><p>Controller는 View와 Model들에 접근하여 앱을 이어주는 단일 컨트롤러로 두었습니다. 초기 세팅, 기능 간의 로직 처리, View에 바인딩 될 이벤트 핸들러를 관리합니다.</p><h2 id="싱글톤-처리"><a href="#싱글톤-처리" class="headerlink" title="싱글톤 처리"></a>싱글톤 처리</h2><p>MVC 패턴에서 객체를 여러 개로 만드는 경우도 있고 하나만 만드는 경우도 있기 때문에 싱글톤 처리가 필요합니다. ES6에서 제공되는 코어객체 <code>WeackMap</code>를 사용해 싱글톤 객체를 생성합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// err = (v = 'invalid') =&gt; &#123; throw v &#125;</span></span><br><span class="line"><span class="keyword">const</span> Singleton = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WeakMap</span> </span>&#123;</span><br><span class="line">  has () &#123; err() &#125;</span><br><span class="line">  get () &#123; err() &#125;</span><br><span class="line">  set () &#123; err() &#125;</span><br><span class="line">  getInstance (v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">super</span>.has(v.constructor)) <span class="keyword">super</span>.set(v.constructor, v)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.get(v.constructor)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WeackMap</code>은 객체를 키로 해서 값을 가질 수 있습니다. <code>WeackMap</code>에서 제공되는 has, get, set의 직접 사용을 막아서 <code>WeackMap</code>처럼 사용될 수 없게 합니다. getInstance()를 통해 키로 넘어온 객체의 생성자를 기준으로 사용하여 클래스당 인스턴스가 한 개씩 생성되도록 합니다.</p><p>Singleton 객체를 활용해서 Model, View, Controller의 에서 getInstance()를 활용해 싱글톤 객체를 얻을 수 있도록 합니다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleton = <span class="keyword">new</span> Singleton()</span><br><span class="line"> <span class="keyword">const</span> Controller = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (isSingleton) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSingleton) <span class="keyword">return</span> singleton.getInstance(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  listen (model) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 부분까지는 참고한 자료를 기반으로 적용할 수 있었습니다. 하지만 제가 작업하는 환경에서는 아래와 같은 에러가 발생하며 babel로 컴파일된 코드에는 동작하지 않았습니다.</p><div class="alert danger"><p>Uncaught TypeError: Constructor WeakMap requires ‘new’</p></div><p>그래서 답을 찾다가 다음과 같이 설정 파일을 변경하였는데 정상적으로 동작했습니다. 서버로 사용하고 중인 node 버전을 targets으로 설정하면 에러가 발생하지 않았습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, &#123;</span><br><span class="line">      <span class="attr">"targets"</span>: &#123;</span><br><span class="line">        <span class="attr">"node"</span>: <span class="string">"8.11"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 새로 추가한 코드 때문에 전체 코드가 관장되는 설정 파일을 수정할 수가 없었기에 다시 원래 설정으로 돌렸습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: ['env']</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그래서 newWeakMap을 new로 생성한 인스턴스를 사용할 수 있는 클래스를 새로 만들어 사용하는 식으로 수정하였습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newWeakMap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (init) &#123;</span><br><span class="line">    <span class="keyword">this</span>._wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(init)</span><br><span class="line">  &#125;</span><br><span class="line">  has (v) &#123; <span class="keyword">return</span> <span class="keyword">this</span>._wm.has(v) &#125;</span><br><span class="line">  get (v) &#123; <span class="keyword">return</span> <span class="keyword">this</span>._wm.get(v) &#125;</span><br><span class="line">  set (k, v) &#123;</span><br><span class="line">    <span class="keyword">this</span>._wm.set(k, v)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Singleton = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">newWeakMap</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>덕분에 설정 파일 변경 없이 싱글톤 객체를 사용할 수 있었습니다.</p><h2 id="Model에-옵저버-패턴-적용"><a href="#Model에-옵저버-패턴-적용" class="headerlink" title="Model에 옵저버 패턴 적용"></a>Model에 옵저버 패턴 적용</h2><p>옵저버 패턴을 지원하기 위해 모델에서는 ES6의 <code>Set</code>을 상속받아서 사용했습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// is = (t, p) =&gt; t instanceof p</span></span><br><span class="line"><span class="comment">// err = (v = 'invalid') =&gt; &#123; throw v &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Model = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Set</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (isSingleton) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">if</span> (isSingleton) <span class="keyword">return</span> singleton.getInstance(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  add () &#123; err() &#125;</span><br><span class="line">  <span class="keyword">delete</span> () &#123; err() &#125;</span><br><span class="line">  has () &#123; err() &#125;</span><br><span class="line">  registerCtrl (v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!is(v, Controller)) err()</span><br><span class="line">    <span class="keyword">super</span>.add(v)</span><br><span class="line">  &#125;</span><br><span class="line">  unregisterCtrl (v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!is(v, Controller)) err()</span><br><span class="line">    <span class="keyword">super</span>.delete(v)</span><br><span class="line">  &#125;</span><br><span class="line">  notify (data) &#123;</span><br><span class="line">    <span class="keyword">this</span>._s.forEach(<span class="function"><span class="params">v</span> =&gt;</span> v.listen(<span class="keyword">this</span>, data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Set</code>과 배열의 차이점은 중복검사를 할 필요가 없다는 점입니다. <code>Set</code>은 들어오는 값에 대하여 중복 값은 무시합니다.</p><p>기본적인 옵저버 패턴을 위해 Controller를 Set에 추가, 삭제하고 notify 할 수 있는 기능을 추가합니다.</p><p><code>WeakMap</code>과 마찬가지로 같은 문제가 발생해서 새로운 ‘Set’을 생성하여 문제를 해결합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newSet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (init) &#123;</span><br><span class="line">    <span class="keyword">this</span>._s = <span class="keyword">new</span> <span class="built_in">Set</span>(init)</span><br><span class="line">  &#125;</span><br><span class="line">  add (v) &#123; <span class="keyword">this</span>._s.add(v) &#125;</span><br><span class="line">  <span class="keyword">delete</span> (v) &#123; <span class="keyword">this</span>._s.delete(v) &#125;</span><br><span class="line">  has (v) &#123; <span class="keyword">return</span> <span class="keyword">this</span>._s.has(v) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Model = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">newSet</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="View에-render-구현"><a href="#View에-render-구현" class="headerlink" title="View에 render 구현"></a>View에 render 구현</h2><p>view는 렌더링을 담당하는 역할로 그 기능은 render 함수가 수행합니다.</p><p>주입받은 model과 해당 view를 렌더링할 위치를 주입받아 해당 위치에 DOM을 추가합니다.</p><p>controller에는 이벤트 핸들러가 있어서 필요한 DOM에 이벤트를 바인딩하여 사용합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">view</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (controller, isSingleton) &#123;</span><br><span class="line">    <span class="keyword">super</span>(controller, isSingleton)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render (model = err(), $selector) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!is(model, myModel)) err()</span><br><span class="line">    <span class="keyword">const</span> &#123;<span class="attr">_controller</span>: ctrl&#125; = <span class="keyword">this</span></span><br><span class="line">    $selector.innnerHTML(myTemlate(model))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Controller-구현"><a href="#Controller-구현" class="headerlink" title="Controller 구현"></a>Controller 구현</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">controller</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  $list () &#123;</span><br><span class="line">    <span class="keyword">const</span> view = <span class="keyword">new</span> ListView(<span class="keyword">this</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">const</span> model = <span class="keyword">new</span> ListModel(<span class="literal">true</span>)</span><br><span class="line">    view.render(model, <span class="built_in">document</span>.getElementById(<span class="string">'#list'</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  listen (model) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> is(model, listModel): <span class="keyword">return</span> <span class="keyword">this</span>.$list()</span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컨트롤러에는 notify에 대응하는 Listen 함수를 생성하였고, 그 안에는 맞는 모델에 맞게 다시 view를 그릴 수 있도록 설정합니다.</p><p>그리고 controller에는 이벤트 핸들러 및 서비스 로직이 추가됩니다.</p><h2 id="알게된-점"><a href="#알게된-점" class="headerlink" title="알게된 점"></a>알게된 점</h2><p>많은 부분이 패턴을 적용하기 이전보다 편리한 점이 있었습니다. 역할별로 기능들을 나눈 덕분에 코드가 더 명확하고 심플해 졌다는 것을 느낄 수 있었습니다. 또한, 옵저버 패턴을 활용해서 Model 변경으로 View를 렌더링하면서 세세한 View 컨트롤이 없어서 너무나 편리했습니다.</p><p>하지만 마냥 좋은 점만 있던 건 아니었습니다. 모든 작업이 그렇듯이 예외적인 케이스들이 있어서 그런 예외 대응하면서 패턴이라는 구조에 맞게 작업을 하는 건 쉽지가 않았습니다.</p><p>제가 머릿속에 처음 구상된 MVC는 아래와 같은 형태였습니다.<br><div class="figure center" style="width:;"><img class="fig-img" src="https://velopert.com/wp-content/uploads/2016/04/MVC.png" alt="출처 : https://velopert.com/1225"><span class="caption">출처 : https://velopert.com/1225</span></div></p><p>하지만 단일 컨트롤러에서 여러 모델과 뷰를 관리하고 그것들이 서로서로를 참조하여 모델을 변경하는 부분에서는 아래와 그림과 같은 상황이었습니다.<br><div class="figure center" style="width:;"><img class="fig-img" src="https://velopert.com/wp-content/uploads/2016/04/MVC2.png" alt="출처 : https://velopert.com/1225"><span class="caption">출처 : https://velopert.com/1225</span></div></p><p>제가 진행한 프로젝트 Model과 View의 쌍이 6개였는데 만약 더 큰 규모의 프로젝트였으면 이러한 문제에 대하여 충분히 대응이 없다면 그 프로젝트도 결과 유지보수가 쉬운 코드가 될 수는 없다는 생각이 들었습니다.</p><p>이번 프로젝트를 통해 패턴에 대한 장점을 익히게 되어서 좋았지만, React와 View 같은 UI 라이브러리들이 얼마나 잘 만들어지고 편리한지 또한 알게 되었던 것 같습니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6를 활용하여 MVC 및 옵저버 패턴을 적용한 프로젝트를 진행하면서 느꼈던 작업과 과정을 정리했습니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="pattern" scheme="https://jae-kwang.github.io/blog/categories/js/pattern/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="mvc" scheme="https://jae-kwang.github.io/blog/tags/mvc/"/>
    
      <category term="project" scheme="https://jae-kwang.github.io/blog/tags/project/"/>
    
  </entry>
  
  <entry>
    <title>더 멋져진 리엑트 프로젝트</title>
    <link href="https://jae-kwang.github.io/blog/2018/07/19/project-react-2nd/"/>
    <id>https://jae-kwang.github.io/blog/2018/07/19/project-react-2nd/</id>
    <published>2018-07-19T00:07:12.000Z</published>
    <updated>2018-12-24T05:03:31.225Z</updated>
    
    <content type="html"><![CDATA[<p>올 초에 작업했던 리엑트 프로젝트를 조금 더 개선하기 위해 수행했던 여러 작업에 대해 간단히 정리해보았습니다.</p><a id="more"></a><h1 id="리엑트-프로젝트를-조금-더-멋지게-만들자"><a href="#리엑트-프로젝트를-조금-더-멋지게-만들자" class="headerlink" title="리엑트 프로젝트를 조금 더 멋지게 만들자!"></a>리엑트 프로젝트를 조금 더 멋지게 만들자!</h1><p>기존 프로젝트에서 아쉬웠던 부분과 새롭게 추가해보고 싶은 것들을 정리했습니다.<br><br></p><ul><li>빌드 프로세스 개선</li><li>Router 적용</li><li>react v15 -&gt; v16 (ContextAPI 활용)</li><li>typescript 적용</li></ul><p>너무 많은 목표를 두는 게 아닌가 생각은 했지만, 목표들이 어느 정도 포함관계가 있어서 지금 해두는 게 이후에 적용하는 것보다 덜 복잡할 것 같다는 생각을 해서 이번 기회에 추진하기로 했습니다.</p><h2 id="빌드-프로세스-개선"><a href="#빌드-프로세스-개선" class="headerlink" title="빌드 프로세스 개선"></a>빌드 프로세스 개선</h2><p>올 초에 프로젝트를 진행하면서 리엑트로 프로젝트를 변경하는 것을 중점으로 작업하다 보니 그 이외에 부분을 신경 쓰지 못했습니다. 그중에 한 부분은 바로 빌드 프로세스입니다.</p><h4 id="리비전-추가"><a href="#리비전-추가" class="headerlink" title="리비전 추가"></a>리비전 추가</h4><p>기존에는 번들 파일이 <code>bundle.js</code>와 같은 형태로 생성되었습니다. 이러한 형태는 파일이 수정되어도 브라우저는 알지 못할 수 있습니다. 브라우저는 기본적으로 리소스를 브라우저캐시에 두고 파일 이름의 차이로 인해 변경사항을 파악합니다. 그래서 아래처럼 작성하여 브라우저 캐시를 갱신합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  output: [name].[chunkhash].js,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].[contenthash].css'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 이렇게 번들링된 파일은 파일 변경 시 매번 hash 값이 달라지니 파일 이름도 같이 달라져서 HTML에 sciprt를 추가할 수가 없습니다. 번들링 된 파일 이름을 알아내기 위해 webpack에 <a href="https://www.npmjs.com/package/webpack-manifest-plugin" target="_blank" rel="noopener">webpack-manifest-plugin</a> 을 적용했습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ManifestPlugin(&#123;</span><br><span class="line">  fileName: <span class="string">`<span class="subst">$&#123;path&#125;</span>/manifest.json`</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>빌드를 통해 나온 <code>manifest.json</code> 파일을 통해 번들링된 파일 이름을 얻을 수 있고 리소스를 HTML에 추가할 수 있었습니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bundle.js"</span>: <span class="string">"bundle.ac8a6e5e050f1befb5e4.js"</span>,</span><br><span class="line">  <span class="attr">"bundle.css"</span>: <span class="string">"bundle.b0cd9b716fef2bc73a57dcbd83cfefb0.css"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="공통모듈-분리"><a href="#공통모듈-분리" class="headerlink" title="공통모듈 분리"></a>공통모듈 분리</h4><p>웹팩의 설정파일은 <code>webpack.config.dev.js</code>, <code>webpack.config.prod.js</code> 와 같이 나누어져 있었습니다. 여러 설정이 추가되면서 설정파일이 커지면서 공통된 부분을 별도로 나누는 것이 좋다고 생각했습니다. </p><p>공통 부분은 <code>webpack.common.js</code>를 생성해서 공통모듈을 생성하였습니다. 해당 파일로 분리된 설정파일을 각각 하나의 <code>dev</code>와 <code>prod</code> 병합할 때는 <a href="https://github.com/survivejs/webpack-merge" target="_blank" rel="noopener">webpack-merge</a>을 사용했습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> common = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>)</span><br><span class="line"><span class="keyword">const</span> ssr = <span class="built_in">require</span>(<span class="string">'SSR_render.jg'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = merge(common, &#123; ... &#125;)</span><br></pre></td></tr></table></figure><hr><h2 id="Router-적용"><a href="#Router-적용" class="headerlink" title="Router 적용"></a>Router 적용</h2><p>기존에는 단일페이지라서 별도로 router를 세팅할 필요가 없지만, 새롭게 추가될 페이지를 위해 <a href="https://reacttraining.com/react-router/" target="_blank" rel="noopener">react-route</a>를 적용하기로 하였습니다. </p><p>해당 프로젝트는 앞서 언급했던 것처럼 SSR이 지원되어야 했습니다. 그러므로 리엑트에서 적용했던 <code>ReactDOM.render</code> 과 <code>ReactDOMServer.renderToString</code>처럼 SSR과 CSR을 위한 다른 Wrapper 메서드가 필요했는데 역시나 App을 Wrapping 하여 사용하는 <code>react-router</code> 도 그러한 메서드가 존재했습니다. CSR에는 <code>BrowserRouter</code> 를 사용하고, SSR에는 <code>StaticRouter</code>를 사용하였습니다.</p><p>App 내부에서는 <code>&lt;Switch/&gt;</code>로 감싼 <code>&lt;Route/&gt;</code> 들을 설정하였습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SSR</span></span><br><span class="line"><span class="keyword">import</span> &#123; StaticRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CSR</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br></pre></td></tr></table></figure><hr><h2 id="React-v16-적용"><a href="#React-v16-적용" class="headerlink" title="React v16 적용"></a>React v16 적용</h2><p>리엑트가 v16을 배포한 지 약 10개월 정도 지났는데, 이번 기회에 v16 중 필요한 기능들을 적용해 보았습니다.</p><h4 id="Context-API-도입"><a href="#Context-API-도입" class="headerlink" title="Context API 도입"></a>Context API 도입</h4><p>Context API는 주로 전역 데이터가 필요할 때 사용합니다. 이러한 기능은 제가 redux를 도입한 목적과 같아 충분히 교체 가능했습니다. </p><div class="figure center" style="width:;"><img class="fig-img" src="contextAPI.png" alt="출처 : https://blog.bitsrc.io/react-context-api-a-replacement-for-redux-6e20790492b3"><span class="caption">출처 : https://blog.bitsrc.io/react-context-api-a-replacement-for-redux-6e20790492b3</span></div><p>redux를 이해하고 적용하는데 많은 시간이 든다고 생각됩니다. 저도 필요한 부분은 적용하며 사용했지만, 모든 부분을 자세히 알고 있다고는 생각할 수 없습니다. 전역 데이터를 위해 사용했지만, redux의 사용이 좀 과하다는 생각이 남아있긴 했습니다.</p><p>Context API를 적용하기 위해 많은 정보를 찾았고, 그중 많은 부분을 <code>velopert</code>의 블로그에서 참고하여 작업을 진행하였습니다. 이유는 redux를 사용할 때도 store 내부에 크게 2개로 나누어 구분해서 사용했기 때문입니다. 그래서 Context API를 적용하려는 상황에서도 다중 context가 필요하다고 생각이 들었습니다. 이와 관련한 내용이 친절하게 설명이 되어 있었습니다.</p><blockquote><p><a href="https://velopert.com/3606" target="_blank" rel="noopener">리액트 16.3 에 소개된 새로워진 Context API 파헤치기</a></p></blockquote><p>하지만 모든 부분을 이전과 같은 컴포넌트 구조로 교체하지 못했습니다. 하나의 컴포넌트에서 여러 context가 필요한 경우였습니다. redux에는 store가 하나였기에 이런 부분에는 문제가 없었습니다. Context API를 활용하는 컴포넌트를 Hoc 형태로 만들었기에 하나의 컴포넌트에 2개 이상의 context를 주입받아야 할 때 컴포넌트를 겹겹이 감싸는 형태는 좋아 보이지 않았습니다.</p><p>그래서 이러한 경우가 발생한 컴포넌트들은 다시 context 기준으로 컴포넌트를 분리하였습니다. context 기준으로 새롭게 컴포넌트를 생성하다 보니 이전보다 더 명확한 목표를 가진 컴포넌트가 자연스럽게 생성된 결과를 볼 수 있었습니다.</p><p>작업하면서 “이 데이터가 이 context에 들어가는 게 맞나?”라는 고민을 참 많이 했던 것 같습니다. 구현 전에 데이터 모델링이 중요하다는 사실을 다시 한 번 느꼈습니다. 하지만 설계단계가 아닌 개발 중간마다 이러한 경우를 맞이하는 것이 아직은 더 많은 공부가 필요한 것을 상기시켜 주는 것 같습니다.</p><h4 id="redux-from에서-formik로-변경"><a href="#redux-from에서-formik로-변경" class="headerlink" title="redux-from에서 formik로 변경"></a>redux-from에서 formik로 변경</h4><p>redux를 제거하게 되면서, redux관련 모듈인 react-redux, redux-thunk, redux-form 들을 제거할 수 있었습니다. 그 중 redux-form은 다른 모듈로 대체되어야 했는데 그 역할은 <code>formik</code>였습니다. 사용이 간편하고 필요한 기능들을 충족했기 때문이었습니다.</p><div class="figure center" style="width:;"><img class="fig-img" src="form.png" alt=""></div><p>사실 submit action이나 validation은 작업의 편의성을 위해 라이브러리를 주로 사용합니다. 하지만 단순히 값을 체크하는걸 넘어서 자동으로 다른 폼의 값을 채우거나, 비동기로 값을 체크하거나, 특정 액션에 다른 view에 영향을 미치는 등 예외의 경우를 조작하는 것은 간단하지만은 않았습니다.</p><p>이럴 거면 그냥 라이브러리 사용하지 않고 처음부터 만들 걸 그랬나 생각도 들었지만, 기본기능들을 그냥 새로 만드는 건 비효율적일 것 같지 않아 끈기있게 붙들고 적용하였습니다.<br><br></p><div class="figure center" style="width:;"><img class="fig-img" src="movie_image.jpg" alt=""></div><p>redux의 의존하지 않는다는 점에서 충분히 작업의미가 있었습니다. 처음엔 <code>redux-form</code>과 <code>formik</code>가 많이 다르다고 생각했지만, 결과적으로 바뀐 코드를 보면 역시 프론트엔드의 컴포넌트 형태의 개발은 크게 다르지 않다는 점을 알 수 있었습니다. </p><blockquote><p><a href="https://redux-form.com/7.4.2/" target="_blank" rel="noopener">redux-form</a></p><p><a href="https://github.com/jaredpalmer/formik" target="_blank" rel="noopener">formik</a></p></blockquote><h4 id="ReactDOM-hydrate"><a href="#ReactDOM-hydrate" class="headerlink" title="ReactDOM.hydrate()"></a>ReactDOM.hydrate()</h4><p>v16을 적용하면 <code>ReactDOM.render()</code>를 <code>ReactDOM.hydrate()</code> 로 변경하라는 경고를 볼 수 있습니다. 이건 v16에서 나온 새로운 렌더링 메서드이며 <code>ReactDOM.render()</code> 은 v17에서는 사용되지 않을 예정이라고 합니다. </p><p><code>ReactDOM.hydrate()</code> SSR을 지원하는 앱에서 서버 렌더링 된 마크업이 있는 노드에서 호출하면 리엑트는 이벤트 핸들러만 연결해서 성능을 시켜준다고 합니다.</p><blockquote><p><a href="https://stackoverflow.com/questions/46516395/whats-the-difference-between-hydrate-and-render-in-react-16" target="_blank" rel="noopener">What’s the difference between hydrate() and render() in React 16?</a></p></blockquote><hr><h2 id="타입스크립트를-적용하는-이유"><a href="#타입스크립트를-적용하는-이유" class="headerlink" title="타입스크립트를 적용하는 이유"></a>타입스크립트를 적용하는 이유</h2><p>복잡한 데이터 구조는 버그를 발생시키는데 한몫합니다. 여러 프로젝트를 하면서 가장 많은 버그를 생성한 곳 역시 복잡한 데이터를 주고받는 부분이었습니다. 이러한 부분에 도움을 받을 만한 것이 바로 <code>타입스크립트(typescript)</code>라고 생각을 했고 적용해보기로 했습니다. 규모가 작은 프로젝트에는 오버엔지니어링이라고 생각될 수 있지만, 이번 기회에 타입스크립트를 적용해보면서 느낀 점도 있어서 결과적으로 “적용해보길 잘했다.”라는 생각을 했습니다.</p><h4 id="타입스크립트-로더-설정"><a href="#타입스크립트-로더-설정" class="headerlink" title="타입스크립트 로더 설정"></a>타입스크립트 로더 설정</h4><p>공식페이지 <a href="https://www.typescriptlang.org/docs/handbook/react-&amp;-webpack.html" target="_blank" rel="noopener">React &amp; Webpack</a>에 언급된 <a href="https://github.com/s-panferov/awesome-typescript-loader" target="_blank" rel="noopener">awesome-typescript-loader</a>를 사용하기로 했습니다. 해당 loader를 설치한 후에 ‘webpack.config.js’ 설정했습니다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">loader: <span class="string">'awesome-typescript-loader'</span>,</span><br><span class="line">exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>타입스크립트를 설정한 파일의 확장자가 <code>.tsx</code> 인 것을 확인했고, 그 파일에만 타입스크립트가 적용되기 때문에 <code>.jsx</code> 파일을 하나씩 <code>.tsx</code> 로 변경하면서 기능을 확인한 후 넘어가는 식으로 변경 작업을 진행했습니다.</p><h4 id="리엑트-with-타입스크립트"><a href="#리엑트-with-타입스크립트" class="headerlink" title="리엑트 with 타입스크립트"></a>리엑트 with 타입스크립트</h4><p>타입스크립트에서는 타입을 선언하는 방식이 많은데 저는 주로 가장 간단한 <code>interface</code> 키워드를 사용하여 타입을 생성했습니다. 우선 선언한 타입을 기준으로 리엑트 컴포넌트를 생성하는 방법입니다.<br><br></p><ul><li>함수기반 컴포넌트(React Stateless Functional Component with TypeScript)</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> customComponent: React.SFC&lt;Props&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;<span class="regexp">/h1&gt;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>클래스기반 컴포넌트(React StateFul Class Component with TypeScript)</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> State &#123;</span><br><span class="line">    state: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> customCompnent <span class="keyword">extends</span> React.Component&lt;Props, State&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>공통된 구조의 타입은 interface를 extends로 상속하여 사용했습니다. 사실 컴포넌트 간의 구조를 생각하면서 하기도 쉽지 않은데 interface 간에 구조도 생각하려니 머리가 아팠습니다. 그러나 결과만 놓고 보면 기본적은 Props의 타입 검사는 만족했으며, 컴포넌트에서 어떠한 구조의 Props를 사용하고 있다는 것을 더욱 가시적으로 확인할 수 있다는 점이 정말 좋았습니다.</p><p>하지만 좋은 점만 있는 게 아니었습니다. 1의 일에 1.5배를 추가로 시간을 투자해야 했습니다. 게다가 강하게 타입체크를 하다 보니 쉬이 넘길 수 있는 부분에 추가로 코드가 들어가야 하는 걸 보면 답답함을 느끼곤 했습니다. 하지만 이런 부분은 기존 작업방식에서 빈틈이었던 부분이니 보완해야 할 부분이 맞아 보였습니다.</p><hr><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>여러 목표를 갖고 개선 프로젝트를 했는데도, 새로운걸. 적용하고 알게 되면서 또 다른 새로운 게 보이고 더 나은 방법이 보이는 건 어쩔 수 없는 것 같습니다. 하지만 이러한 경험 덕분에 다른 것들을 적용해볼 수 있는 환경 및 정보들을 얻었으니 좋은 시도였다고 생각이 듭니다. 다음 개선에는 또 다른 걸 시도해 보고 싶은데 그중에서 하나는 렌더링 성능 관련인데 충분히 더 알아보고 도전해봐야겠습니다. 읽어 주셔서 감사합니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;올 초에 작업했던 리엑트 프로젝트를 조금 더 개선하기 위해 수행했던 여러 작업에 대해 간단히 정리해보았습니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/categories/js/react/"/>
    
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/tags/react/"/>
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="project" scheme="https://jae-kwang.github.io/blog/tags/project/"/>
    
      <category term="contextAPI" scheme="https://jae-kwang.github.io/blog/tags/contextAPI/"/>
    
      <category term="react-router" scheme="https://jae-kwang.github.io/blog/tags/react-router/"/>
    
      <category term="webpack" scheme="https://jae-kwang.github.io/blog/tags/webpack/"/>
    
      <category term="typescript" scheme="https://jae-kwang.github.io/blog/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Iteration &amp; Generator</title>
    <link href="https://jae-kwang.github.io/blog/2018/05/01/iteration_generator/"/>
    <id>https://jae-kwang.github.io/blog/2018/05/01/iteration_generator/</id>
    <published>2018-05-01T07:57:22.000Z</published>
    <updated>2018-12-24T05:03:31.219Z</updated>
    
    <content type="html"><![CDATA[<p>ES6의 Iteration &amp; Generator에 대하여 알아봅니다.</p><a id="more"></a><p>우선, Iteration &amp; Generator를 알아보기에 앞서 Interface에서 대하여 알아보도록 하겠습니다.</p><h4 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h4><p>우선, Javascript에서의 Interface는 고유명사입니다.<br>다른 언어에서 말하는 Interface와는 아무 상관이 없습니다.</p><p><strong>ES6에서의 Interface의 정의</strong></p><ol><li>Interface란 사양에 맞는 값과 연결된 속성키의 세트.</li><li>어떤 Object라도 Interface의 정의를 충족시킬 수 있다.</li><li>하나의 Object는 여러 개의 Interface를 충족시킬 수 있다.</li></ol><blockquote><p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-iteration" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/6.0/#sec-iteration</a></p></blockquote><p>예를 들어 Interface ‘TEST’를 만들어 보겠습니다.</p><p><strong>Interface ‘TEST’의 요구 사항</strong></p><ol><li>‘test’라는 키를 가진다.</li><li>‘test’에는 함수가 있으며, 문자열 인자를 한 개 받고, Boolean 값을 반환한다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="comment">// TEST'Interface 를 만족하는 object의 형태</span></span><br><span class="line">  test(str) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class를 활용한 정의에서도 Interface를 만족하게 하면,</span></span><br><span class="line"><span class="comment">// 그 인스턴스들은 자동으로 원래의 Interface의 요구사항을 만족한다.</span></span><br><span class="line"><span class="keyword">const</span> Test = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  test(str) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> Test();</span><br></pre></td></tr></table></figure><p><strong>덕 타이핑(duck typing)</strong><br>class Test가 test Interface 조건만 만족한다면 test Interface의 구상체로 볼 수 있습니다.<br>덕 타이핑을 쓰는 이유는 런타임에는 컴파일타임의 타입체크가 되지 않기 때문입니다.<br>즉, Javascript에서 말하는 Interface는 덕 타이핑으로 구현을 약속한 프로토콜 같은 것이라고 볼 수 있습니다.</p><h4 id="Iterator-Interface"><a href="#Iterator-Interface" class="headerlink" title="Iterator Interface"></a>Iterator Interface</h4><p>Javascript 스펙에는 미리 규정된 Interface들이 있습니다.<br>그 중 Iterator Interface를 살펴보겠습니다.</p><p><strong>Iterator Interface의 요구 사항</strong></p><ol><li>next라는 키를 가진다.</li><li>next에는 함수가 있으며, 인자를 받지 않고 <code>iteratorResultObject</code>를 반환한다.</li><li><code>iteratorResultObject</code>는 <code>value</code>와 <code>done</code>이라는 키를 갖고 있다.(interface)</li><li>이중 <code>done</code>은 계속 반복할 수 있을지 없을지에 따라 Boolean 값을 반환한다.<br><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-iterator-interface" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/6.0/#sec-iterator-interface</a> </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterator = &#123; <span class="comment">// iterator Interface를 만족하는 object의 형태</span></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// Interface iteratorResultObject를 만족하는 object의 형태</span></span><br><span class="line">      done: <span class="literal">true</span>,</span><br><span class="line">      value: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터를 갖는 iterator 활용 예제 </span></span><br><span class="line"><span class="keyword">const</span> iterator = &#123;</span><br><span class="line">  data: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      done: <span class="keyword">this</span>.data.length === <span class="number">0</span>,</span><br><span class="line">      value: <span class="keyword">this</span>.data.pop()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator 수행 </span></span><br><span class="line"><span class="keyword">let</span> iResult = iterator.next()</span><br><span class="line"><span class="built_in">console</span>.log(iResult.value + <span class="string">':'</span> + iResult.done); <span class="comment">// 4:false</span></span><br><span class="line">iResult = iterator.next()</span><br><span class="line"><span class="built_in">console</span>.log(iResult.value + <span class="string">':'</span> + iResult.done); <span class="comment">// 3:false</span></span><br><span class="line">iResult = iterator.next()</span><br><span class="line"><span class="built_in">console</span>.log(iResult.value + <span class="string">':'</span> + iResult.done); <span class="comment">// 2:false</span></span><br><span class="line">iResult = iterator.next()</span><br><span class="line"><span class="built_in">console</span>.log(iResult.value + <span class="string">':'</span> + iResult.done); <span class="comment">// 1:false</span></span><br><span class="line">iResult = iterator.next()</span><br><span class="line"><span class="built_in">console</span>.log(iResult.value + <span class="string">':'</span> + iResult.done); <span class="comment">// undefined:true</span></span><br><span class="line"><span class="comment">// value가 없으면 undefined를 return하고 done은 true가 된다.</span></span><br></pre></td></tr></table></figure><p>이렇게 Iterator Interface을 적용하여 iterator object를 만들어 보았고,<br>반복수행을 해보았습니다. 다음은 Iterable Interface에 대하여 알아보겠습니다. </p><h4 id="Iterable-Interface"><a href="#Iterable-Interface" class="headerlink" title="Iterable Interface"></a>Iterable Interface</h4><p><strong>Iterable Interface의 요구 사항</strong></p><ol><li>Symbol.iterator라는 키를 갖는다.</li><li>Symbol.iterator에는 함수가 있으며, 인자를 받지 않고 iterator object를 반환한다. </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterable = &#123; <span class="comment">// iterable Interface를 만족하는 object의 형태</span></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">return</span> iterator; <span class="comment">// iterator object</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iterator는 한번 반복 후에는 수명을 다해서 없어집니다.<br>그래서 원본을 그대로 둔 상태에서 계속 반복 가능한 객체를 새롭게 얻기 위해 iterable을 사용합니다.</p><h4 id="Loop"><a href="#Loop" class="headerlink" title="Loop"></a>Loop</h4><p>ES6에서는 ES5에서 제공되는 기본 기능들에도 변화가 생겼습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line"> <span class="string">'0'</span>: <span class="number">3</span>,</span><br><span class="line">  a: <span class="number">5</span>,</span><br><span class="line">  [Symbole()]: <span class="number">7</span>,</span><br><span class="line">  b: <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5으로 for .. in은 순서보장이 지원되지 않았는데,<br>ES6에서는 숫자, 알파벳, 심볼로 순서로 정렬되서 결과를 나옵니다.(생성은 순서대로 진행된다.)</p><h4 id="while-문으로-살펴보는-iterator"><a href="#while-문으로-살펴보는-iterator" class="headerlink" title="while 문으로 살펴보는 iterator"></a>while 문으로 살펴보는 iterator</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">while</span>(arr.length &gt; <span class="number">0</span>) &#123; <span class="comment">// 계속 반복할지 판단</span></span><br><span class="line">  <span class="built_in">console</span>.log(arr.pop()); <span class="comment">//반복시 마다 처리할 것</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = &#123;</span><br><span class="line">  data: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      done: <span class="keyword">this</span>.data.length === <span class="number">0</span>, <span class="comment">// 계속 반복할지 판단</span></span><br><span class="line">      value: <span class="keyword">this</span>.data.pop() <span class="comment">// 반복시 마다 처리할 것</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>while문과 iterator객체가 매우 유사하다는 사실을 알 수 있습니다. </p><p>차이점으로는 while은 loop를 ‘문’으로 돌아서 제어가 불가능 하지만 iterator는 ‘값’으로 돌기 때문에 제어할 수 있습니다. 또한 next() 함수로 실행하기 때문에 지연실행이 가능합니다.</p><p>또한 while은 반복을 엔진이 해주지만 iterator는 외부에 실행기를 두어야 합니다.</p><p>즉, <strong>iterator object</strong>는 반복 자체를 하지는 않지만, 외부에서 반복하려고 할 때 반복에 필요한 조건과 실행을 미리 준비해둔 <strong>객체</strong> 입니다.</p><p>이를 통해 반복행위와 반복을 위한 준비를 분리했다고 볼 수 있습니다.</p><h4 id="ES6-Loop"><a href="#ES6-Loop" class="headerlink" title="ES6+ Loop"></a>ES6+ Loop</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 사용자 반복처리기 (직접 Iterator 반복 처리기를 구현)</span></span><br><span class="line"><span class="keyword">const</span> loop = <span class="function">(<span class="params">iter, f</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// iterable이라면 iterator를 얻음</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> iter[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span>) &#123;</span><br><span class="line">    iter = iter[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// iteratorObject가 아니라면 건너뜀</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> iter.next != <span class="string">'function'</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> = v = iter.next();</span><br><span class="line">    <span class="keyword">if</span> (v.done) <span class="keyword">return</span>; <span class="comment">// 종료 처리</span></span><br><span class="line">    f(v.value) <span class="comment">// 현재 값을 전달</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterable이자, iterator인 객체</span></span><br><span class="line"><span class="keyword">const</span> iter = &#123;</span><br><span class="line">  [Symbole.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>&#125;</span><br><span class="line">  data: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">      done: <span class="keyword">this</span>.data.length === <span class="number">0</span>,</span><br><span class="line">      value: <span class="keyword">this</span>.data.pop()</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">loop(iter, <span class="built_in">console</span>.log);</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>loop라는 반복기를 통해 iterator object를 순회합니다.</p><h4 id="destructuring-amp-amp-For-of"><a href="#destructuring-amp-amp-For-of" class="headerlink" title="destructuring &amp;&amp; For of"></a>destructuring &amp;&amp; For of</h4><h5 id="destructuring"><a href="#destructuring" class="headerlink" title="destructuring"></a>destructuring</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a,...b] = iter;</span><br><span class="line"><span class="built_in">console</span>.log(a, b);</span><br><span class="line"><span class="comment">//4, [3, 2, 1]</span></span><br></pre></td></tr></table></figure><p>실제로 destructuring은 배열을 해체하는 게 아니라 iterable을 해체하는 것입니다.<br>배열(문자열)을 넣었을 때도 destructuring이 정상작동하는 원리는 배열(문자열)에도 [Symbole.iterator]가 존재하다는 것을 알 수 있습니다.</p><p>이처럼 기본에 알고 있는 데이터의 구조도 ES5와는 차이가 있습니다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">""</span>[<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> [][<span class="built_in">Symbol</span>.iterator]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="For-of"><a href="#For-of" class="headerlink" title="For of"></a>For of</h5><p>새롭게 추가된 iterator를 소비하는 Loop로 기존 제어문이 소비하는 형태의 Loop 입니다.</p><h4 id="Iterator-Example"><a href="#Iterator-Example" class="headerlink" title="Iterator Example"></a>Iterator Example</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 제곱을 요소로 갖는 가상 컬렉션 </span></span><br><span class="line"><span class="keyword">const</span> N2 = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(max) &#123;</span><br><span class="line">    <span class="keyword">this</span>.max = max;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> cursor = <span class="number">0</span>, max = <span class="keyword">this</span>.max;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      done: <span class="literal">false</span>,</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (cursor &gt; max) &#123;</span><br><span class="line">          <span class="keyword">this</span>.done = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.value = cursor * cursor;</span><br><span class="line">          cursor++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...new N2(<span class="number">5</span>)]); <span class="comment">// [0, 1, 4, 9, 16]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> v <span class="keyword">of</span> <span class="keyword">new</span> N2(<span class="number">5</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>데이터 자체가 외부의 반복기에 의존하지 않고 원하는 조건에 의하여 데이터를 생성할 수 있게 되었습니다.</p><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p>Generator를 가장 쉽게 사용하는 예로는 iterator generator로써 사용하는 것입니다.<br>Iterator generator라는걸 풀어서 생각해보면 iterator 생성기라는 말인데,<br>위에서 같이 보신 것처럼 지금까지 iterator 생성기의 역할은 iterable이 하고 있었습니다. </p><div class="alert info"><p>iterator를 만든다는 입장에서 generator와 iterable은 같다고 볼 수 있다.</p></div><ul><li><p>Iterable이 iterator를 만드는 방식<br><code>Symbol.iterator</code>호출하는 것에 의해서 그 반환 값으로 호출 당할 때마다 iterator를 만들어 낸다.</p></li><li><p>Generator는 Generator를 호출할 때 마다 그 결과로 iterator를 만들어 낸다.</p></li></ul><p>그럼 실제로 우리는 iterable, iterator 인터페이스를 모두 알아야만 사용 가능할까요?<br>그건 너무 불친절한 일입니다. 그래서 그걸 몰라도 사용할 수 있는 문법적 장치가 바로 <code>generator</code>입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generator = <span class="function"><span class="keyword">function</span>*(<span class="params">max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cursor = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(cursor &lt; max) &#123;</span><br><span class="line">    <span class="keyword">yield</span> cursor * cursor; <span class="comment">// value</span></span><br><span class="line">    cursor ++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 1. return이 없지만 return하면 iterator 객체가 나온다.</span></span><br><span class="line"><span class="comment">// 2. 제어문을 멈출 수 있다.(지연 실행이 가능하다.)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...generator(<span class="number">5</span>)]) <span class="comment">// [0, 1, 4, 9, 16]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> v <span class="keyword">of</span> generator(<span class="number">5</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 16</span></span><br></pre></td></tr></table></figure><h4 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h4><p>iterable, iterator은 ES6에서 완전히 새로 나온 개념이라서 이해하기가 쉽지 않았습니다. 하지만 반면에 새로운 기능이라서 기존의 기능을 확장해서 알아야 할 필요는 없다는 생각으로 이해하려고 노력했습니다.</p><p>평소 프로그래밍을 하다 보면 당연하게 데이터를 반복하려면 당연히 반복기가 필요하고, 그 반복기로 순회를 할 때는 멈출 수 없다는 게 당연한 생각이었습니다.</p><p>그래서 ES6에서의 generator가 이를 개선해줄 거라고 나왔을 때도 반가워하며 찾아봤지만 이해하기가 쉽지 않았습니다. 하지만 이 기회에 interface를 기반으로 이해하려니까 더 잘 이해가 되는 것 같습니다.</p><p>ES6의 데이터가 ES5의 데이터와 다르게 iterator의 interface를 갖고 있다는 것만으로도 많은 이해가 됐습니다.</p><p>이제는 generator를 활용하며 익숙해져야겠습니다. :)</p><blockquote><p>출처 : <a href="https://www.youtube.com/watch?v=GhAkc00TvZs" target="_blank" rel="noopener">https://www.youtube.com/watch?v=GhAkc00TvZs</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6의 Iteration &amp;amp; Generator에 대하여 알아봅니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="ES6" scheme="https://jae-kwang.github.io/blog/categories/js/ES6/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="ES6" scheme="https://jae-kwang.github.io/blog/tags/ES6/"/>
    
      <category term="iteration" scheme="https://jae-kwang.github.io/blog/tags/iteration/"/>
    
      <category term="generator" scheme="https://jae-kwang.github.io/blog/tags/generator/"/>
    
  </entry>
  
  <entry>
    <title>객체 바르게 만들기</title>
    <link href="https://jae-kwang.github.io/blog/2018/03/01/making-objects-correct/"/>
    <id>https://jae-kwang.github.io/blog/2018/03/01/making-objects-correct/</id>
    <published>2018-03-01T05:27:00.000Z</published>
    <updated>2018-12-24T05:03:31.221Z</updated>
    
    <content type="html"><![CDATA[<p>프로젝트를 구조화하면서 객체의 생성방식은 매우 중요해집니다. 여러가지 객체생성 패턴을 살펴보고 제가 겪었던 문제를 간단히 정리해보았습니다.</p><a id="more"></a><p>객체 생성 패턴에 대한 간략한 정리이며, 하단부분에는 저의 생각을 작성했습니다. 읽는데 참고하시면 좋겠습니다. “자바스크립트 패턴과 테스트” 책을 참고하였습니다.</p><h3 id="1-모듈-패턴"><a href="#1-모듈-패턴" class="headerlink" title="1. 모듈 패턴"></a>1. 모듈 패턴</h3><p>모듈 패턴은 <code>데이터 감춤이 주목적인 함수</code>가 <code>모듈 API</code>를 이루는 <code>객체</code>를 반환하게 하는 구조이며, 두가지 기반의 모듈 생성 방식이 있습니다.</p><h4 id="1-1-임의-모듈-생성"><a href="#1-1-임의-모듈-생성" class="headerlink" title="1.1 임의 모듈 생성"></a>1.1 임의 모듈 생성</h4><figure class="codeblock codeblock--tabbed"><figcaption><span>임의 모듈 패턴 예시</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyApp = MyApp || {};</span><br><span class="line"></span><br><span class="line">MyApp.wildlifePreserveSimulator = <span class="function"><span class="keyword">function</span>(<span class="params">animalMaker</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> animals = []; <span class="comment">// 프라이빗 변수</span></span><br><span class="line">  <span class="keyword">return</span> { <span class="comment">// API 반환</span></span><br><span class="line">    addAnimals: <span class="function"><span class="keyword">function</span>(<span class="params">species, sex</span>) </span>{</span><br><span class="line">      animals.push(animalMaker.make(species, sex));</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">getAnimalCount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">      <span class="keyword">return</span> animals.legnth;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용</span></span><br><span class="line"><span class="keyword">var</span> perserve = MyApp.wildlifePreserveSimulator(realAnimalMaker);</span><br><span class="line">preserve.addAnimal(gorilla, female);</span><br></pre></td></tr></tbody></table></figure></div></figure><h4 id="1-2-즉시-실행-모듈-생성"><a href="#1-2-즉시-실행-모듈-생성" class="headerlink" title="1.2 즉시 실행 모듈 생성"></a>1.2 즉시 실행 모듈 생성</h4><p>API 반환하는건 임의 모듈과 같지만, 외부 함수를 선언하자마자 실행하는 방법입니다.<br>반환된 API는 이름공간을 가진 전역 변수에 할당된 후 해당 모듈의 싱글톤 인스턴스가 됩니다.</p><figure class="codeblock codeblock--tabbed"><figcaption><span>싱글톤 모듈</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyApp = MyApp || {};</span><br><span class="line"></span><br><span class="line">MyApp.wildlifePreserveSimulator = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> animals = [];</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="attr">addAnimals</span>: <span class="function"><span class="keyword">function</span>(<span class="params">animalMaker, species, sex</span>) </span>{</span><br><span class="line">      animals.push(animalMaker.make(species, sex));</span><br><span class="line">    },</span><br><span class="line">    <span class="attr">getAnimalCount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{</span><br><span class="line">      <span class="keyword">return</span> animals.legnth;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 사용</span></span><br><span class="line">MyApp.wildlifePreserveSimulator.addAnimal(realAnimalMaker, gorilla, female);</span><br></pre></td></tr></tbody></table></figure></div></figure><p>외부 함수는 애플리케이션 기동 코드의 실행과 상관없이 코드가 작성된 지점에서 즉시 실행되기 때문에 함수 (즉시) 실행시 의존성을 가져오지 못하며 외부 함수에 주입할 수 없습니다.</p><h3 id="2-new-객체-생성-패턴"><a href="#2-new-객체-생성-패턴" class="headerlink" title="2. new 객체 생성 패턴"></a>2. new 객체 생성 패턴</h3><figure class="codeblock codeblock--tabbed"><figcaption><span>Marsupial함수와 생성자 함수 사용법</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Marsupial</span>(<span class="params">name, nocturanl</span>) </span>{</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.isNocturnal = nocturanl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maverick = <span class="keyword">new</span> Marsupial(<span class="string">'매버릭'</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> slider = <span class="keyword">new</span> Marsupial(<span class="string">'슬라이더'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(maverick.isNocturnal); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(maverick.name);        <span class="comment">// '매버릭'</span></span><br><span class="line"><span class="built_in">console</span>.log(slider.isNocturnal);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(slider.name);          <span class="comment">// '슬라이더'</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>Marsupial함수는 주어진 인자를 내부적으로 생성할 인스턴스의 프로퍼티에 할당한다. 다음 줄에서 maverick, slider라는 이름으로 생성한 두 Marsupial 인스턴스는 각자 고유한 프로퍼티 값을 가진다.</p><p>자바스크립트 언어는 Marsupial 함수를 생성자 함수(new 키워드와 함께 사용하려고 작성한 함수)로 사용하라고 강요하지 않는다. 즉, new 키워드 없이 생성자 함수를 사용해도 이를 못하게 막을 보호 체계가 없다. 그래서 더러 개발자들은 파스칼 표기법(PascalCase)으로 생성자 함수를 따로 표기하여 구분하기도 한다.</p><h3 id="3-생성자-함수-프로토-타입-함수"><a href="#3-생성자-함수-프로토-타입-함수" class="headerlink" title="3. 생성자 함수 + 프로토 타입 함수"></a>3. 생성자 함수 + 프로토 타입 함수</h3><figure class="codeblock codeblock--tabbed"><figcaption><span>Marsupial함수와 생성자 함수 사용법</span><ul class="tabs"><li class="tab active">javascript</li></ul></figcaption><div class="tabs-content"><figure class="highlight javascript" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Marsupial</span>(<span class="params">name, nocturanl</span>) </span>{</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.isNocturnal = nocturanl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Marsupial.prototype.isAwake = <span class="function"><span class="keyword">function</span>(<span class="params">isNight</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> isNight === <span class="keyword">this</span>.isNocturnal; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maverick = <span class="keyword">new</span> Marsupial(<span class="string">'매버릭'</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> slider = <span class="keyword">new</span> Marsupial(<span class="string">'슬라이더'</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isNightTime = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(maverick.isAwake(isNightTime)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(slider.isAwake(isNightTime));   <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></figure></div></figure><p>생성자 함수의 프로토타입에 함수를 정의하면 객체 인스턴스를 대량 생성할 때 함수 사본 개수를 한개로 제한하여 메모리 점유율을 낮추고 성능까지 높이는 추가 이점이 있습니다.</p><h3 id="4-올바른-객체-생성에-대한-나의-생각"><a href="#4-올바른-객체-생성에-대한-나의-생각" class="headerlink" title="4. 올바른 객체 생성에 대한 나의 생각"></a>4. 올바른 객체 생성에 대한 나의 생각</h3><p>구조화를 위해 데이터의 객체화에 대한 필요성을 느끼기 시작했습니다. 그래서 흔히들 말하는 모듈패턴과 생성자 함수 프로토 타입을 익히는데 노력했습니다.</p><p>그리고는 특별히 이상한 점을 느끼지 못하고는 이리저리 패턴들을 적용하기에 이르렀습니다. 하지만 자바스크립트가 아시다시피 모든걸 묵인하고 인용하며 에러는 주지않고 “너 하고싶은대로 하거라” 라는  부처님 같은 녀석이라서 이것에 대한 오용과 남용(?)에 대해 잘 인지하지 못하고 있었습니다.<br><br><div class="figure center" style="width:;"><img class="fig-img" src="Buddha.jpeg" alt="마음대로 만들어도 괜찮아~"><span class="caption">마음대로 만들어도 괜찮아~</span></div></p><p>결국 전 이런 코드까지 쓰게 된거죠. 끔찍한 혼종을 만들어 버리고 맙니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.oil = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getOil: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> oil;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.setOil = <span class="function"><span class="keyword">function</span>(<span class="params">newOil</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.oil = newOil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모듈패턴 처럼 사용</span></span><br><span class="line"><span class="keyword">var</span> myCar = Car();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수 처럼 사용</span></span><br><span class="line"><span class="keyword">var</span> myNewCar = <span class="keyword">new</span> Car();</span><br></pre></td></tr></table></figure><p>당연하지만 생각처럼 동작지 않습니다. 두 경우 모두 <code>setOil</code>을 찾아볼 수 없습니다. 모듈 패턴에서는 당연히 myCar가 Car의 인스턴스가 아니기 때문이며, 생성자 패턴에서는 return의 대상이 변경되어서 더 이상 생성자의 역할을 하지 못하기 때문입니다.</p><p>이를 통해 알게 된 점은 목적에 맞는 방법으로 객체를 생성해야 한다는 점입니다. 그러니 모듈 패턴은 유틸과 같은 한 개의 모듈로 동작하게 되는 경우가 적당하며, 여러 개의 인스턴스가 필요한 경우에는 생성자 패턴을 적용해야 합니다.</p><p>이름에서 그 패턴의 목적이 잘 녹아있음에도 불구하고, 자바스크립트의 특성에 의해 전혀 생각지도 못하게 쓰고 있었던 것 같습니다.</p><p>비록 실제 서비스가 <code>Car</code>와 같이 쉽게 객체를 명확히 나눌 수 있는 것은 아닙니다. 객체 자체를 어떻게 구조조화 할건지는 참 어려운 일 중 하나인 것 같습니다. 하지만 이제 스스로도 객체를 생성할 때 좀 더 명확한 판단의 기준을 가지고 효율 적인 객체를 생성하는데 큰 도움이 될 것 같습니다. 😃</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;프로젝트를 구조화하면서 객체의 생성방식은 매우 중요해집니다. 여러가지 객체생성 패턴을 살펴보고 제가 겪었던 문제를 간단히 정리해보았습니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="core" scheme="https://jae-kwang.github.io/blog/categories/js/core/"/>
    
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/tags/js/"/>
    
      <category term="object" scheme="https://jae-kwang.github.io/blog/tags/object/"/>
    
      <category term="pattern" scheme="https://jae-kwang.github.io/blog/tags/pattern/"/>
    
      <category term="prototype" scheme="https://jae-kwang.github.io/blog/tags/prototype/"/>
    
  </entry>
  
  <entry>
    <title>리엑트로 프로젝트 갈아입히기</title>
    <link href="https://jae-kwang.github.io/blog/2018/02/04/project-react/"/>
    <id>https://jae-kwang.github.io/blog/2018/02/04/project-react/</id>
    <published>2018-02-04T06:37:32.000Z</published>
    <updated>2018-12-24T05:03:31.229Z</updated>
    
    <content type="html"><![CDATA[<p>2018년의 첫 번째 목표는 “서비스 중인 프로젝트를 ‘리엑트’로 바꿔보자!”입니다. 이 목표를 수행하면서 진행한 여러 작업을 정리해보려 합니다.</p><a id="more"></a><h3 id="서버사이드-렌더링-프로젝트-구축하기"><a href="#서버사이드-렌더링-프로젝트-구축하기" class="headerlink" title="서버사이드 렌더링 프로젝트 구축하기"></a>서버사이드 렌더링 프로젝트 구축하기</h3><p>프로젝트는 서버사이드 렌더링이 필요했습니다. <span class="highlight-text primary">SSR(Server Side Rendering)</span>이란 말 그대로 렌더링 되어야 할 파일들이 미리 서버에서 렌더링이 되어서 내려오는 것을 의미합니다.</p><p>리엑트는 Webpack을 통해 JSX로 형태로 구성된 파일들을 컴파일해서 브라우저가 읽을 수 있는 번들 파일을 만들어 화면을 렌더링하는 <span class="highlight-text primary">CSR(Client-side Rendering) </span>방식으로 렌더링하는 방식이 보통의 방식으로 사용되고 있습니다. 그러면 어떻게 리엑트가 SSR이 되도록 할까요?</p><p></p><p>리엑트 사용 시 컴포넌트를 렌더링 하기 위해 ‘react-dom’을 import 하는데, 이때 ‘react-dom’에는 <code>renderToString</code>란 메서드가 존재합니다. 이는 리엑트 컴포넌트를 단순 문자열로 변환시켜서 서버에서 바로 사용할 수 있게 해줍니다.</p><p>서버는 Node.js express 구성되어있으며, 아래와 같이 기본 html 형태를 템플릿 리터럴 형태로 내려주었습니다. 이때 <code>renderToString</code> 에 리엑트 엘리먼트를 넘긴 형태를 root 엘리먼트의 자식으로 넘겨주는 방식으로 사용할 수 있습니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; renderToString &#125; from 'react-dom/server'</span><br><span class="line"></span><br><span class="line">res.send(`</span><br><span class="line">    <span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSR App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span>$&#123;renderToString(<span class="tag">&lt;<span class="name">App</span> <span class="attr">data</span>=<span class="string">&#123;preloadedState&#125;/</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'bundle.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">`)</span><br></pre></td></tr></table></figure><p>이렇게 작업한 ‘server.js’파일을 <code>node server.js</code> 가 아닌 <code>babel-node server.js</code>로 Run하여 서버를 띄웠습니다. 또한, webpack을 통해 얻은 ‘bundle.js’를 추가해 상호 작용이 가능하도록 했습니다. 여기에서 <code>preloadedState</code>는 서버에서 직접 받는 데이터로써 해당 데이터를 props로 전달해 component에서 활용합니다.</p><h3 id="리덕스-Redux-설정하기"><a href="#리덕스-Redux-설정하기" class="headerlink" title="리덕스(Redux) 설정하기"></a>리덕스(Redux) 설정하기</h3><p>이 프로젝트는 크기가 크지 않아 처음에는 리덕스를 사용하지 않으려 했습니다. 하지만 앱의 기능 중 하나로 페이지 전체의 ‘언어변경’기능이 있었는데 이는 언어 변경 시 전체 페이지의 언어가 다른 국가의 언어로 변경되어야 했습니다. 그렇다는건 모든 텍스트가 직접 컴포넌트에 작성되어 있는 게 아니라 레퍼런스 값이어야 컨트롤이 가능하다는 것을 의미했습니다. <strong>매 컴포넌트 작업 시 언어정보를 root에서 받아서 사용하는 건 매우 비효율적인 작업이 아닐 수 없었습니다.</strong></p><p>컴포넌트에서 즉시 값을 사용할 수 있게 리덕스를 적용해보았습니다. ‘redux’의 <code>createStore</code>를 사용해 서버에서 받은 값인 ‘preloadedState’와 store 를 컨트롤 하기 위한 ‘reducers’를 넘겨서 store를 생성합니다. 생성된 store를 react와 연결하는 역할을 하는 ‘react-redux’의 <code>Provider</code> 사용해 리엑트에 주입합니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; renderToString &#125; from 'react-dom/server'</span><br><span class="line">import &#123; createStore &#125; from 'redux'</span><br><span class="line">import &#123; Provider &#125; from 'react-redux'</span><br><span class="line">import reducers from './reducers'</span><br><span class="line"></span><br><span class="line">const store = createStore(reducers, preloadedStateㅇ)</span><br><span class="line"></span><br><span class="line">res.send(`</span><br><span class="line">    <span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSR Redux App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span>$&#123;renderToString(<span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">App</span> /&gt;</span><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.__PRELOADED_STATE__ = $&#123;<span class="built_in">JSON</span>.stringify(preloadedState)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'bundle.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">`)</span><br></pre></td></tr></table></figure><p>이제 컴포넌트들은 store를 통해 값을 받아 사용할 수 있습니다. 랜더링 이후에도 ‘bundle.js’에도 동일하게 store를 사용해야하기 때문에 브라우저의 전역 변수인 window에 임의값(<code>__PRELOADED_STATE__</code>)에 preloadedState를 넣어 주도록 합니다.</p><h3 id="HMR-Hot-Module-Replacement-사용하기"><a href="#HMR-Hot-Module-Replacement-사용하기" class="headerlink" title="HMR(Hot Module Replacement) 사용하기"></a>HMR(Hot Module Replacement) 사용하기</h3><span class="highlight-text primary">HMR</span>이란 코드의 수정사항 발생시 브라우저의 새고로침 없이 모듈을 업데이트 해주는 기능을 말합니다. 저는 이를 위해 <code>webpack-hot-middleware</code>를 사용하기로 했습니다. <code>webpack-hot-middleware</code>는 <code>webpack-dev-middleware</code>에 의존적이기 때문에 두가지가 설치되어야 합니다.<br><br>webpack.config.js에 entry와 plugins에 다음과 같이 추가합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">entry: [</span><br><span class="line">    <span class="string">'webpack-hot-middleware/client'</span>,</span><br><span class="line">    path.resolve(__dirname, <span class="string">'src'</span>)</span><br><span class="line">],</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.NoErrorsPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>server.js에 <code>webpack-dev-middleware</code>와 <code>webpack-hot-middleware</code>를 사용하도록 설정합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">var</span> webpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.config'</span>)</span><br><span class="line"><span class="keyword">var</span> compiler = webpack(webpackConfig)</span><br><span class="line"></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">"webpack-dev-middleware"</span>)(compiler, &#123;</span><br><span class="line">    noInfo: <span class="literal">true</span>,</span><br><span class="line">    publicPath: webpackConfig.output.publicPath</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.use(<span class="built_in">require</span>(<span class="string">"webpack-hot-middleware"</span>)(compiler))</span><br></pre></td></tr></table></figure></p><p>store값 변경에도 hmr이 감지하도록 reducers를 바라보도록 합니다.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV == <span class="string">'development'</span> &amp;&amp; <span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'./reducers'</span>, () =&gt; &#123;</span><br><span class="line">        store.replaceReducer(<span class="built_in">require</span>(<span class="string">'./reducers'</span>).default);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위에 보시면 <code>process.env.NODE_ENV == &#39;development&#39;</code>가 있습니다. 이는 개발 환경에서만 이를 사용한다는 의미입니다. 이렇게 분기를 준 이유는 HRM은 일종의 가상 웹서버를 띄워서 그 웹서버를 제어해 컴포넌트 변화 시 화면을 리렌더링하는 방식입니다. 하지만 서버사이드 프로젝트로 다른 서버를 통해 렌더링 되게 프로젝트를 구성한 현재의 방식에는 적합하지 않습니다. 그렇기 때문에 랜더링 되는 부분을 개발 모드와 프로덕션 모드로 나눠줍니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">if (process.env.NODE_ENV === 'development') &#123;</span><br><span class="line">    res.send(`</span><br><span class="line">        <span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSR Redux App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.__PRELOADED_STATE__ = $&#123;<span class="built_in">JSON</span>.stringify(preloadedState)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'bundle.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">    `)</span><br><span class="line">&#125; else if (process.env.NODE_ENV === 'production')</span><br><span class="line">    res.send(`</span><br><span class="line">        <span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSR Redux App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span>$&#123;renderToString(<span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">App</span> /&gt;</span><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.__PRELOADED_STATE__ = $&#123;<span class="built_in">JSON</span>.stringify(preloadedState)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'bundle.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">    `)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>개발 모드에서는 <code>renderToString</code>을 사용하는 SSR이 아닌 CSR을 이용하도록 해서 HMR이 동작하도록 합니다.  </p><blockquote><p><a href="https://blog.cloudboost.io/live-reload-hot-module-replacement-with-webpack-middleware-d0a10a86fc80" target="_blank" rel="noopener">Live Reload / Hot Module Replacement with Webpack Middleware</a><br><a href="http://madole.github.io/blog/2015/08/26/setting-up-webpack-dev-middleware-in-your-express-application/" target="_blank" rel="noopener">Setting Up Webpack Dev Middleware in Express</a></p></blockquote><h3 id="styled-component-사용하기"><a href="#styled-component-사용하기" class="headerlink" title="styled-component 사용하기"></a>styled-component 사용하기</h3><p>리엑트는 컴포넌트 방식으로 코드를 모듈화합니다. 그럼 컴포넌트란 무엇을 의미할까요? <strong>저는 html, CSS, JS가 하나로 뭉쳐있어서 그것만 다른 곳에 놓더라도 바로 사용할 수 있는 것이라고 생각합니다.</strong> 하지만 현재의 상태로는 html과 JS는 합쳐 있지만, CSS는 그렇지 않습니다. 여전히 CSS는 다른 파일에서 작업 된 후 적용이 되어야 하죠. 그렇기 때문에 <a href="https://www.styled-components.com/" target="_blank" rel="noopener">styled-component</a>를 사용하기로 했습니다.</p><p>기본적으로 컴포넌트에서 styled-components를 import 해서 사용 할 수 있지만, 서버사이드 렌더링 시에는 추가로 작업해줘야 할 부분이 있습니다.</p><p>‘styled-components’의 <code>ServerStyleSheet</code>를 통해 얻은 sheet 인스턴스의 collectStyles메서드로  렌더링 될 앱에 넘겨주어야 하며 sheet 인스턴스의 <code>getStyleTags()</code> 를 통해 렌더링 될 컴포넌트의 CSS를 얻어 head에 넣어줍니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; renderToString &#125; from 'react-dom/server'</span><br><span class="line">import &#123; createStore &#125; from 'redux'</span><br><span class="line">import &#123; Provider &#125; from 'react-redux'</span><br><span class="line">import reducers from './reducers'</span><br><span class="line">import &#123; ServerStyleSheet &#125; from 'styled-components'</span><br><span class="line"></span><br><span class="line">const store = createStore(reducers, preloadedState)</span><br><span class="line">const sheet = new ServerStyleSheet()</span><br><span class="line">const styles = sheet.getStyleTags()</span><br><span class="line">if (process.env.NODE_ENV === 'development') &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; else if (process.env.NODE_ENV === 'production')</span><br><span class="line">    res.send(`</span><br><span class="line">        <span class="meta">&lt;!doctype html&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">title</span>&gt;</span>SSR Redux styled-components App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">                $&#123;styles&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'app'</span>&gt;</span>$&#123;renderToString(sheet.collectStyles(<span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">App</span> /&gt;</span><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.__PRELOADED_STATE__ = $&#123;<span class="built_in">JSON</span>.stringify(preloadedState)&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'bundle.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">    `)</span><br></pre></td></tr></table></figure><h4 id="프로젝트-구성하기"><a href="#프로젝트-구성하기" class="headerlink" title="프로젝트 구성하기"></a>프로젝트 구성하기</h4><p>어느 정도 환경은 세팅이 되었다는 판단으로 관련 파일들을 어떻게 구성해야 할지 고민이 많았습니다. 대략적인 구조를 오픈소스들을 참고하며 구조를 잡아 보았습니다.</p><ol><li><b>containers, components</b><ul><li>components : 재사용 가능한 컴포넌트들을 관리합니다</li><li>containers : 프로젝트는 단일 페이지로 router 설정이 필요 없었습니다. 하지만 서버에서 IP를 판단해서 그에 따라 다른 페이지가 나와야 하므로 container는 페이지를 나누는 구분으로 사용하였습니다. (원래라면 components 하위에 존재하는 컴포넌트들을 다루는 여러 핸들러나 로직이 있는 컴포넌트를 모아두는 데 주로 사용합니다.)</li></ul></li><li><b>reducers, actions, constants, store</b><ul><li>Redux 에 종속적인 디렉터리입니다.</li><li>reducers: 액션 타입에 따라 store에 직접 접근해 store 값을 수정하는 리듀서 작업을 위치시킵니다.</li><li>actions: dispatch에 넘겨줄 액션 생성자를 정의하거나, dispatch 후 리듀서로 접근 하기 전 값을 컨트롤할 함수를 작성합니다. (이를 위해 redux-thunk 합니다.)</li><li>contants: 액션 타입을 정해놓은 상숫값들을 지정해 놓은 파일을 넣어둡니다. (actionTypes.js)</li><li>store: store 설정 파일이 있습니다. (configureStore.js)</li></ul></li><li><b>API</b><ul><li>server에 직접 API를 호출하는 역할을 합니다.</li></ul></li></ol><h4 id="데이터-플로우"><a href="#데이터-플로우" class="headerlink" title="데이터 플로우"></a>데이터 플로우</h4><ol><li>해당 프로젝트의 containers 단순 IP에 의존한 페이지 구분을 목적으로 합니다.</li><li>store에 저장될 필요 없는 stateless 한 컴포넌트의 경우 API에 직접 접근하여 기능을 수행할 수 있습니다.</li><li>store에 저장되어야 하는 값은 reducer에 action을 넘겨주는 동작을 반드시 수행해야 합니다.<ul><li>이때 서버에 데이터가 있어야 하는 경우 <code>redux-thunk</code>를 활용해서 비동기 처리를 합니다.</li></ul></li></ol><div class="figure center" style="width:;"><img class="fig-img" src="cycle.png" alt=""></div><blockquote><p>참고 :<br><a href="http://huns.me/development/1953" target="_blank" rel="noopener">리덕스(Redux) 애플리케이션 설계에 대한 생각</a></p></blockquote><h4 id="배포-전-닥친-새로운-문제"><a href="#배포-전-닥친-새로운-문제" class="headerlink" title="배포 전 닥친 새로운 문제"></a>배포 전 닥친 새로운 문제</h4><p>맨 처음 프로젝트를 설정할 때 <code>babel-node server.js</code>로 서버를 Run 한다는 생각으로 프로젝트를 구성하였습니다. 하지만 babel-node가 <a href="https://babeljs.io/docs/usage/cli/#babel-node" target="_blank" rel="noopener">‘프로덕션 모드에 사용돼서는 안 된다’</a>는 사실을 알게 되었습니다. 오픈소스 프로젝트들이 production 모드에서 babel-node를 설정한 부분을 정확히 확인하지 않고 그대로 적용한 저의 실수였습니다.</p><div class="figure center" style="width:;"><img class="fig-img" src="areyoukiddingme.gif" alt=""></div><p>오픈소스를 조사하면서 서버사이드 렌더링 시 서버를 Run 하는 방법은 크게 두 가지로 나눌 수 있었습니다.</p><ol><li>babel-node로 서버를 구동한다.</li><li>서버를 채로 번들링 한 후 node로 서버를 구동한다.</li></ol><p>1번 항목은 프로덕션 배포를 앞둔 저에게는 답이 될 수 없었습니다. 그리고 2번 항목은 저에게는 맞지 않았습니다. 해당 프로젝트는 API Server가 따로 없이 express 서버에 API가 같이 존재했으며, 해당 백엔드 작업은 제가 작업하지 않았거니와 백엔드를 잘 모르는 저에게 그 코드를 번들링해버리는 건 무책임한 행동이라고 생각이 들었습니다.</p><p><strong>그래서 저는 생각 끝에 다음과 같은 방식으로 변경을 시도했습니다.</strong></p><ol><li>서버사이드 렌더링시 템플릿 리터럴 형태로 내려주는 파일을 별도의 .html로 추출합니다.<br>이때 기존에 JS들이 들어가는 위치에 특정 형태의 string으로 추가해 놓습니다 (ex: &lt;% data %&gt;</li><li>renderToString 및 store 설정, styled-components 등 페이지 설정 부분을 별도의 .js 추출합니다.</li><li>wepack.config.prod.js에 또 하나의 번들 task를 추가해 위에서 2번에서 작업한 .js파일을 node.js에서 읽을 수 있는 <code>commonjs</code>형태로 번들링 되도록 설정합니다.</li><li>서버에서 페이지를 내려주는 종단에서 .html을 fs로 읽어들이고, 3번에서 번들링된 모듈을 호출해 각각의 값을 읽습니다.</li><li>읽은 .html을 toString().replace() 통해 치환해줍니다.</li></ol><p>결과적으로 제가 원하는 대로 server는 건드리지 않고 렌더링 되는 부분만 번들링해서 사용할 수 있게 되었습니다.</p><blockquote><p>참고 :<br><a href="http://webframeworks.kr/tutorials/react/server-side-rendering/" target="_blank" rel="noopener">React 애플리케이션의 서버 렌더링</a></p></blockquote><h4 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h4><p>해당 글에는 언급되지 않았지만 이를 제외하고도 많은 문제가 있었고 해결하지 못한 문제들도 많았습니다. 솔직히 말하면 생각했던 방향대로 작업 되지 않아 굴복하고 동작하게끔만 설정해놓은 부분도 더러 있었습니다. 하지만 목표대로 서비스가 되는 프로젝트를 정상적으로 리엑트로 변경하는 작업은 성공이라고 생각됩니다. 시간이 될 때마다 작업한 프로젝트를 손보면서, 새로운 프로젝트에는 또 다른 방식 혹은 더 나은 방식으로 구성해서 작업 해봐야겠습니다. 글이 생각보다 길어져 작업 후 느낀점 같은 부분은 제 기술 블로그가 아닌 개인 블로그에 따로 정리를 해야 할 것 같습니다. 읽어주셔 감사합니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018년의 첫 번째 목표는 “서비스 중인 프로젝트를 ‘리엑트’로 바꿔보자!”입니다. 이 목표를 수행하면서 진행한 여러 작업을 정리해보려 합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/categories/js/react/"/>
    
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/tags/react/"/>
    
      <category term="project" scheme="https://jae-kwang.github.io/blog/tags/project/"/>
    
      <category term="SSR" scheme="https://jae-kwang.github.io/blog/tags/SSR/"/>
    
      <category term="styled-components" scheme="https://jae-kwang.github.io/blog/tags/styled-components/"/>
    
  </entry>
  
  <entry>
    <title>클로저(closure)란?</title>
    <link href="https://jae-kwang.github.io/blog/2017/11/13/js-closure/"/>
    <id>https://jae-kwang.github.io/blog/2017/11/13/js-closure/</id>
    <published>2017-11-13T01:02:33.000Z</published>
    <updated>2018-12-24T05:03:31.219Z</updated>
    
    <content type="html"><![CDATA[<h3 id="클로저-closure"><a href="#클로저-closure" class="headerlink" title="클로저(closure)"></a>클로저(closure)</h3><p>자바스크립트에서 빠지지 않은 개념 중 하나인 클로저에 대해 알아봅시다.</p><a id="more"></a><h3 id="아직도-클로저"><a href="#아직도-클로저" class="headerlink" title="아직도 클로저"></a>아직도 클로저</h3><p>자바스크립트를 사용한지 꽤 지났음에도 불구하고 다시 한번 클로저에 대한 포스팅을 올린다는것은 아직도 내가 클로저를 완벽하게 이해하지 못한다는 것을 의미하고 있는 것 같습니다.</p><p>누군가 나에게 클로저에 대하여 묻는다면, 똑부러지게 대답할 수 있을까요? ‘접근하려고 하는 함수의 생명주기가 종료됬지만, 내부함수가 참조 하고 있어서 그 함수에 접근할 수 있는 함수’입니다.</p><p>더 설명하라고 하면 아직 뭐라해야 할지 모르겠습니다. 다른 사람에게 설명할 수 있을 정도가 되야 아는 거라도 했던가요? 여러번 봤지만 오늘도 또 한번 공부해보려고 합니다. 같은 개념이지만 공부할때마다 이해하는 범위가 조금씩 확장되는것 같습니다. 이러한 이유로 또 한번 클로저를 공부해보려고 합니다.</p><h3 id="클로저를-알기-위한-키워드"><a href="#클로저를-알기-위한-키워드" class="headerlink" title="클로저를 알기 위한 키워드"></a>클로저를 알기 위한 키워드</h3><p>예전에는 클로저는 무엇이다라는 것에 대해서만 집중했지만, 클로저를 잘 이해하기 위해서는 몇가지 개념들을 사전에 이해해야 한다고 생각합니다.</p><p>제가 생각하는 클로저를 알기 전에 이해해야할 몇 가지 키워드들입니다.</p><ol><li>유효 범위(Scope)</li><li>어휘적 유효 범위(Lexical scope)</li><li>실행 컨텍스트(Execution Context)</li><li>유효 범위 체인(Scope Chain)</li></ol><h4 id="1-유효범위-Scope"><a href="#1-유효범위-Scope" class="headerlink" title="1. 유효범위(Scope)"></a>1. 유효범위(Scope)</h4><p>프로그래밍 언어에서 Scope는 변수와 매겨변수의 접근성 및 생존 기간을 제어하고, 이름 충돌 문제 및 메모리 관리를 해주는 중요한 개념 중 하나입니다.  </p><p>대표적으로 C언어와 같은 언어는 <code>블록 유효범위(Block Scope)</code>가 있습니다.</p><ol><li>블록(중괄호로 묶인 문장들의 집합) 내에서 정의된 모든 변수는 블록의 바깥쪽에서는 접근할 수 있다.</li><li>블록 내에서 정의된 변수는 블록의 실행이 끝나면 해제된다.</li></ol><p>그러나 자바스크립트는 <code>블록 유효범위</code>가 아닌 <code>함수 유효범위(Function Scope)</code>를 가지고 있습니다.<br>(ES6 이후로는 자바스크립트도 <code>블록 유효범위</code>도 사용가능합니다.)</p><div class="alert info"><p>함수 내에서 정의된 매개변수와 변수는 함수 외부에서는 유효하지 않지만, 내부에서 정의된 변수는 함수 내부 어느 곳에서도 접근할 수 있습니다.</p></div><h4 id="2-어휘적-유효-범위-Lexical-scope"><a href="#2-어휘적-유효-범위-Lexical-scope" class="headerlink" title="2. 어휘적 유효 범위(Lexical scope)"></a>2. 어휘적 유효 범위(Lexical scope)</h4><p>자바스크립트는 <code>Lexical scope</code> 특성을 지닙니다.<br>Lexical scope란 Scope가 함수 실행시점이 아닌 함수 정의 시점에 정해진다는 의미입니다.</p><p>아래의 예를 보도록 하겠습니다.<br>같은 함수 형태를 보이지만, 좌측은 ‘nero’를 우측은 ‘zero’를 출력합니다.</p><div class="figure " style="width:;"><img class="fig-img" src="lexical-scope.png" alt=""></div><p>좌측은 함수를 처음 선언하는 순간부터 log()의 name 변수는 자신의 상위 스코프의 변수 name을 참조합니다.<br>그래서 Wrapper()에서 log()를 실행하기전에 참조변수인 name을 변경했기에 ‘nero’를 출력하고 있습니다.</p><p>그러나 우측에서는 Wrapper()안에서 새로운 name 변수를 정의 하였습니다.<br>하지만 log()는 이미 상위 스코의 변수인 name을 참조하고 있기때문에 ‘zero’를 출력하게 되는 것입니다.</p><div class="alert info"><p>다시 한번 말하자면 함수가 실행될 때가 아니라 정의될 때에 변수를 참조하게 됩니다.</p></div><h4 id="3-실행-컨텍스트-Execution-Context"><a href="#3-실행-컨텍스트-Execution-Context" class="headerlink" title="3. 실행 컨텍스트(Execution Context)"></a>3. 실행 컨텍스트(Execution Context)</h4><p><code>Execution Context</code>는 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념으로, 코드가 실행되는 <code>환경</code>입니다. 변수나 함수의 실행 컨텍스트는 다른 데이터에 접근할 수 있는지, 어떻게 행동하는지를 규정합니다.</p><p>자바스크립트 인터프리터가 어떤 함수를 실행시킬때마다 그 함수에 대한 새로운 실행 컨텍스트가 생성됩니다.</p><p>실행 컨텍스트가 생성되면 자바스크립트 엔진은 실행에 필요한 여러 정보들을 담을 객체를 생성합니다.<br>이를 <code>변수 객체(Variable Object)</code>라고 합니다. 해당 컨텍스트에서 정의된 모든 변수와 함수는 이 객체에 존재합니다.</p><p>실행 컨텍스트는 포함된 코드가 모두 실행된 후에 파괴되는데, 이때 해당 컨텍스트 내부에서 정의된 변수와 함수도 함께 파괴됩니다.</p><div class="alert info"><p><strong>Scope VS Context</strong><br>Scope는 변수의 가시성과 관련이 있으며, Context는 함수가 실행되는 객체를 나타냅니다.</p></div><h4 id="4-유효-범위-체인-Scope-Chain"><a href="#4-유효-범위-체인-Scope-Chain" class="headerlink" title="4. 유효 범위 체인(Scope Chain)"></a>4. 유효 범위 체인(Scope Chain)</h4><p><code>Scope Chain</code>은 일종의 리스트로서 중첩된 함수의 Scope의 참조를 차례로 저장하고 있는 개념입니다. Scope Chain의 목적은 실행 컨텍스트가 접근할 수 있는 모든 변수와 함수에 순서를 정의하는 것입니다.</p><p>컨텍스트가 함수인 경우 ‘활성화 객체(activation object)’를 변수 객체(Variable Object)로 사용합니다.</p><p>중첩된 함수에서 변수 객체가 값을 찾지 못햇을 경우 해당 부모 컨텍스트에서 찾고 다시 그 다음 부모의 컨텍스에서 찾으며, 전역 컨텍스트에 도달할 때 까지 계속합니다. 전역 컨텍스트의 변수 객체는 항상 스코프 체인의 마지막에 존재합니다.</p><p>내부 컨텍스트는 스코프 체인을 통해 외부 컨텍스트 전체에 접근할 수 있지만 외부 컨텍스트는 내부 컨텍스트에 대해 전혀 알 수 없습니다. 컨텍스트 사이의 연결은 선형이며 순서가 중요합니다.  각 건텍스트는 스코프 체인을 따라 상위 컨텍스트에서 변수나 함수를 검색할 수 있지만 스코프 체인을 따라 내려가며 검색할 수는 없습니다.</p><h3 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h3><p>클로저는 가장 맨 앞에서 언급했듯 한마디로 <span class="highlight-text primary">'접근하려고 하는 함수의 생명주기가 종료됬지만, 내부함수가 참조 하고 있어서 그 함수에 접근할 수 있는 함수'</span>라고 말할 수 있습니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'Hello'</span>;</span><br><span class="line">  <span class="keyword">var</span> funB = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(x); &#125;;</span><br><span class="line">  <span class="keyword">return</span> funB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> funC = funA();</span><br><span class="line">funC(); <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>funA()가 실행종료 되었으니 x또한 접근할수가 없어야 하는데 return 된 funB()를 받은 funcC()를 실행하니 x를 참조 할 수 있게 되었습니다.</p><h3 id="클로저-사용시-주의해야할-점"><a href="#클로저-사용시-주의해야할-점" class="headerlink" title="클로저 사용시 주의해야할 점"></a>클로저 사용시 주의해야할 점</h3><p>클로저는 외부 함수의 변수를 참조 합니다. 하지만 값의 복사값은 아닙니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add_the_handlers = <span class="function"><span class="keyword">function</span>(<span class="params">nodes</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;nodes.length; i++) &#123;</span><br><span class="line">nodes[i].onClick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">alert(i);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이 함수는 노드를 클릭하면 해당 노드가 몇 번째 노드인지를 경고창으로 알려주는것이 함수의 목적이지만, 함수 전체 노드의 수만 보여주게 됩니다. 이유는 함수의 i가 함수가 만들어지는 시점의 i가 아니라 그냥 상위 스코프의 변수 i를 참조하기 때문입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add_the_handlers = <span class="function"><span class="keyword">function</span>(<span class="params">nodes</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;nodes.length; i++) &#123;</span><br><span class="line">nodes[i].onClick = <span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">alert(i);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이제 onclick에 함수를 연결되어 있는 내부 함수에서 새로 함수를 정의하고 여기에 i를 넘기면서 곧바로 실행시켰습니다. 실행된 함수는 add_the_handlers에 정의된 i가 아니라 넘겨받은 i의 값을 이벤트 핸들러 함수에 연결하여 반환합니다.<br>이 반환되는 이벤트 핸들러 함수는 onclick에 할당합니다. 함수가 원한는 목적대로 구현이 되었습니다.</p><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>보통 코드를 잘때면 클로저를 생각하지 않고 자연스러운 흐름에 의해 클로저를 사용하는 경우가 많습니다. 앞으로는 그러한 부분에 있어서 좀더 의식적으로 이해하고 코드를 작성하도록 해야 하겠습니다. </p><blockquote><p>참고 :</p><ul><li>블로그<br><a href="http://meetup.toast.com/posts/86" target="_blank" rel="noopener">자바스크립트의 스코프와 클로저</a><br><a href="https://www.zerocho.com/category/Javascript/post/5740531574288ebc5f2ba97e" target="_blank" rel="noopener">함수의 범위(scope)</a><br><a href="http://www.nextree.co.kr/p7363/" target="_blank" rel="noopener">JavaScript : Scope 이해</a><br><a href="http://webclub.tistory.com/113" target="_blank" rel="noopener">유효범위의 효용</a><br><a href="http://poiemaweb.com/js-execution-context" target="_blank" rel="noopener">실행 컨텍스트와 자바스크립트의 동작 원리</a><br><a href="http://ryanmorr.com/understanding-scope-and-context-in-javascript/" target="_blank" rel="noopener">Understanding Scope and Context in JavaScript</a><br><a href="https://blog.kevinchisholm.com/javascript/difference-between-scope-and-context/" target="_blank" rel="noopener">What is the Difference Between Scope and Context in JavaScript?</a><br><a href="https://blog.outsider.ne.kr/506" target="_blank" rel="noopener">자바스크립트 클로저(Closure)에 대해서…</a></li><li>책<br>자바스크립트 완벽 가이드<br>프론트엔드 개발자를 위한 자바스크립트 프로그래밍<br>함수형 자바스크립트</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;클로저-closure&quot;&gt;&lt;a href=&quot;#클로저-closure&quot; class=&quot;headerlink&quot; title=&quot;클로저(closure)&quot;&gt;&lt;/a&gt;클로저(closure)&lt;/h3&gt;&lt;p&gt;자바스크립트에서 빠지지 않은 개념 중 하나인 클로저에 대해 알아봅시다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="core" scheme="https://jae-kwang.github.io/blog/categories/js/core/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="closure" scheme="https://jae-kwang.github.io/blog/tags/closure/"/>
    
  </entry>
  
  <entry>
    <title>form 전송과 ajax 전송</title>
    <link href="https://jae-kwang.github.io/blog/2017/10/16/form-vs-ajax/"/>
    <id>https://jae-kwang.github.io/blog/2017/10/16/form-vs-ajax/</id>
    <published>2017-10-16T00:39:10.000Z</published>
    <updated>2018-12-24T05:03:31.219Z</updated>
    
    <content type="html"><![CDATA[<h3 id="form-전송과-ajax-전송의-차이"><a href="#form-전송과-ajax-전송의-차이" class="headerlink" title="form 전송과 ajax 전송의 차이"></a>form 전송과 ajax 전송의 차이</h3><p>요즘 흔히 서버와의 통신시 ajax를 사용하고 있습니다.<br>하지만 <code>&lt;form&gt;</code>을 통해서도 서버와의 통신이 가능한데 어떤 차이점이 있을까요?</p><a id="more"></a><h2 id="비동기"><a href="#비동기" class="headerlink" title="비동기"></a>비동기</h2><p>form 방식과 ajax 방식의 대표적인 차이점이라고 하면 역시 ajax는 페이지의 전환 없이 <code>비동기</code>로 서버와 통신을 할 수 있게 되었다는 점입니다. 이러한 <code>비동기</code>를 통해 전체 페이지가 아닌 일부분만을 업데이트 할 수 있게 해줍니다.</p><h2 id="이벤트"><a href="#이벤트" class="headerlink" title="이벤트"></a>이벤트</h2><p>사용자 인터렉션에 의헤 데이터를 서버로 전송하는경우 반드시 이벤트에 의해 발생되게 됩니다.</p><p>이때, ajax를 사용해 통신을 할 경우 이벤트를 처리하는 이벤트 리스너를 별도로 생성해야합니다.</p><p>하지만 form을 이용한다면 별도의 코드 없이 HTML에서 만으로 submit 이벤트를 발생시켜서 데이터를 서버에 전송할 수 있습니다.</p><p>form에 form submit이 가능한 버튼이 있고, form에 포커스가 있는 상태라면 <code>enter</code>를 누르면 form submit이 됩니다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 폼 전송이 가능한 버튼 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 범용 전송 버튼 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit Form"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 커스텀 전송 버튼 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit Form<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 이미지 버튼-&gt;</span></span><br><span class="line"><span class="comment">&lt;input type="image" src="graphic.gif"&gt;</span></span><br></pre></td></tr></table></figure><p>form에는 이처럼 편의 기능이 있어서, 두가지 경우를 합쳐서 사용한는 경우가 많습니다. </p><p>form을 이용해 submit 이벤트를 발생시키고, 이후에 form 전송이 막고 ajax를 통해 <code>비동기</code> 로 통신을 하는 방식이 많이 사용 되고 있습니다.</p><h2 id="content-type"><a href="#content-type" class="headerlink" title="content-type"></a>content-type</h2><p>content-type은 request로 보내는 데이터가 무엇인지 알려줍니다.</p><p>기본적으로 form과 ajax의 content-type은 <code>application/x-www-form-urlencoded</code>으로 key=value&amp;key=value 형태로 전송됩니다.</p><p>form에서는 기본 전송인 <code>application/x-www-form-urlencoded</code>방식과 파일전송 방식인 <code>multipart/form-data</code>을 사용하고 있습니다.</p><p>하지만 ajax는 기본을 제외하고 다른 라이브러리들은 이를 <code>application/json</code>과 같은 다른 방식으로 사용하는 경우가 많으니 인지하고 사용해야 합니다.</p><p>변경된 이유는 예전과 다르게 <code>다계층</code>의 데이터를 주고 받아야 할 일이 많아졌기 때문입니다.</p><blockquote><p>참고 :</p><ul><li><a href="https://gist.github.com/jays1204/703297eb0da1facdc454" target="_blank" rel="noopener">https://gist.github.com/jays1204/703297eb0da1facdc454</a></li><li><a href="http://fetobe.co.kr/http-protocol/" target="_blank" rel="noopener">http://fetobe.co.kr/http-protocol/</a></li><li><a href="http://1ambda.github.io/content-type-vs-accept-http-header/" target="_blank" rel="noopener">http://1ambda.github.io/content-type-vs-accept-http-header/</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;form-전송과-ajax-전송의-차이&quot;&gt;&lt;a href=&quot;#form-전송과-ajax-전송의-차이&quot; class=&quot;headerlink&quot; title=&quot;form 전송과 ajax 전송의 차이&quot;&gt;&lt;/a&gt;form 전송과 ajax 전송의 차이&lt;/h3&gt;&lt;p&gt;요즘 흔히 서버와의 통신시 ajax를 사용하고 있습니다.&lt;br&gt;하지만 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;을 통해서도 서버와의 통신이 가능한데 어떤 차이점이 있을까요?&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/tags/js/"/>
    
      <category term="form" scheme="https://jae-kwang.github.io/blog/tags/form/"/>
    
      <category term="ajax" scheme="https://jae-kwang.github.io/blog/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>Bootstrap의 tap plugins 분석</title>
    <link href="https://jae-kwang.github.io/blog/2017/10/11/bootstrap-tab/"/>
    <id>https://jae-kwang.github.io/blog/2017/10/11/bootstrap-tab/</id>
    <published>2017-10-11T00:10:00.000Z</published>
    <updated>2018-12-24T05:03:31.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Bootstrap의-tabs-코드-분석"><a href="#Bootstrap의-tabs-코드-분석" class="headerlink" title="Bootstrap의 tabs 코드 분석"></a>Bootstrap의 tabs 코드 분석</h3><p>Bootstrap은 plugin을 생성할때 코드를 어떻게 구조화하는지 tab plugin을 통해 분석해보며 이해해 봅니다.</p><p>버전은 v3.3.2을 사용합니다.</p><a id="more"></a><h3 id="코드-분석의-목적"><a href="#코드-분석의-목적" class="headerlink" title="코드 분석의 목적"></a>코드 분석의 목적</h3><p>현재 export, import 혹은 require와 같은 방법을 통해 module이나 component를 효율적으로 나눠서 사용하고 있습니다.</p><p>그렇다면 위의 기능들이 없었을때는 어떻게 효율적으로 코드를 분할할 수 있었을까요?</p><p>만약 코드 구조가 현재 지원하고 있는 방식이 아니라 다른방식일 경우 어떻게 사용할 수 있을지 알기 위함입니다.</p><h3 id="Bootstrap의-함수"><a href="#Bootstrap의-함수" class="headerlink" title="Bootstrap의 함수"></a>Bootstrap의 함수</h3><p>기본적으로 Bootstrap은 plugin을 구현시 <code>생성자 패턴</code>과 <code>프로토타입 패턴</code>을 적용해서 구현하고 있습니다.</p><p>패턴 적용시 자신만의 인스턴스를 가지면서도 참조 방식을 통해 메서드를 공유해 메모리를 절약할 수 있습니다.</p><p>Bootstrap은 다음과 같이 익명함수로 모든 기능을 정의해서 스코프가 섞이지 않도록 합니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;(jQuery);</span><br></pre></td></tr></table></figure><p>여기서 <code>+</code> 다음에 나오는 부분을 파서는 표현식으로 처리하며, 위와 같이 즉시 실행함수에서 사용됩니다.</p><p>만약, <code>+</code>가 없는 상태라면 파서가 <code>function</code>을 함수 표현식이 아닌 선언식으로 인식하여 뒤에 나오는 <code>()</code>가 오류로 처리됩니다.</p><blockquote><p>참고 : <a href="https://stackoverflow.com/questions/13341698/javascript-plus-sign-in-front-of-function-name/13341710" target="_blank" rel="noopener">https://stackoverflow.com/questions/13341698/javascript-plus-sign-in-front-of-function-name/13341710</a></p></blockquote><h3 id="이벤트-바인딩"><a href="#이벤트-바인딩" class="headerlink" title="이벤트 바인딩"></a>이벤트 바인딩</h3><p>jQuery의 ‘on’을 API 통해 이벤트를 등록하고 있습니다.</p><p>여기서 ‘이벤트 위임(Event Delegation)’ 방식으로 이벤트를 등록하고 있습니다. </p><div class="alert info"><p><strong>이벤트 위임(Event Delegation)</strong><br>이벤트 위임은 이벤트 버블링의 장점을 활용하여, 이벤트 헨들러를 하나만 할당해서 해당 타입의 이벤트를 모두 처리하는 테크닉입니다. DOM요소 하나에만 접근해 거기에만 이벤트 핸들러를 할당하므로 비용이 훨씬 적으며, 메모리를 훨씬 조금 사용합니다.</p></div><p>이벤트 위임의 또 하나의 장점은 동적으로 생성되는 요소에 일일이 이벤트를 할당할 필요가 없다는 점입니다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>)</span><br><span class="line">  .on(<span class="string">'click.bs.tab.data-api'</span>, <span class="string">'[data-toggle="tab"]'</span>, clickHandler)</span><br><span class="line">  .on(<span class="string">'click.bs.tab.data-api'</span>, <span class="string">'[data-toggle="pill"]'</span>, clickHandler)</span><br></pre></td></tr></table></figure><p>이벤트 대상은 ‘[data-toggle=”tab”]’와 ‘[data-toggle=”pill”]’이며, 이벤트 처리는 ‘clickHandler’에서 진행됩니다.</p><p>이때 걸려 있는 이벤트는 ‘click’ 이벤트로, 이 이벤트는 ‘bs, tab, data-api’라는 namespace를 갖습니다.</p><h3 id="이벤트-핸들러"><a href="#이벤트-핸들러" class="headerlink" title="이벤트 핸들러"></a>이벤트 핸들러</h3><p>이벤트에 대한 이벤트 처리가 이루어집니다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clickHandler = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault()</span><br><span class="line">  Plugin.call($(<span class="keyword">this</span>), <span class="string">'show'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>엘리먼트의 e.preventDefault()를 통해 기본기능을 막고, 선언된 Tab Plugin을 .call()로 ‘show’를 호출하며 현재 ‘this’를 교체합니다.</p><h3 id="탭-플러그인-정의"><a href="#탭-플러그인-정의" class="headerlink" title="탭 플러그인 정의"></a>탭 플러그인 정의</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">var</span> data  = $<span class="keyword">this</span>.data(<span class="string">'bs.tab'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!data) $<span class="keyword">this</span>.data(<span class="string">'bs.tab'</span>, (data = <span class="keyword">new</span> Tab(<span class="keyword">this</span>)))</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> option == <span class="string">'string'</span>) data[option]()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우선, 대상되는 요소의 data정보에 ‘bs.tab’이 있는지 확인하는 작업을 하는데 이는 이전에 이벤트가 바인딩 되어 있는지 체크하는 작업입니다.</p><p>만약 이벤트가 바인딩이 되어 있지 않다면 선언된 Tab을 new 통해 인스턴스를 생성하여 해당 요소의 data에 ‘bs.tab’의 값으로서 할당합니다.</p><p><strong>이 작업은 이벤트가 바인딩 되어있는지를 확인하는 flag로써 활용할 수 있으며, 실제로 기능을 하는 함수로 사용됩니다.</strong></p><p>마지막으로 option으로 넘어온 ‘show’를 실행시킵니다. (data.show())</p><h3 id="jQuery-Plugin-설정"><a href="#jQuery-Plugin-설정" class="headerlink" title="jQuery Plugin 설정"></a>jQuery Plugin 설정</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> old = $.fn.tab</span><br><span class="line"></span><br><span class="line">$.fn.tab             = Plugin</span><br><span class="line">$.fn.tab.Constructor = Tab</span><br><span class="line"></span><br><span class="line">$.fn.tab.noConflict = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $.fn.tab = old</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jQuery의 Plugin을 설정시 $.fn에 연결합니다. jQuery에서는 이부분에 연결된 기능을 prototype으로 연결시킵니다.</p><p>다음으로는 Constructor에 연결합니다. 그 이유는 일부 동일한 다른 함수의 경우 (popover의 경우에는 tooptip을 상속받아서 사용)에는 다른 기능을 상속받아 사용하기 때문에 어떤 유형인지 확인이 어렵습니다. 그래서 Constructor를 사용해 어떤 유형인지 확인하는데 사용될 수 있습니다.</p><blockquote><p>참고 : <a href="https://stackoverflow.com/questions/19680895/bootstrap-constructor" target="_blank" rel="noopener">https://stackoverflow.com/questions/19680895/bootstrap-constructor</a></p></blockquote><p>$.fn.tab.noConflict를 사용해 이전에 $.fn.tab에 사용되고 있었던 플러그인을 사용할 수 있습니다. (예전에 동일한 이름으로 플러그인을 사용하고 있다는 가정하에)</p><h3 id="탭-클래스-정의"><a href="#탭-클래스-정의" class="headerlink" title="탭 클래스 정의"></a>탭 클래스 정의</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tab = <span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.element = $(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tab.VERSION = <span class="string">'3.3.2'</span></span><br><span class="line"></span><br><span class="line">Tab.TRANSITION_DURATION = <span class="number">150</span></span><br><span class="line"></span><br><span class="line">Tab.prototype.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">Tab.prototype.activate = <span class="function"><span class="keyword">function</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>부트스랩은 프로토타입 상속에 의해 기능들이 정의 되어 있습니다.</p><p>인스턴스를 생성하기위한 Tab 클래스를 생성하고, 필요한 상수를 선언하며, 기능들을 prototype에 추가합니다.</p><p>앞서 설명된 플러그인에서 탭 플러그인 설정에서 사용되는 클래스 입니다.</p><p>Tab.prototype.show에서는 요소를 노출하기 위한 action을 trigger하는 기능들을 모아놓았으며,</p><p>Tab.prototype.activate에서는 실제 요소를 활성화 시키는 .active 클래스를 컨트롤 합니다.</p><h3 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h3><p><strong>“높은 응집도 낮은 결합도”</strong>에 대한 이해가 조금이나마 와닿은것 같습니다.<br>예전에는 머리로 이했었던 느낌이지만 요즘은 이런게 필요하구나 라는 것을 직접 느끼고 있는것 같습니다.</p><p>사실 디자인 패턴을 공부하면서 직접 적용해서 작업하는건 쉽지 않는다고 판단이 들어서,<br>유명한 라이브러리들을 조금씩 열어보면서 이들은 어떤식으로 구조화를 했었고, 어떻게 진화하고 있는지 알아보려고 했습니다.</p><p>우선 제가 가장 많이 쓰고 있는 것중에 하나인 bootstrap중에서 가장 짧은 tab을 살펴 보았습니다.<br>더 공부해야겠지만, 이러한 방식을 더 잘 이해하면 현재 사용되는 모듈 방식을 좀 더 잘 사용할 수 있지 않을까 생각됩니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Bootstrap의-tabs-코드-분석&quot;&gt;&lt;a href=&quot;#Bootstrap의-tabs-코드-분석&quot; class=&quot;headerlink&quot; title=&quot;Bootstrap의 tabs 코드 분석&quot;&gt;&lt;/a&gt;Bootstrap의 tabs 코드 분석&lt;/h3&gt;&lt;p&gt;Bootstrap은 plugin을 생성할때 코드를 어떻게 구조화하는지 tab plugin을 통해 분석해보며 이해해 봅니다.&lt;/p&gt;
&lt;p&gt;버전은 v3.3.2을 사용합니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="bootstrap" scheme="https://jae-kwang.github.io/blog/categories/js/lib/bootstrap/"/>
    
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
      <category term="bootstrap.js" scheme="https://jae-kwang.github.io/blog/tags/bootstrap-js/"/>
    
  </entry>
  
  <entry>
    <title>Under-the-hood-ReactJS(2) - 업데이트</title>
    <link href="https://jae-kwang.github.io/blog/2017/09/28/Under-the-hood-ReactJS-2/"/>
    <id>https://jae-kwang.github.io/blog/2017/09/28/Under-the-hood-ReactJS-2/</id>
    <published>2017-09-28T00:18:00.000Z</published>
    <updated>2018-12-24T05:03:31.217Z</updated>
    
    <content type="html"><![CDATA[<p>Under-the-hood-ReactJS의 파트 8~10인 업데이트 관련 부분입니다.</p><a id="more"></a><h3 id="파트-8"><a href="#파트-8" class="headerlink" title="파트 8"></a>파트 8</h3><h4 id="this-setState"><a href="#this-setState" class="headerlink" title="this.setState"></a>this.setState</h4><div class="alert info"><p>인트로에서도 언급되었듯 업데이트의 시작은 <strong>this.setState</strong>에서 부터 다뤄집니다.</p></div><ul><li>setState는 <code>ReactComponent</code>에서 컴포넌트를 상속받았고, <code>updater</code> 속성을 받습니다. (파트3)</li><li>각 컴포넌트는 자신의 pandding state의 목록을 가지고 있고, 하나의 트랜잭션에서 setState를 호출 할 때마다 그 객체를 대기열에 넣은 다음 나중에 하나씩 컴포넌트 state로 머지합니다.</li><li>setState를 호출하여, 컴포넌트를 dirtyComponents 리스트에 추가 할 수 있습니다.<ul><li>dirtyComponents는 변경된 항목들을 비교하기위해 넣어두는 리스트 입니다. (파트 10)</li></ul></li></ul><hr><h3 id="파트-9"><a href="#파트-9" class="headerlink" title="파트 9"></a>파트 9</h3><h4 id="setState-메소드가-호출되는-두가지-경우"><a href="#setState-메소드가-호출되는-두가지-경우" class="headerlink" title="setState 메소드가 호출되는 두가지 경우"></a>setState 메소드가 호출되는 두가지 경우</h4><ul><li>마우스 이벤트에 의한 호출<ul><li>마우스 이벤트가 발생하면 앞서 살펴본 것처럼 여러 레이어를 통해 일괄(batched)업데이트 되는데, ReactReconcileTransaction 래퍼가 비활성화되고 이후 ReactEventListener enabled때 다시 발생될때 안전하게 마운팅됩니다. (파트 2)</li></ul></li><li>setTimeout에 의한 호출<ul><li>setTimeout의 경우에도 위의 경우와 다르지 않게 트랜잭션이 아직 오픈되지 않았을 경우 일괄(batching) 트렌젝션 열고 dirtyComponents리스트에 영향받은 컴포넌트 추가하고 트렌젝션을 close(ReactUpdates.flushBatchedUpdates)하고 dirtyComponents를 처리합니다.</li></ul></li></ul><hr><h3 id="파트-10"><a href="#파트-10" class="headerlink" title="파트 10"></a>파트 10</h3><h4 id="Dirty-components"><a href="#Dirty-components" class="headerlink" title="Dirty components"></a>Dirty components</h4><ul><li>dirtyComponents리스트를 처리하기 위해 루프를 수행합니다.</li><li>이때 ReactUpdates.runBatchedUpdates 호출합니다.<ul><li>새로운 또 하나의 트렌젝션 <strong>ReactUpdatesFlushTransaction 래퍼</strong> 사용</li><li>dirtyComponentsLength가 변경된 경우 flushBatchedUpdates를 통해 한번 더 수행</li></ul></li><li>ReactUpdatesFlushTransaction 래퍼(dirtyComponents 배열을 지우고, 마운트 준비 핸들러(예: componentDidUpdate)가 대기열에 추가 한 모든 업데이트를 수행)<ul><li>dirtyComponets배열 정렬(mount order)</li><li>dirtyComponentsLength을 기준으로 반복해서 수행.</li><li>각 컴포넌트를 ReactReconciler.performUpdateIfNecessary로 전달.<ul><li>실제로 performUpdateIfNecessary메소드는 ReactCompositeComponent.updateComponent에서 호출합니다.</li></ul></li></ul></li></ul><hr><h3 id="파트-11"><a href="#파트-11" class="headerlink" title="파트 11"></a>파트 11</h3><h4 id="Update-component"><a href="#Update-component" class="headerlink" title="Update component"></a>Update component</h4><ul><li>setState가 호출되거나 props가 변경된 경우 updateComponent 메소드가 호출될 수 있습니다.</li><li>pending state queue기반으로 nextState를 비교합니다. (예제 에서의 {message : “click state message”})</li><li>shouldUpdate를 디폴트값 true로 설정<ul><li>실제로 <code>shouldComponentUpdate</code>가 지정되지 않은 경우에도 컴포넌트가 기본적으로 업데이트되는 이유</li></ul></li><li>강제 업데이트인지 확인<ul><li>강제 업데이트가 아닌경우 <code>shouldComponentUpdate</code> 메소드가 호출되어 <code>shouldUpdate</code>의 결과 값으로 재할당됩니다.</li></ul></li></ul><hr><h3 id="파트-12"><a href="#파트-12" class="headerlink" title="파트 12"></a>파트 12</h3><h4 id="실제로-컴포넌트를-업데이트하는-경우"><a href="#실제로-컴포넌트를-업데이트하는-경우" class="headerlink" title="실제로 컴포넌트를 업데이트하는 경우"></a>실제로 컴포넌트를 업데이트하는 경우</h4><ul><li><p><code>componentWillUpdate</code>가 명시되어 있다면 그것을 호출합니다.</p></li><li><p>컴포넌트를 리랜더링합니다.</p><ul><li>컴포넌트의 render 메소드를 호출하고, 그에 따라 DOM을 업데이트 합니다.</li><li>이전에 렌더링된 엘리먼트와 비교하여 DOM을 실제로 업데이트해 하는지 확인합니다.(update or replace completely)<ul><li>shouldUpdateReactComponent(중복된 DOM 업데이트를 피하고 리엑트 성능을 향상)</li></ul></li></ul></li><li><p><code>componentDidUpdate</code> 호출을 대기열에 추가합니다.</p></li></ul><hr><h3 id="파트-13"><a href="#파트-13" class="headerlink" title="파트 13"></a>파트 13</h3><h4 id="Receive-component"><a href="#Receive-component" class="headerlink" title="Receive component"></a>Receive component</h4><ul><li><p>shouldUpdateReactComponent -&gt; ReactReconciler.receiveComponent -&gt; ReactDOMComponent.receiveComponent</p><ul><li>위와 같은 형태로 다음 엘리먼트 전달합니다.</li></ul></li><li><p>DOM 컴포넌트 인스턴스에 전달받은 엘리먼트를 할당하고 update 메소드를 호출합니다.</p></li><li><p>updateComponent 메소드는 실제로 prev와 next props를 기반으로 2가지 동작을 수행합니다.</p><ul><li>DOM properties 업데이트 : _updateDOMProperties(파트 5)</li><li>DOM children 업데이트 : _updateDOMChildren(파트 14)</li></ul></li></ul><hr><h3 id="파트-14"><a href="#파트-14" class="headerlink" title="파트 14"></a>파트 14</h3><h4 id="updateDOMChildren"><a href="#updateDOMChildren" class="headerlink" title="_updateDOMChildren"></a>_updateDOMChildren</h4><ul><li><p>‘ExampleApplication’는 button, ChildCmp, text string를 자식으로 가지고 있습니다.</p></li><li><p>해당 컴포넌트의 자식이 ‘content’형태인지 ‘complex’형태 인지 판단합니다.</p><ul><li>complex : 리엑트 컴포넌트</li><li>content : 문자열이나 숫자와 같은 단순타입</li></ul></li><li><p>complex인 경우</p><ul><li>부모 컴포넌트는 이전에 수행했던 시나리오와 동일한 시나리오를 통해 자식들을 전달합니다.</li><li>‘content’ 레벨에 도달할때까지 여러번 작업을 반복합니다.</li></ul></li><li><p>content인 경우</p><ul><li>이전과 현재 텍스트가 같은지 비교하고 수정되었다면 업데이트 합니다.(replace)</li><li>텍스트 업데이트인 경우 setTextContent를 호출해 HTML노드의 내용을 수정합니다.</li><li>콘텐츠가 업데이트되고 페이지에서 사용자를 위해 리렌더링됩니다.</li></ul></li><li><p>이전에 대기열에 넣어두었던 <code>componentDidUpdate</code>를 호출합니다. (파트 12)</p><ul><li><code>componentDidUpdate</code>를 호출할 수 있는 이유<ul><li>dirty 컴포넌트 업데이트는 ReactUpdatesFlushTransaction로 래핑되었고, 래퍼 중 하나는 실제로 this.callbackQueue.notifyAll() 로직을 포함하므로 <code>componentDidUpdate</code>를 호출되는 것입니다. (파트 10)</li></ul></li></ul></li></ul><hr><p>저는 이 글들을 번역하고 공부하면서도 실제로 100% 이해했다고는 말할 수 없었습니다. 다만 제가 리엑트 이해도를 100%로 정했을때 스스로의 이해도가 10%정도의 수준이라면 15%정도 되지 않았을까라는 생각정도만 가지고 있습니다.</p><p>그 이유로는, 저는 무언가를 읽고 학습할때 글보다는 코드로 이해하는게 훨씬 이해도가 높습니다. 그래서 제가 처음보는 말들보다는 익숙한 예약어들이 많이 등장할때 훨씬 이해가 잘되는 느낌이었습니다.</p><p>그 예약어로는 라이프사이클 메소드를 들 수가 있었고, 제가 가지고 있는 라이프사이클 순서 사이사이에 위에서 알아본 일련의 과정들을 집어넣어보면서 이해했던것 같습니다.</p><p>제법 오랜시간동안 이거 한다고 다른걸 안하고 있었으니, 이제는 실제로 써먹을 수 있을지 간단히 리엑트 프로젝트를 한번 해봐야겠습니다!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Under-the-hood-ReactJS의 파트 8~10인 업데이트 관련 부분입니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/categories/js/lib/react/"/>
    
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/tags/react/"/>
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Under-the-hood-ReactJS(1) - 마운트</title>
    <link href="https://jae-kwang.github.io/blog/2017/09/28/Under-the-hood-ReactJS-1/"/>
    <id>https://jae-kwang.github.io/blog/2017/09/28/Under-the-hood-ReactJS-1/</id>
    <published>2017-09-28T00:18:00.000Z</published>
    <updated>2018-12-24T05:03:31.217Z</updated>
    
    <content type="html"><![CDATA[<p>Under-the-hood-ReactJS를 읽어보면서 이해한 부분을 정리해보았습니다.<br>Intro ~ 파트7까지의 마운트 부분에 대한 설명이 있습니다.</p><a id="more"></a><p>처음 뭔가를 배울때는 아무것도 모르는 상태에서 책이나 다른 문서의 예제를 약간씩 따라 치면서 익히곤 합니다.</p><p>그러다 스스로 뭔가 대충 “아, 정확히는 모르겠지만 이건 요런 방식이구나…” 라고 생각되는 시점이 오면 “그런데 이게 어떻게 되는거지?”라고 생각하게 되는 것 같은데 이때 <a href="https://bogdan-lyashenko.github.io/Under-the-hood-ReactJS/" target="_blank" rel="noopener">Under-the-hood-ReactJS</a>를 알게되었습니다.</p><p>영어실력이 좋지 않아서 번역기의 도움을 받으면서 몇 번씩 읽어보았고 제가 이해한 방식으로 해석하는 작업을 몇 차례 반복했습니다. 한달정도의 시간동안 틈틈히 공부 했지만, 그럼에도 이해 안된 부분들이 조금씩은 있어서, 번역된 내용중에 ‘한글인데 뭔말인지 모르겠다…’ 란 부분은 바로 그러한 부분이니 참고 부탁드립니다. :)</p><p>현재 저는 올초부터 리엑트를 공부하기 시작했지만, 실제 총 시간으로 따지만 약 두달 정도만 리엑트에 집중했던것 같습니다. 이것을 말하는 이유는 저와 비슷한 초보자들도 읽어볼 수 있을 만한 글이라는것을 말씀드리고 싶어서 입니다.</p><p>다음은 저자가 14개의 파트로 나눠서 작업한 부분들을 번역하면서 간단히 요약해 놓은 부분입니다. </p><hr><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><ul><li><p>전체적으로 두가지 프로세스를 다루고 있습니다 : <strong>‘마운트’와 ‘업데이트’</strong></p><ul><li>마운트 : 파트 1~7 / 시작 : ReactDOM.render</li><li>업데이트 : 파트 8~14 / 시작 : component.setState </li></ul></li><li><p>코드에 상응하는 전체 스키마가 있는 것은 아닙니다.</p></li><li><p>마지막에 보이는 샘플 코드는 앞으로 나오는 파트들에 꾸준히 예제로 쓰이고 있습니다.</p></li></ul><div class="alert info"><p>각 파트별로 해당되는 스키마를 잘라서 보여주기는 합니다만 <strong>전체 스키마</strong>와 <strong>샘플코드</strong>를 항상 띄워 놓고 다음 파트들을 살펴보면 보면 이해가 좀 더 수월한 것 같습니다.</p></div><hr><h3 id="파트-0"><a href="#파트-0" class="headerlink" title="파트 0"></a>파트 0</h3><h4 id="ReactDom-render"><a href="#ReactDom-render" class="headerlink" title="ReactDom.render"></a>ReactDom.render</h4><ul><li>앱의 시작은 ReactDom.render에서 부터 시작됩니다.<ul><li>JSX가 리엑트의 엘리먼트되는 시작이며, 이건 단순히 plain objects에 불과합니다.</li><li>실제로, ReactDOM에는 로직이 없고, <code>ReactMount</code>를 사용하기 위한 인터페이스일 뿐입니다. 따라서 <code>ReactDOM.render</code>를 호출하면 기술적으로 <code>ReactMount.render</code>를 호출합니다.</li></ul></li></ul><blockquote><p><strong>마운팅이란?</strong><br>  DOM 엘리먼트를 생성하고 제공된 container에 삽입하여 리엑트 컴포넌트를 초기화하는 작업입니다.</p></blockquote><h4 id="React-컴포넌트-인스턴스화"><a href="#React-컴포넌트-인스턴스화" class="headerlink" title="React 컴포넌트 인스턴스화"></a>React 컴포넌트 인스턴스화</h4><ul><li>가장 먼저 TopLevelWrapper의 인스턴스화가 먼저 일어나면서 트리를 렌더링 합니다.</li></ul><div class="alert info"><p>JSX를 작성해보셨다면, JSX 사용시 하나의 root 엘리먼트로 감싸주어야 한다는 사실을 알고있으실 텐데요. 그게 바로 TopLevelWrapper라고 생각하시면 될 것 같습니다.</p></div><ul><li><p>JSX는 내부 컴포넌트로 변환됨</p></li><li><p>내부 컴포넌트의 종류</p><ul><li>ReactCompositeComponent : 자체 컴포넌트 클래스</li><li>ReactDOMComponent : HTML 태그 클래스</li><li>ReactDOMTextComponent : text nodes 클래스</li></ul></li><li><p>Virtual DOM</p><ul><li>Virtual DOM은 리엑트가 diff 중에 DOM을 직접 건드리지 않는데 사용되는 DOM 표현의 일종.(개념)</li><li>Virtual DOM은 위 3개의 내부 컴포넌트를 참조.</li></ul></li></ul><div class="alert info"><p>마운트라는 개념을 잘 생각해보고, 내부 컴포넌트의 종류 잘 기억하는게 좋은것 같습니다. </p></div><hr><h3 id="파트-1"><a href="#파트-1" class="headerlink" title="파트 1"></a>파트 1</h3><h4 id="Transaction-1"><a href="#Transaction-1" class="headerlink" title="Transaction(1)"></a>Transaction(1)</h4><ul><li><p><code>ReactUpdates</code>모듈을 통해 컴포넌트 인스턴스가 리엑트 생태계에 연결 되도록 합니다.</p></li><li><p>리엑트는 chunks 형태로 업데이트를 수행하기 때문에 사전/사후 처리를 한번만 적용할 수 있도록 트렌젝션을 활용합니다.</p></li><li><p>리엑트에서 트렌잭션이 어떻게 사용되고 있는지 말하고 있습니다.</p><ul><li><code>Transaction</code> 모듈에서 확장하여 사용되며, <strong>어떤 트렌잭션 래퍼로 감싸는지에 따라 목적이 달라집니다.</strong></li><li>래퍼는 기본적으로는 초기화 및 클로즈 메소드를 포함한 객체입니다.</li></ul></li><li><p><code>ReactDefaultBatchingStrategyTransaction</code>레퍼에는 ‘FLUSH_BATCHED_UPDATES’, ‘RESET_BATCHED_UPDATES’래퍼가 존재합니다.</p><ul><li>내부에서 <code>initialize</code> 메소드가 비어있지만, <code>close</code>에는 <code>ReactUpdates.flushBatchedUpdates</code>를 호출합니다.</li><li><code>ReactUpdates.flushBatchedUpdates</code>는 dirty 컴포넌트에 대한 검증을 시작합니다. (파트 8 이후)</li></ul></li></ul><div class="alert info"><p>해당 컴포넌트가 마운팅 되기전에 일련 작업들을 한번에 처리하기위해 <strong>트렌젝션</strong>을 사용해서 진행되고 있습니다.</p></div><hr><h3 id="파트-2"><a href="#파트-2" class="headerlink" title="파트 2"></a>파트 2</h3><h4 id="Transaction-2"><a href="#Transaction-2" class="headerlink" title="Transaction(2)"></a>Transaction(2)</h4><ul><li><p>파트 1의 트렌젝션에서의 메소드 실행부분에서 발생되는 또 다른 트렌잭션.</p></li><li><p>여기에서는 트랜젝션이 다음을 제어하는데 사용됩니다.</p><ul><li>현재 선택한 영역이 다른 영역들로부터 침범되지 않도록 합니다.</li><li>리플로우가 발생되는 정도의 DOM 조작 발생 가능성이 있는 이벤트를 제한합니다.</li><li>이런 과정을 <code>initialize</code> 할 때 제한하고, <code>close</code> 할때 사용하도록 설정합니다.</li></ul></li><li><p>파트 2의 메소드 실행시 <code>ReactReconciler.mountComponent</code>로 DOM에 넣을 준비가 된 마크업을 리턴합니다.</p></li></ul><div class="alert info"><p>랜더링을 위한 마크업을 만들기 전에 다른 영역에 영향을 미칠 수 있는 부분을 제한하는데 이를 <strong>트랜젝션</strong>을 활용하고 있다는 것을 알 수 있습니다.   </p></div><hr><h3 id="파트-3"><a href="#파트-3" class="headerlink" title="파트 3"></a>파트 3</h3><h4 id="Mount"><a href="#Mount" class="headerlink" title="Mount"></a>Mount</h4><ul><li><p>컴포넌트의 트리에 처음 삽입되는 컴포넌트는 TopLevelWrapper 입니다.</p><ul><li>이후에 자식의 자식들도 같은 방식으로 마운트 됩니다. </li></ul></li><li><p>ExampleApplication 컴포넌트에 대한 ReactCompositeComponent 인스턴스 생성(new ExampleApplication())</p><ul><li>생성자를 통해 인스턴스에 props, context, refs, updater가 할당됩니다.<br>(updater는 setState에 의해 사용됩니다.)</li></ul></li></ul><h4 id="초기-마운트-수행"><a href="#초기-마운트-수행" class="headerlink" title="초기 마운트 수행"></a>초기 마운트 수행</h4><ul><li><p>초기 마운트 수행</p><ul><li>componentWillMount가 호출됩니다.</li><li>updater가 할당되었기 때문에 componentWillMount안에서 setState를 사용할 수는 있습니다.<br>   하지만 render()전에 호출되기 때문에 컴포넌트가 아직 마운트 되지 않았기 때문에, state를 알 수 가 없어 state를 설정해도 리렌더링이 발생되지 않습니다.</li><li>componentDidMount 트랜젝션 큐에 넣어둡니다.(이후에 실행되기 때문에)     </li><li>render()가 호출됩니다.</li></ul></li><li><p>render 메소드에서 얻은 엘리먼트를 기반으로 그 자식에 대한 가상 컴포넌트(ReactDOMComponent 인스턴스)를 생성합니다.</p><ul><li>ReactReconciler.mountComponent() 호출합니다.</li></ul></li></ul><div class="alert info"><ul><li>코드랑 매칭 시켜서 이해해 볼 수 있는 첫번째 부분입니다. <code>constructor</code>, 라이프 사이클 메소드인 <code>componentWillMount</code>와 <code>componentDidMount</code>를 연결시켜 볼 수 있습니다.</li><li>컴포넌트의 인스턴스를 만들면서 ReactCompositeComponent(내부 컴포넌트)를 만들고, 그 자식의 인스턴스를 만들어 ReactDOMComponent(HTML 컴포넌트)까지 생성합니다.</li></ul></div><hr><h4 id="파트-4"><a href="#파트-4" class="headerlink" title="파트 4"></a>파트 4</h4><ul><li><p>HTML 태그에서 video, form, textarea의 경우에는 추가 래핑을 진행합니다.</p></li><li><p>내부 props가 올바르게 설정되었는지 확인하기 위해 유효성 검사 메서드를 호출합니다.</p></li><li><p>실제 HTML 엘리먼트는 document.createElement에 의해 생성됩니다.</p></li></ul><hr><h4 id="파트-5"><a href="#파트-5" class="headerlink" title="파트 5"></a>파트 5</h4><ul><li>이전 props와 새 props의 차이를 계산합니다.<ul><li>순서 : 스타일 업데이트 -&gt; 트랜잭션 패턴을 이용해 이벤트 처리 -&gt; attribute, property 업데이트</li></ul></li></ul><hr><h4 id="파트-6"><a href="#파트-6" class="headerlink" title="파트 6"></a>파트 6</h4><ul><li><p>자식 요소들을 관리하는 <code>ReactMultiChild</code> 모듈의 <code>mountChildren</code>메소드를 통해 자식요소들을 인스턴스화하고 마운팅합니다.</p></li><li><p>전반적인 마운팅 프로세스에 대한 전체적인 확인</p><ul><li>커스텀 컴포넌트 인스턴스 생성(<code>constructor</code> 호출)<br>-&gt; render 메소드 호출로 랜더링 진행 하고 <code>React.createElement</code>로 엘리먼트 생성<br>-&gt; 커스텀 컴포넌트가 리턴된 경우 ‘ReactCompositeComponent’로 인스턴스 화하고 HTML인 경우 <code>ReactDOMComponent</code>로 인스턴스화 함<br>-&gt; 반복하면서 DOM 엘리먼트가 생성되면 이벤트 리스너를 할당하면서 DOM 컴포넌트를 마운트합니다.<br>-&gt; 다음 자식들을 이어서 위의 동작들을 반복합니다.</li></ul></li></ul><hr><h3 id="파트-7"><a href="#파트-7" class="headerlink" title="파트 7"></a>파트 7</h3><ul><li><p>마운팅 메소드 실행의 결과로 document에 세팅할 준비가 된 HTML 엘리먼트를 가질 수 있었지만, 실제로는 HTML 마크업이 아닌, children, node(실제 DOM 노드)등의 필드를 가진 데이터 구조입니다.</p></li><li><p>parentNode.insertBefore로 인해 드디어 document에 엘리먼트가 추가됩니다.</p></li><li><p>아직 트렌젝션의 중간 단계이기 때문에 상위 두 단계의 트렌젝션을 모두 닫아줍니다(파트2).</p></li></ul><hr><p>여기까지가 마운팅 프로세스에 대한 일련의 과정입니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Under-the-hood-ReactJS를 읽어보면서 이해한 부분을 정리해보았습니다.&lt;br&gt;Intro ~ 파트7까지의 마운트 부분에 대한 설명이 있습니다.&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jae-kwang.github.io/blog/categories/js/"/>
    
      <category term="lib" scheme="https://jae-kwang.github.io/blog/categories/js/lib/"/>
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/categories/js/lib/react/"/>
    
    
      <category term="react" scheme="https://jae-kwang.github.io/blog/tags/react/"/>
    
      <category term="javascript" scheme="https://jae-kwang.github.io/blog/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Redux 코드로 이해하기</title>
    <link href="https://jae-kwang.github.io/blog/2017/06/21/redux-use/"/>
    <id>https://jae-kwang.github.io/blog/2017/06/21/redux-use/</id>
    <published>2017-06-20T23:17:00.000Z</published>
    <updated>2018-12-24T05:03:31.235Z</updated>
    
    <content type="html"><![CDATA[<h3 id="리덕스를-코드로-이해해보자"><a href="#리덕스를-코드로-이해해보자" class="headerlink" title="리덕스를 코드로 이해해보자"></a>리덕스를 코드로 이해해보자</h3><p>리엑트를 공부하다 보면 자연스럽게 리덕스를 접하게 됩니다.<br>리덕스를 이해하기 위해 많은 문서를 접하지만, 저 같은 경우에는 코드랑 연결이 되어 있을 때 가장 잘 이해하는 것 같습니다. 그래서 코드로 리덕스를 접근해보려고 합니다.</p><a id="more"></a><h3 id="리덕스의-단어들"><a href="#리덕스의-단어들" class="headerlink" title="리덕스의 단어들"></a>리덕스의 단어들</h3><p>“리덕스는 뭐다.”라는 부분은 많은 문서에서 잘 정리되어 있고, 저 또한 그런 곳을 많이 참조하여 읽습니다.<br>그래서 저는 제가 이해한 만큼에서 직접 사용되는 리덕스의 단어들을 코드로써 이야기해 보려고 합니다.</p><h4 id="1-스토어-Store"><a href="#1-스토어-Store" class="headerlink" title="1. 스토어(Store)"></a>1. 스토어(Store)</h4><p>가장 먼저 스토어 입니다. 스토어는 리덕스를 처음 접하자마자 들을 수 있는 단어로 <strong>state(상태 값)</strong>총괄하는 부분입니다. state는 각 컴포넌트가 갖는 특정한 값일 수도 있으며, UI의 상태를 나타낼 수 있습니다.</p><figure class="highlight javascript"><figcaption><span>스토어 형태</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">    color: <span class="string">'black'</span>,</span><br><span class="line">    number: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컴포넌트들은 이 스토어에 액션을 dispatch하고, subscribe 하며 상태를 반영할 수 있습니다.<br>액션, dispatch는 천천히 알아보도록 하죠. </p><h4 id="2-액션-action"><a href="#2-액션-action" class="headerlink" title="2. 액션(action)"></a>2. 액션(action)</h4><p>스토어에 대한 값을 변경하기 위해서 어떤 신호를 보내주어야 하는데 바로 그게 바로 액션입니다.</p><p>예를 들어 컴포넌트에서 어떤 이벤트가 발생한 경우 컴포넌트가 “이벤트가 발생했어! 값을 변화시켜줘!”라고 말하는 상태에 대한 변경 값이 들어 있습니다.</p><p>액션은 무엇이냐? 그냥 객체입니다.<br>다만, 한가지 알아두어야 하는 건 모든 액션객체는 <strong>‘type’</strong>이라는 값을 지닙니다.<br><figure class="highlight javascript"><figcaption><span>액션 형태</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">"INCREMENT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>추가로 이벤트 발생 후 변경할 값을 같이 전달해 주려면 아래와 같이 단순히 값을 추가하면 됩니다.</p><figure class="highlight javascript"><figcaption><span>액션 + 값 추가</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: <span class="string">"SET_COLOR"</span>,</span><br><span class="line">    color: <span class="string">"black"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-리듀서-reducers"><a href="#3-리듀서-reducers" class="headerlink" title="3. 리듀서(reducers)"></a>3. 리듀서(reducers)</h4><p>리듀서는 액션을 받아서 스토어의 값을 처리하는 작업을 해줍니다.<br>사실, 스토어는 그냥 저장소일 뿐 아무것도 하지 않습니다. 이 리듀서가 바리바리 움직여서 스토어의 값을 변화시켜줍니다.</p><p>그럼 코드로서는 어떨까요? 리듀서는 스토어의 값을 변형시켜준다고 했습니다.<br>위에서 언급된 것처럼 스토어는 값을 담은 객체일 뿐이고 리듀서는 그 값을 변경한다고 했으니 스토어라는 객체의 값을 변경시켜주는 함수일 뿐이죠.</p><p>대신 액션을 받아서 어떤 값인지 판단해서 어떻게 변경해줘야 할지 분기해야 햐죠.<br>그럼 그 부분을 코드로 작성해보면 아래와 같이 됩니다.</p><figure class="highlight javascript"><figcaption><span>스토어 + 리듀서</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 스토어</span></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">    color: <span class="string">'black'</span>,</span><br><span class="line">    number: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 리듀서</span></span><br><span class="line"><span class="comment">// 1. state에 store로 설정한 값을 초기값으로 넣습니다.(처음 스토어가 생성됩니다.)</span></span><br><span class="line"><span class="comment">// 2. action에는 지정한 action 객체가 들어옵니다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exampleReducers</span>(<span class="params">state = initState, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> types.INCREMENT: </span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                number: state.number + <span class="number">1</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> types.SET_COLOR:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                color: action.color</span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> exampleReducers;</span><br></pre></td></tr></table></figure><h3 id="4-액션-생성자-Action-Creator"><a href="#4-액션-생성자-Action-Creator" class="headerlink" title="4. 액션 생성자(Action Creator)"></a>4. 액션 생성자(Action Creator)</h3><p>사실 액션 설명할 때 액션 생성자를 같이 설명하는데, 리듀서 다음에 나온 이유는 제가 이해한 흐름대로 나열하기 때문이죠.</p><p>처음 예제들을 참고하며 공부했을 때 혼동이 있었던 부분이었습니다.<br>액션을 리듀서에 전달할 때 “액션 타입을 지정하는 파일(ActionTypes.js)을 만들고, 액션 생성자를 통해서, 리듀서로 전달한다.”라는 말이 직관적으로 머리에 들어오지 않았습니다.</p><p>그래서 저는 저 나름대로 이해를 했습니다.</p><blockquote><p>Q. 액션 생성자를 만드는 이유.<br>A. 매번 객체(액션 객체)를 만들기 귀찮아서.</p></blockquote><blockquote><p>Q. ActionTypes.js란 파일을 만드는 이유.<br>A. 매번 문자열로 전달하면 귀찮아서.</p></blockquote><h3 id="5-디스패치-dispatch"><a href="#5-디스패치-dispatch" class="headerlink" title="5. 디스패치(dispatch)"></a>5. 디스패치(dispatch)</h3><p>액션 생성자와 디스패치의 설명 순서는 좀 애매했습니다.<br>액션 생성자를 설명할 때 “귀찮다”가 언제 인지를 알아야 사용의 편리함을 아니까요.</p><p>바로 디스패치를 통해 액션을 전달할 때 귀찮습니다.</p><p>이 단락에 액션 생성자 코드를 넣는 건 이상하지만 흐름으로는 이게 맞아 보여서 여기에 쓰겠습니다.<br>정말 이름 그대로 액션이란 객체를 만들어주는 객체(액션) 생성자일 뿐입니다.</p><figure class="highlight javascript"><figcaption><span>액션생성자</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// () =&gt; (&#123;&#125;) 은, function() &#123; return &#123; &#125; &#125; 와 동일한 의미</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    type: types.INCREMENT</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>디스패치는 컴포넌트에서 특정한 이벤트 발동 시 실행이 됩니다.<br>디스패치는 액션(객체)을 스토어로 넘겨주는 이벤트 트리거라고 생각하면 될 것 같습니다.</p><figure class="highlight javascript"><figcaption><span>컴포넌트</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'../actions'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> (&#123;</span><br><span class="line">    onIncrement: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(actions.increment()),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>onIncrement()가 실행되면 actions.increment()란 액션 생성자를 통해 액션객체를 생성하고 그 액션객체를 dispatch로 리듀서에 전달되는 겁니다.</p><h3 id="6-react-redux"><a href="#6-react-redux" class="headerlink" title="6. react-redux"></a>6. react-redux</h3><p>그렇다면 이 모든 과정에서 어떻게 액션객체를 컴포넌트에서 스토어로 스토어에서 컴포넌트로 공유가 될 수 있을까요? 바로 ‘react-redux’ 가 해줍니다.</p><h4 id="6-1-Provider"><a href="#6-1-Provider" class="headerlink" title="6-1. Provider"></a>6-1. Provider</h4><p>redux 에서 store는 단 하나입니다. 그렇다면 이게 어디