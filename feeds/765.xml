<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NonBlock</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.javarouka.me/"/>
  <updated>2019-05-06T07:39:51.140Z</updated>
  <id>https://blog.javarouka.me/</id>
  
  <author>
    <name>JavaRouka</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[책] Elasticsearch In Action</title>
    <link href="https://blog.javarouka.me/2019/04/07/book-elasticsearch-in-action/"/>
    <id>https://blog.javarouka.me/2019/04/07/book-elasticsearch-in-action/</id>
    <published>2019-04-06T15:00:00.000Z</published>
    <updated>2019-05-06T07:39:51.140Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br><img src="http://acornpub.co.kr/tb/detail/book/ej/lq/1477017264mU57qQOe.jpg" alt="엘라스틱 인 "><br></p><p>최근 엘라스틱서치를 좀 써보고 깊이 공부해야 할 필요성이 있어 인액션 시리즈를 구매해서 부록을 제외한 파트를 다 읽었다. 이런 두꺼운 책은 오랜만인것 같다.</p><p>읽으면서 많이 아쉬웠던건 예제나 설명이 구 버전에 맞춰져 있었고, 샘플 색인 데이터 스크립트는 Mac 에서 오동작했다 (스크립트 안의 curl 명령어를 조금 수정해줘야 색인할 수 있다)</p><p>번역의 품질은 번역서에서는 매우 중요한데 이 책은 번역 품질은 아쉽게도 그리 훌륭하지 않다.</p><p>용어 번역 그런 문제가 아니다.<br>그냥 번역문이 매끄럽지가 못해서 같은 부분을 반복해서 읽어야 이해가 된다 (머리속에 더 잘남으려나;) 오탈자도 많다;</p><p>하지만 이런 단점에도 내용 자체가 깊이있고 훌륭하다.</p><p>상당히 괜찮은 책.</p>]]></content>
    
    <summary type="html">
    
      책 리뷰.
    
    </summary>
    
      <category term="book" scheme="https://blog.javarouka.me/categories/book/"/>
    
    
      <category term="db" scheme="https://blog.javarouka.me/tags/db/"/>
    
      <category term="book" scheme="https://blog.javarouka.me/tags/book/"/>
    
      <category term="elasticsearch" scheme="https://blog.javarouka.me/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Java / Kotlin 의 상속과 구성 (Inheritance &amp; Composition) #1</title>
    <link href="https://blog.javarouka.me/2019/04/07/interits-conposition/"/>
    <id>https://blog.javarouka.me/2019/04/07/interits-conposition/</id>
    <published>2019-04-06T15:00:00.000Z</published>
    <updated>2019-04-16T12:51:48.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="자바의-상속"><a href="#자바의-상속" class="headerlink" title="자바의 상속"></a>자바의 상속</h1><p>객체지향언어에서의 상속은 객체간의 관계를 언어레벨에서 정의하는 방법이다.</p><p>상속은 <a href="https://ko.wikipedia.org/wiki/시뮬라" rel="external nofollow noopener noreferrer" target="_blank">Simula</a> 라는 언어의 객체지향적 부분에서 발전했다고 알려져 있다. C++ 개발자인 <a href="https://ko.wikipedia.org/wiki/비야네_스트롭스트룹" rel="external nofollow noopener noreferrer" target="_blank">비야네 스트로스트롭</a>이나 Java 개발자인 <a href="https://ko.wikipedia.org/wiki/제임스_고슬링" rel="external nofollow noopener noreferrer" target="_blank">제임스 고슬링</a>도 Simula 에서 언어 개발에 상당한 아이디어를 얻었다고.</p><p>Java 의 상속은 다음과 같은 성격을 지닌다</p><h2 id="수퍼-서브클래스"><a href="#수퍼-서브클래스" class="headerlink" title="수퍼/서브클래스"></a>수퍼/서브클래스</h2><p>어떤 클래스 B 가 다른 클래스 A 를 상속할 때 A를 수퍼클래스, B 를 서브클래스라고 한다. 간혹 수퍼타입/서브타입으로도 부르기도 하는데 다소 다른 의미다.</p><p>아래 코드에서 <code>Truck</code> 은 <code>Car</code> 의 서브클래스이기 때문에 자동차가게(CarStore) 에 <code>Truck</code> 을 둘 수 있다. 하지만 <code>Ship</code> 은 둘 수 없다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ship</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Truck</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarStore</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Car&gt; carList = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        carList.add(car);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        CarStore shop = <span class="keyword">new</span> CarStore();</span><br><span class="line">        shop.put(<span class="keyword">new</span> Car());</span><br><span class="line">        shop.put(<span class="keyword">new</span> Truck());</span><br><span class="line">        shop.put(<span class="keyword">new</span> Ship()); <span class="comment">// 컴파일 에러. 배는 차가 아니다.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>상속관계인 클래스 <code>Car</code> 와 <code>Truck</code> 은 서로 각자의 타입이면서 클래스이다.</p><p>타입과 클래스는 다르다. <em>하나의 클래스는 대부분 두가지 이상의 타입으로 표현</em> 될 수 있기 때문이다.</p><h2 id="타입과-클래스"><a href="#타입과-클래스" class="headerlink" title="타입과 클래스"></a>타입과 클래스</h2><p><code>Truck</code>의 인스턴스는 <code>Truck</code> 와 <code>Car</code> 타입이 될 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">Truck truck = <span class="keyword">new</span> Truck();</span><br><span class="line">Car truckCar = truck; <span class="comment">// 가능하다.</span></span><br><span class="line">Object obj = truck; <span class="comment">// 가능하다.</span></span><br></pre></td></tr></table></figure><p>Java 의 모든 클래스는 Object 를 상속하므로, Object 타입으로도 표현할 수 있다.</p><p>게다가 제네릭 클래스는 타입 인자에 따라 수많은 타입을 만들어낼 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; objs = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">ArrayList&lt;Car&gt; cars = <span class="keyword">new</span> ArrayList&lt;Car&gt;();</span><br><span class="line">ArrayList&lt;Truck&gt; trucks = <span class="keyword">new</span> ArrayList&lt;Truck&gt;();</span><br></pre></td></tr></table></figure><p>다음과 같이 정리할 수 있겠다.</p><ul><li>클래스는 구현 지향적이다. 내부 상태와 할 수 있는 연산이 구현되어 수행하는 자료구조에 가깝다.</li><li>타입은 선언 지향적이다. 특정 객체가 수행할 수 있는 일의 제한을 지정한다.</li></ul><p align="center"><br><img src="/asset/images/truck.jpg" alt="트럭"><em>아마존 트럭. 트럭이고 차이고 기계이다.</em><br></p><h2 id="타입-관계"><a href="#타입-관계" class="headerlink" title="타입 관계"></a>타입 관계</h2><p>서브타입은 수퍼타입의 변수에 할당할 수 있다. 서브타입은 수퍼타입의 모든 기능을 상속받았고 수퍼타입이 할 수 있는 모든 일을 할 수 있으므로, 수퍼 타입이 할 수 있는 모든 기능이 문제없이 동작가능하게 구현되어야 한다. <a href="https://blog.javarouka.me/2018/11/27/object-equals-liskov/#%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EB%B2%95%EC%B9%99">리스코프 치환 원칙</a> 으로도 부른다.</p><p>이러한 타입 관계에서는 <code>변성(variance)</code> 이라는 성질이 존재한다.</p><p>메서드의 인자로 전달된 객체의 상태가 변할땐 자신의 타입을 포함한 수퍼타입으로 제한되고, 특정 객체를 반환할 경우 반환형은 자신의 서브타입으로 제한된다.</p><ol><li>특정 메서드에게 걸그룹을 인자로 전달하려면 특정 메서드의 선언은 걸그룹이거나 걸그룹의 수퍼타입(가수, 사람, 동물 …)이어야 한다.</li><li>특정 메서드에서 걸그룹을 반환할 경우 그 반환값은 걸그룹이거나 걸그룹의 서브타입(트와이스, 소녀시대 …)이어야 한다.</li></ol><p>좀더 유식하게 표현하면 1번의 경우를 <a href="https://medium.com/@lazysoul/%EA%B3%B5%EB%B3%80%EA%B3%BC-%EB%B6%88%EB%B3%80-297cadba191" rel="external nofollow noopener noreferrer" target="_blank">반공변적</a>이라고 하고 2번의 경우를 <a href="https://edykim.com/ko/post/what-is-coercion-and-anticommunism/" rel="external nofollow noopener noreferrer" target="_blank">공변적</a>이라고 한다.</p><p align="center"><br><img src="/asset/peoples/twice.jpg" alt="트와이스"><em>트와이스는 걸그룹이지만 소녀시대는 아니다.</em><br></p><p>가요무대 클래스의 멤버 메서드가 노래를 부를 가수 타입이 필요하다면 걸그룹 인자에 대해 반공변적이라고 할 수 있다.</p><p>보이그룹이나 솔로가수도 갈 수 있다.</p><p>하지만 걸그룹 어워드 클래스 메서드에서 특정 걸그룹중 1위를 반환한다고 하면 반환시에는 트와이스나 시스타, 소녀시대만으로 제한된다.</p><p>이때는 인자에 대해 공변적이다.</p><h3 id="제네릭은-항상-서로-다르다"><a href="#제네릭은-항상-서로-다르다" class="headerlink" title="제네릭은 항상 서로 다르다"></a>제네릭은 항상 서로 다르다</h3><p>제네릭을 처음 공부할때 다소 혼란스러운 부분이 제네릭 파라미터가 수퍼/서브타입의 관계일 경우 제네릭 클래스도 수퍼/서브타입이 성립할거라는 착각이다.</p><p>다음 코드는 컴파일 오류이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 호환되지 않는 타입. 컴파일 오류가 발생한다.</span></span><br><span class="line">ArrayList&lt;Car&gt; cars = <span class="keyword">new</span> ArrayList&lt;Truck&gt;();</span><br></pre></td></tr></table></figure><p>제네릭 타입은 다른 모든 제네릭 타입과 수퍼/서브타입이 성립하지 않는다. 제네릭 파라미터화 타입이 서로 어떤 관계이든 항상 다른 타입이다.</p><p>이것을 유식한 단어로 <code>불공변(invariant)</code> 이리고 한다.</p><h3 id="하지만-배열은-이상하다"><a href="#하지만-배열은-이상하다" class="headerlink" title="하지만 배열은 이상하다."></a>하지만 배열은 이상하다.</h3><p>배열은 위의 성질과 다르게 공변관계를 허용한다. 그래서 다음 코드는 문제가 없다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car[] cars = <span class="keyword">new</span> Truck[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>문제는 위의 배열에 다음과 같은 코드를 실행할 때다. <code>ArrayStoreException</code> 이 발생하는데, 컴파일 타임이 아닌 런타임에 발생한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayStoreException</span></span><br><span class="line">cars[<span class="number">0</span>] = <span class="keyword">new</span> Taxi();</span><br></pre></td></tr></table></figure><p>배열은 제네릭과 다르게 런타임 시에도 타입이 소거되지 않고 유지하기 때문이다. 런타임 시 이 소거되지 않은 타입을 검사하며 오류를 출력한다.</p><p>배열의 이러한 공변성으로 인해 타입관련 잠재적인 런타임 오류가 발생할 수 있다. 이런 오류에 대해서는 컴파일러가 대부분은 경고를 해 주므로, 컴파일 시의 워닝 메시지를 무시하지 말자.</p><h3 id="와일드카드-변성"><a href="#와일드카드-변성" class="headerlink" title="와일드카드 변성"></a>와일드카드 변성</h3><p>Java 에서는 배열의 제네릭 파라미터일 경우 이 관계를 와일드카드와 함께 써서 <code>PECS (Producer-extends, Consumer-super)</code> 로 정의한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 공변 제네릭 리스트</span></span><br><span class="line">List&lt;? extends GirlGroupSinger&gt; girlGroups1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이 문은 컴파일 오류이다. 이 값이 어떤 값인지 특정지을 수 없다.</span></span><br><span class="line">girlGroups1.add(<span class="keyword">new</span> Twice());</span><br><span class="line">girlGroups1.add(<span class="keyword">new</span> Sistar());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 걸그룹임이 보장된다.</span></span><br><span class="line">GirlGroupSinger some = girlGroups.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 반공변 제네릭 리스트</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> GirlGroupSinger&gt; girlGroups2 = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 걸그룹의 수퍼타입이면 뭐든 입력할 수 있다</span></span><br><span class="line">girlGroups1.add(<span class="keyword">new</span> People());</span><br><span class="line">girlGroups1.add(<span class="keyword">new</span> Animal());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이 문은 컴파일 오류이다. 이 타입이 무엇인지 특정지을 수 없다.</span></span><br><span class="line">GirlGroupSinger some = girlGroups.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>여기서 Producer 와 Consumer 의 주체는 제네릭 타입의 인자이다.</p><p>extends 일 경우 인자가 값을 생산 (get) 한다는 의미이며 super 일 경우 인자가 값을 소비(set) 한다는 의미이다.</p><blockquote><p>이 주제와 관련해서 좋은 StackOverflow 링크가 있다. <a href="https://bit.ly/2GdGEUh" rel="external nofollow noopener noreferrer" target="_blank">https://bit.ly/2GdGEUh</a></p></blockquote><h2 id="자동-선언"><a href="#자동-선언" class="headerlink" title="자동 선언"></a>자동 선언</h2><p>서브클래스는 수퍼클래스의 인스턴스 변수와 멤버 메서드들을 자동으로 상속한다.</p><p>상속한다는 뜻은 서브클래스에서 별도로 정의하지 않아도 정의된 것처럼 별도 선언 없이 사용할 수 있다.</p><p><em>인스턴스 변수</em>, <em>멤버 메서드</em> 라고 명시적으로 말한 건 static 으로 정의된 변수와 메서드는 제외되기 때문이다.</p><p>수퍼클래스에 대한 접근은 <code>super</code> 키워드를 사용한다.</p><p>super 키워드는 사용처에 따라 다른 대상을 가르킨다.</p><ul><li>생성자에서 사용되는 <code>super</code> 는 <em>생성자 함수</em> 를 가르킨다. 호출하는 함수 형태이다.</li><li>멤버 함수에서의 <code>super</code> 는 <em>인스턴스</em> 를 가르킨다. 부모 인스턴스를 레퍼런스하는 변수처럼 동작한다.</li></ul><h2 id="접근제어"><a href="#접근제어" class="headerlink" title="접근제어"></a>접근제어</h2><p>상속에 몇가지 제약을 걸 수 있는 접근제어자가 있다.</p><p>Java 를 처음 학습할때 접하는 <code>private</code>, <code>protected</code>, <code>public</code> 이고 별도로 정의하지 않으면 <code>default</code> 접근제어가 적용된다.</p><p>보통 좋은 프로그램 코딩 가이드에서는 제한적인 접근을 먼저 적용하고 필요에 따라 넓혀가라고 조언된다. <code>private</code> 으로 전부 선언한 뒤, 필요에 따라 <code>protected</code> 혹은 <code>public</code> 으로 넓혀가는게 좋다.</p><p>애매한 건 <code>default</code> 접근 제어인데 이 케이스는 일반적인 케이스의 경우 잘 사용되지 않지만, 구현체를 직접적으로 사용하지 못하게 할때 유용하게 쓸 수 있다.</p><p>만일 같은 패키지에 <code>UserInputController</code> 클래스와 <code>UserInputController</code> 을 상속한 <code>Mouse</code> 클래스, <code>Keyboard</code> 클래스가 있다고 할 때 타 패키지에서는 <code>UserInputController</code> 으로만 추상적으로 접근하게 하고 싶다면 다음과 같이 구현하면 된다.</p><p>구현 클래스에는 public 접근제어 없이 default 로 선언했다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file UserInputController.java</span></span><br><span class="line"><span class="keyword">package</span> me.javarouka.input;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInputController</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @file Mouse.java</span></span><br><span class="line"><span class="keyword">package</span> me.javarouka.input;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">UserInputController</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @file Keyboard.java</span></span><br><span class="line"><span class="keyword">package</span> me.javarouka.input;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Keyboard</span> <span class="keyword">implements</span> <span class="title">UserInputController</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>외부에서는 클래스를 생성하지 못한다.</p><p><em>private 생성자</em> 로도 이런 방법을 쓸 수 있지만, DI 프레임워크(Spring Framework 가 대중적이다.) 등을 쓰고 있다면 이 방법이 유용할 것이다.</p><p>DI 프레임워크 등이 없다면 팩토리 클래스 같은 생성 헬퍼를 만들어줘야 할 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.javarouka.input;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInputControllers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserInputController <span class="title">createMouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Mouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserInputController <span class="title">createKeyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Keyboard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실제 구현 클래스의 노출 없이 구현 클래스 타입을 제공하여 불필요한 정보 공개를 하지 않고 안전성을 높일 수 있다.</p><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>다음 포스트에서는 상속의 단점과 구성에 대해 알아보겠다. 그리고 코틀린에서 이런 상속 관계들을 어떻게 처리하는지 알아본다</p>]]></content>
    
    <summary type="html">
    
      자바의 상속과 클래스, 타입
    
    </summary>
    
      <category term="java" scheme="https://blog.javarouka.me/categories/java/"/>
    
      <category term="kotlin" scheme="https://blog.javarouka.me/categories/java/kotlin/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="kotlin" scheme="https://blog.javarouka.me/tags/kotlin/"/>
    
      <category term="composition" scheme="https://blog.javarouka.me/tags/composition/"/>
    
      <category term="type" scheme="https://blog.javarouka.me/tags/type/"/>
    
      <category term="class" scheme="https://blog.javarouka.me/tags/class/"/>
    
      <category term="delegate" scheme="https://blog.javarouka.me/tags/delegate/"/>
    
  </entry>
  
  <entry>
    <title>Redux-Saga 소개</title>
    <link href="https://blog.javarouka.me/2019/04/02/redux-saga-1/"/>
    <id>https://blog.javarouka.me/2019/04/02/redux-saga-1/</id>
    <published>2019-04-01T15:00:00.000Z</published>
    <updated>2019-04-07T12:13:32.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redux-와-부수효과"><a href="#Redux-와-부수효과" class="headerlink" title="Redux 와 부수효과"></a>Redux 와 부수효과</h2><p>Redux 는 상태 관리를 도와주는 간단한 라이브러리이다. 실제로도 소스코드 용량은 매우 작고, 해주는 일도 매우 단순하다.</p><h3 id="Redux-복습"><a href="#Redux-복습" class="headerlink" title="Redux 복습"></a>Redux 복습</h3><p>Redux 를 다들 잘 알겠지만 복습해보자.</p><ul><li>스토어</li><li>액션</li><li>리듀서</li></ul><p>Redux 는 자신이 관리하는 데이터 모음인 <code>상태(state)</code> 를 <code>스토어(Store)</code> 라는 저장소에 두고 이 상태를 변경할 수 있는 것은 <code>액션(action)</code> 으로 제한한다.</p><p>액션은 단순한 문자열이며 이 액션으로 상태를 변경하기 위해서는 <code>스토어(Store)</code> 에 <code>디스패치(dispatch)</code> 하는 행위가 필요하다.</p><p><code>디스패치(dispatch)</code> 할 때 전달할 정보는 다음과 같은 인터페이스를 가지는 일반 자바스크립트 객체이다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReduxDispatchAction &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="built_in">string</span>, <span class="comment">// required 액션은 반드시 문자열이어야 한다.</span></span><br><span class="line">    [prop:<span class="built_in">any</span>]?: <span class="built_in">any</span> <span class="comment">// optional N. 나머지는 옵셔널이며 객체에 할당할 수 있는 모든 키/값이 올 수 있다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>디스패치 함수는 스토어가 가지고 있고, 시그니쳐는 다음과 같다</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReduxStore &#123;</span><br><span class="line"></span><br><span class="line">    dispatch(action: ReduxDispatchAction) =&gt; <span class="built_in">void</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 스토어 기타 함수, subscribe 등</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실제 사용 코드는 다음과 같다.</p><p><code>doAmazingShow</code> 라는 액션을 payload 속성과 같이 디스패치하는 코드다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열 액션</span></span><br><span class="line"><span class="keyword">const</span> doAmazingShow = <span class="string">'doAmazingShow'</span></span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">    action: doAmazingShow,</span><br><span class="line">    payload: &#123;</span><br><span class="line">        invited: [ <span class="string">'Cool'</span>, <span class="string">'Hot'</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>디스패치의 결과로 <code>reducer</code>가 실행된다. <code>reducer</code> 는 모든 액션이 디스패치 될 때마다 액션과 현재 상태를 받는 단순한 함수다.</p><p>reducer 의 시그니처는 다음과 같다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Reducer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param currentState 현재 상태</span></span><br><span class="line"><span class="comment">     * @param action 디스패치를 통해 전달된 액션</span></span><br><span class="line"><span class="comment">     * @return 새로운 상태 객체</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    (currentState): object, action: ReduxDispatchAction) =&gt; object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 흐름은 한번의 실행 스택으로 수행되는데, 이 뜻은 다수의 액션 수행을 해도 그 순서를 보장한다는 뜻이다. 스크립트의 동작이 원래 그렇듯이 말이다.</p><p>여기까지가 Redux 의 간단한 흐름이다. 더 자세한 설명을 원하면 <a href="https://lunit.gitbook.io/redux-in-korean/" rel="external nofollow noopener noreferrer" target="_blank">공식 사이트</a>를 보자.</p><blockquote><p>Reducer 라는 네이밍은 Redux 제작자의 네이밍인데, 개인적으로는 액션처리기 같은 직관적 네이밍이 어땠을까 한다. 그럼 Redux 가 아니라 Execer 가 되었을지도 모르겠다. 그렇지만 액션을 누적해 하나의 상태로 처리하는 <code>reduce</code> 측면에서는 원래 이름인 Redux 가 더 어울린다.</p></blockquote><h3 id="Side-Effect"><a href="#Side-Effect" class="headerlink" title="Side Effect"></a>Side Effect</h3><p>실무에서 Redux 를 쓰다보면 액션이 동시다발적으로 발생되며, 액션 중간에 실제 Redux 액션이 아닌 일반 로직이 수행되거나 Ajax Call 등의 서버 리퀘스트도 발생한다. 그 와중에 여러 액션의 실행 보장도 해줘야 하는데, 자칫 코드가 상당히 난해해질 수 있다.</p><p>이럴때 사용을 고려해볼만한 라이브러리들이 몇개 있는대 대표적으로 Redux-Saga, Rx-Observable, MobX 등이다.</p><p>Redux-Saga 나 Rx-Observable 등을 Redux 와 같이 사용할때 이점으로 보통 비동기 처리가 손쉽다…라는 문구로 광고가 보통 되지만, 구조화된 Redux 설계를 했다면 비동기 처리도 그렇게 더러워지진 않는다. (다시 말하면 설계가 좋지 않다면 유지보수가 힘든 스파게티가 나온다는 뜻이다)</p><p>사실 단순 비동기 처리보다 더 큰 어려움은 액션이 여러 의미를 가지게 되고 그에 맞춰 기능이 확장되면서 액션이 다른 액션과 체이닝되기 시작할 때이다.</p><p>이런 기능들을 기존의 Redux 로 일일해 대응하다보면 코드가 순식간에 누더기가 된다. 순진하게 액션 처리 후 다른액션, 그리고 그 액션 성공 후 다른 액션… 으로 이어지는 코드는 대부분 스파게티맛을 맛본다.</p><p>예를 들어 회원 정보 페이지가 있다고 해보자. 다음은 액션을 디스패치하는 코드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadUser = <span class="keyword">async</span> (&#123; userId &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'START_USER_LOADING'</span> &#125;)</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> Users.loadUser(userId)</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">'END_USER_LOADING'</span>,</span><br><span class="line">            payload: user</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">'FAIL_USER_LOADING'</span>,</span><br><span class="line">            payload: error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 앱에 새로운 기능이 추가되어 유저 로딩 후 사용자의 팔로워를 같이 로딩해야 한다고 해보자.</p><p>코드는 다음과 같이 변경할 수 있다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadFollowersFrom = <span class="keyword">async</span> (&#123; userId &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'START_FOLLOWER_LOADING'</span> &#125;)</span><br><span class="line">        <span class="keyword">const</span> followers = <span class="keyword">await</span> Users.loadFollowersFrom(userId);</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">'END_FOLLOWER_LOADING'</span>,</span><br><span class="line">            payload: user</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">'FAIL_FOLLOWER_LOADING'</span>,</span><br><span class="line">            payload: error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loadUser = <span class="keyword">async</span> (&#123; userId &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'START_USER_LOADING'</span> &#125;)</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> Users.loadUser(userId)</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">'END_USER_LOADING'</span>,</span><br><span class="line">            payload: user</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 이 부분이 추가되었다. 유저 정보 로딩 후 실행한다.</span></span><br><span class="line">        loadFollowersFrom()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">'FAIL_USER_LOADING'</span>,</span><br><span class="line">            payload: error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>별로 나빠보이지 않는다. 그러나 이 코드는 앞으로의 코드 변경에 꽤나 힘들어질 수 있는 스타트를 끊은 코드다.</p><p>지금은 유저 정보 로딩 후 팔로워 로딩만 추가했지만 앞으로 이후 수많은 유저 관련 정보가 로딩될 수 있다.</p><p>예를 들면 추가적으로 유저 정보 로딩 후, 그 정보의 유무에 따라 현금성 결제 포인트와 이 유저를 방문한 유저를 로딩해야 할 수 있다. 그리고 사용성 트래킹을 위해 로그를 서버에 전송할 수도 있다.</p><p>그 호출 책임은 전부 <code>loadUser</code> 라는 함수가 담당하고 있다.</p><p>원래의 목적은 유저를 로딩한다는 목적으로 만들었지만, 이제는 유저도 로딩하고, 포인트도 로딩하고, 팔로워도 로딩하고 … 하는 함수가 되었다. 이쯤되면 이름을 <code>loadUserThenFollowers</code> 같은 이름으로 바꿔야 할지도 모르겠다.</p><p>더욱 힘들게 하는 건 만일 유저 정보 로딩 후 실행되는 부수 액션들(팔로워, 포인트…) 중 하나가 오류가 났을 때 각 부수 액션들끼리도 서로 영향을 줄 수 있다. 만일 비즈니스적으로 어떤 액션은 주변의 오류와 상관없이 진행해야 할 수도 있고 중단해야 할 수도 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loadUser = <span class="keyword">async</span> (&#123; userId &#125;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'START_USER_LOADING'</span> &#125;)</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> Users.loadUser(userId)</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">'END_USER_LOADING'</span>,</span><br><span class="line">            payload: user</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FIXME 거슬리는 부분 1</span></span><br><span class="line">        <span class="comment">// 비즈니스에 따라 처리해야 할 로직이 직접적으로 박힌다.</span></span><br><span class="line">        <span class="comment">// 이쯤 되면 함수 이름을 loadUser 가 아닌 다른걸로 바꾸는 걸 정말로 고려하는게 좋겠다.</span></span><br><span class="line">        <span class="keyword">await</span> loadFollowersFrom(userId)</span><br><span class="line">        <span class="keyword">await</span> loadPoint(userId)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        store.dispatch(&#123;</span><br><span class="line">            type: <span class="string">'FAIL_USER_LOADING'</span>,</span><br><span class="line">            payload: error</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// FIXME 거슬리는 부분 2</span></span><br><span class="line">        <span class="comment">// 오류 여부에 관계없이 실행해야 한다.</span></span><br><span class="line">        <span class="keyword">await</span> writeUserActionLogging(userId)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이러한 본래 액션 말고도 그 액션에 따라 다른 액션이나 이벤트가 파생되는건 꽤나 흔한 일이다.</p><p>이런 일을 <code>부수효과 (Side-Effect)</code> 라고 한다.</p><ul><li>Ajax 콜</li><li>비동기 타이머</li><li>애니메이션 후 콜백</li><li>요청 중 취소</li><li>스로틀링</li><li>디바운싱</li><li>페이지 이동</li></ul><p>이러한 것은 일반적인 Redux의 액션 흐름으로는 나타내기가 조금 어렵고, 비동기 수행시에는 어디엔가 dispatch 함수의 레퍼런스를 가지고 있다가 필요할때에 호출하면서 수행해야 한다.</p><p>이러한 부수 효과들은 Redux-Saga 를 쓴다면 꽤 단순하고 직관적으로 풀어낼 수 있다.</p><h3 id="Redux-Saga-적용"><a href="#Redux-Saga-적용" class="headerlink" title="Redux Saga 적용"></a>Redux Saga 적용</h3><p>다음은 Redux-Saga 로 위의 문제를 다시 작성해본 코드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 유저 현금성 포인트를 로딩한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> loadPoint = <span class="function"><span class="keyword">function</span>* (<span class="params">&#123; userId &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> followers = <span class="keyword">yield</span> call(Point.load, userId);</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'END_USER_POINT_LOADING'</span>, <span class="attr">payload</span>: user &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'FAIL_USER_POINT_LOADING'</span>, <span class="attr">payload</span>: error &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 특정 유저의 팔로워를 로딩한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> loadFollowers = <span class="function"><span class="keyword">function</span>* (<span class="params">&#123; userId &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> followers = <span class="keyword">yield</span> call(Users.loadFollowersFrom, userId);</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'END_FOLLOWER_LOADING'</span>, <span class="attr">payload</span>: user &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'FAIL_FOLLOWER_LOADING'</span>, <span class="attr">payload</span>: error &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 유저 정보를 로딩한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> loadUser = <span class="function"><span class="keyword">function</span>* (<span class="params">&#123; userId &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">yield</span> call(Users.loadUser, userId)</span><br><span class="line">        <span class="keyword">yield</span> put((&#123; <span class="attr">type</span>: <span class="string">'END_USER_LOADING'</span>, <span class="attr">payload</span>: user &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">        <span class="keyword">yield</span> put((&#123; <span class="attr">type</span>: <span class="string">'FAIL_USER_LOADING'</span>, <span class="attr">payload</span>: error &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 각 워커의 시작점을 관리</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> watcher = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">'START_USER_LOADING'</span>, loadUser);</span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">'END_USER_LOADING'</span>, loadFollowers);</span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">'END_USER_LOADING'</span>, loadPoint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">saga.runSaga(watcher)</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*" rel="external nofollow noopener noreferrer" target="_blank">Generator</a>를 모르는 사람은 문법에 어지러울지 모르겠다. <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/function*" rel="external nofollow noopener noreferrer" target="_blank">Generator</a>가 중요한 부분이 아니니 실행 흐름에 거쳐가는 키워드로 보자.</p></blockquote><p>Saga 는 액션을 구독하는 Watcher 와 실제 작업을 수행하는 Worker 의 구성을 따른다</p><ul><li>Watcher<ul><li>watcher 함수</li></ul></li><li>Worker<ul><li>loadUser</li><li>loadFollowers</li><li>loadPoint</li></ul></li></ul><p>먼저 액션을 처리할 워커 함수를 전부 정의한다. loadUser, loadFollowers, loadPoint 셋이 있다. 그리고 매니저가 될 와쳐 함수를 정의하고 그 함수에서 실행을 정의하면 끝이다.</p><p>이후에 좀 더 설명하겠지만 takeXXX 류의 함수는 특정 액션(들) 을 감시하는 함수이고, put 은 실제 액션을 dispatch 하는 함수이다. Redux 의 Dispatch 함수와 동일하다. (이것들을 Saga 에서는 Saga-Effect 라고 부른다. 이후에 설명한다.)</p><p>위 예제에서는 <code>loadUser</code> 는 <code>START_USER_LOADING</code> 가 디스패치될 경우 매번 loadUser 를 실행하게 되어 있다. 그 아래 두개의 함수도 마찬가지로 <code>END_USER_LOADING</code> 가 디스패치 될 경우 각각의 두번째 인자의 함수를 실행한다.</p><p>코드량이 약간 줄은 것 외에는 더 복잡해졌다고 생각할 수 있다.</p><p>하지만 <strong>각 함수들이 자신만의 일에 집중하는 구조로 바뀌었으며 실행 시점을 알기 편해졌다.</strong> 자신 외에 별도 부수효과에 신경쓸 필요가 없다.</p><p>만일 여기서 팔로워나 포인트를 유저 정보 로딩 후가 아닌 다른 타이밍에 호출하려는걸 추가한다면 다음과 같이 하면 된다. 실제 loadXXX 류의 작업 함수는 건드릴 필요가 없다.</p><p>다음과 같이 watcher 함수에 watching 할 액션만 추가로 넣어주면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watcher = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> takeEvery(<span class="string">'START_USER_LOADING'</span>, loadUser);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> takeEvery([</span><br><span class="line">        <span class="string">'END_USER_LOADING'</span>,</span><br><span class="line">        <span class="string">'START_FOLLOWER_LOADING'</span>, <span class="comment">// 추가 </span></span><br><span class="line">    ], loadFollowersFrom);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> takeEvery([</span><br><span class="line">        <span class="string">'END_USER_LOADING'</span>,</span><br><span class="line">        <span class="string">'START_POINT_LOADING'</span>, <span class="comment">// 추가</span></span><br><span class="line">    ], loadPointFrom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 액션에 대해 로깅을 추가한다고 하면 다음 구문만 추가하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> takeEvery([</span><br><span class="line">    <span class="string">'END_USER_LOADING'</span>,</span><br><span class="line">    <span class="string">'END_USER_POINT_LOADING'</span>,</span><br><span class="line">    <span class="string">'END_FOLLOWER_LOADING'</span>, </span><br><span class="line">], writeUserActionLogging);</span><br></pre></td></tr></table></figure><p>이렇게 액션의 감시와 해당 부수효과들을 아예 분리해서 각자의 일만 하게 두었다. 이런 방식으로는 각 액션별로 서로 영향을 주는 표현을 액션만으로 쉽게 나타낼 수 있게 된다. 실제 디스패치 하는 측에서도 비동기의 성공 여부를 고민할 것 없이 동기적 디스패치를 쓰는 것만으로 충분하다.</p><p>실제 작업은 Saga 내부적으로 처리되며 디스패치 된다.</p><h2 id="Saga-Effect"><a href="#Saga-Effect" class="headerlink" title="Saga-Effect"></a>Saga-Effect</h2><p>Saga 는 이러한 부수효과를 처리하는 이펙트들을 지원한다. 앞의 코드에서는 put 과 takeEvery 가 나왔었다.</p><blockquote><p>공식 문서의 Effect 들 <a href="https://redux-saga.js.org/docs/api/#effect-creators" rel="external nofollow noopener noreferrer" target="_blank">https://redux-saga.js.org/docs/api/#effect-creators</a></p></blockquote><p>모든 effect 들은 반드시 yield keyword 와 함께 사용해야 한다</p><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p><code>take</code> 는 특정 액션을 감시하는 용도로 쓰인다.</p><p>다음 코드는 REQUEST_ORDER 액션이 디스패치될 때까지 기다린 후 Api.requestOrder 를 호출하는 예제이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchOrderRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="keyword">yield</span> take(<span class="string">'REQUEST_ORDER'</span>);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">yield</span> call(Api.requestOrder, action.orderId);</span><br><span class="line">    <span class="comment">// ... process ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>블럭된다는 성질을 이용해서 다음과 같이 매번 액션에 대해 반응하는 saga 를 만들 수 있다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchOrderRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 무한 루프</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> action = <span class="keyword">yield</span> take(<span class="string">'REQUEST_ORDER'</span>); <span class="comment">// 하지만 이 라인에서 블럭된다.</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">yield</span> call(Api.requestOrder, action.orderId);</span><br><span class="line">        <span class="comment">// ... process ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런 saga 를 만들일이 많으므로 공식적으로 이런 동작의 헬퍼인 takeEvery, takeLatest, takeLeading 등을 제공하고 있다</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>put effect 는 단순하다.</p><p>redux의 dispatch 함수와 완전히 동일하다. 이 effect 는 블럭되지 않기에 조심해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watchOrderRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 무한 루프</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> action = <span class="keyword">yield</span> take(<span class="string">'REQUEST_ORDER'</span>);</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">yield</span> call(Api.requestOrder, action.orderId);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 결과를 스토어에 디스패치(put) 한다.</span></span><br><span class="line">        <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: <span class="string">'RESPONSE_ORDER'</span>, result &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>새로운 하위 saga 태스크를 생성하는 effect 이다.</p><p>fork 는 블럭되지 않으며 호출 시점에 호출자는 부모 task 가 되고 fork 된 saga 는 자식 task 가 된다. 부모 task 가 취소되면 자식 task 도 취소된다.</p><p>명시적으로 특정 자식 태스크만 취소시킬수도 있다.</p><p>아래에 예제가 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">parentTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> task1 = <span class="keyword">yield</span> fork(childTask1);</span><br><span class="line">    <span class="keyword">const</span> task2 = <span class="keyword">yield</span> fork(childTask2);  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ... do something ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 아직 동작중이면 취소시킨다.</span></span><br><span class="line">    <span class="keyword">if</span>(task2 &amp;&amp; task2.isRunning()) &#123;</span><br><span class="line">        task2.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>call 은 블럭되는 fork 라고 보면 된다. 인자로 함수나 saga task 를 받을 수 있다.</p><p>두번째부터는 실행될 함수나 사가의 인자로 들어간다.</p><p>보통 Promise 등의 실행 (보통은 Ajax Call) 에 쓰이며 Promise 가 resolve 될 때까지 블럭된다.</p><p>예제는 위에 이미 있으므로 생략한다.</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>redux 의 state 에서 특정 상태를 가져올때 사용하는 effect 이다.</p><p>redux-thunk 의 getState 와 비슷하지만, 인자로 셀렉터를 줄 수 있다.</p><p>블럭 effect 이다.</p><p>아래 예제는 활성 유저를 redux state 에서 찾은 뒤 그 아이디로 유저 정보를 Ajax call 하는 예제이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> activeUserSelector = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.user.activeUser;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> getUserData = <span class="function"><span class="params">userId</span> =&gt;</span> ajax(<span class="string">`/user/data/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">parentTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> activeUser = <span class="keyword">yield</span> select(activeUserSelector);</span><br><span class="line">    <span class="keyword">const</span> activeUserData = <span class="keyword">yield</span> call(getUserData, activeUser.userId); </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ... do something ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Redux-Saga 소개
    
    </summary>
    
      <category term="javascript" scheme="https://blog.javarouka.me/categories/javascript/"/>
    
      <category term="react" scheme="https://blog.javarouka.me/categories/javascript/react/"/>
    
      <category term="redux-saga" scheme="https://blog.javarouka.me/categories/javascript/react/redux-saga/"/>
    
    
      <category term="javascript" scheme="https://blog.javarouka.me/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Java HashMap 구현에 대해 (Effective java 3th - Item11)</title>
    <link href="https://blog.javarouka.me/2018/11/28/java%EC%9D%98-HashMap-%EA%B5%AC%ED%98%84%EC%97%90-%EB%8C%80%ED%95%B4/"/>
    <id>https://blog.javarouka.me/2018/11/28/java의-HashMap-구현에-대해/</id>
    <published>2018-11-27T15:00:00.000Z</published>
    <updated>2018-12-01T11:49:20.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map-인터페이스"><a href="#Map-인터페이스" class="headerlink" title="Map 인터페이스"></a>Map 인터페이스</h2><p>Map 같은 동작을 하는 키-값의 자료구조는 <a href="https://ko.wikipedia.org/wiki/%EC%97%B0%EA%B4%80_%EB%B0%B0%EC%97%B4" rel="external nofollow noopener noreferrer" target="_blank">연관 배열</a>이라고 부르는 자료구조이다. 언어에 따라 Dictionary, Map, Symbol Table 등등으로 바꿔 부르기도 한다.</p><h3 id="JDK-8"><a href="#JDK-8" class="headerlink" title="JDK 8"></a>JDK 8</h3><p><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Map.html" rel="external nofollow noopener noreferrer" target="_blank">Map Interface(JDK9 기준)</a> 는 단순하던 JDK 7 구현에서(기본적인 CRUD 성의 메서드 지원만 했다.) <code>default method</code> 가 추가된 JDK 8에서는 편의성 메서드들이 대거 추가되었다.</p><ul><li>편의성을 위해 지정된 값에 대해 일정 연산을 수행하고 그 결과를 갱신하는 compute, computeIfAbsent, computeIfPresent, merge</li><li>요소를 엔트리로 순회가능한 forEach</li><li>값을 보고 없으면 두번째 인자를 반환하는 getOrDefault</li><li>첫번째 인자로 준 키가 없을때만 넣는 putIfAbsent</li><li>값과 키 둘이 일치해야 삭제하는 remove(key, value)</li><li>값을 교체하는 replace, replaceAll</li></ul><p>이 중 getOrDefault 는 특정 경우에 따라 computeIfAbsent 와 대체해서 코드 량을 더욱 줄일 수 있다.</p><p>다음과 같은 코드를 보자.</p><p>키가 문자열이고 리스트가 값인 맵에서 특정 문자열 키의 값이 없다면 해당 값을 기본값을 리스트에 넣고 리스트를 값으로 put 하는 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; strListMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기본값 넣기</span></span><br><span class="line">List&lt;String&gt; list = strListMap.getOrDefault(<span class="string">"locale"</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">list.add(<span class="string">"ko_KR"</span>);</span><br><span class="line">strListMap.put(<span class="string">"locale"</span>, list);</span><br></pre></td></tr></table></figure><p>이 코드를 computeIfAbsent 와 람다로 한줄로 줄일 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; strListMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기본값 넣기</span></span><br><span class="line">strListMap.computeIfAbsent(<span class="string">"locale"</span>, key -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;()).add(<span class="string">"ko_KR"</span>);</span><br></pre></td></tr></table></figure><p><a href="https://medium.com/@hun/java-8%EC%9D%98-%EB%9E%8C%EB%8B%A4-%ED%95%A8%EC%88%98-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-1767d034f962#e8d1" rel="external nofollow noopener noreferrer" target="_blank">Java 8의 람다 함수 살펴보기:성능 비교</a> 를 참고해보자.</p><h3 id="JDK-9"><a href="#JDK-9" class="headerlink" title="JDK 9"></a>JDK 9</h3><p>JDK 9 에서는 좀더 기능이 확장되어 불변 맵을 생성하는 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/Map.html#immutable" rel="external nofollow noopener noreferrer" target="_blank">of default</a> 메서드가 추가되었다.</p><p>오버로딩이 꽤 많이 되어 최대 인자 20개로 10개까지의 원소를 가지는 맵을 생성할 수 있다. 구현이 너무 정직해서 놀랐다.</p><p><a href="https://github.com/google/guava" rel="external nofollow noopener noreferrer" target="_blank">Google Guava</a> 에는 이미 구현되어 있던 기능이다. 그냥 Guava를 정식 라이브러리로 하면 어떨까 싶다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; immutableMap = Map.of(<span class="string">"키1"</span>, <span class="string">"값1"</span>, <span class="string">"키2"</span>, <span class="string">"값2"</span>);</span><br></pre></td></tr></table></figure><h2 id="Map-의-hash-함수"><a href="#Map-의-hash-함수" class="headerlink" title="Map 의 hash 함수"></a>Map 의 hash 함수</h2><p>Java 에서는 hashCode 라는 메서드가 기본적으로 최상위 클래스인 Object 에 존재한다.</p><p>이 코드로 Map 에 사용되는 key 를 대체하면 좋겠지만, hashCode 는 int 형이기에 Map 에 저장할 수 있는 객체의 숫자는 2의 32제곱의 사이즈만으로 제한될 것이다. 그렇다고 hashCode 를 long 으로 키워도 문제고, 다른 타입으로 교체할 경우 계산에 따른 성능 문제가 발생할 수 있다.</p><p>이런걸 다 무시하고 억지로 적용한다 쳐도, Map 이 생성될때마다 2의 32제곱의 사이즈만큼의 저장소(버킷이라고 한다)를 초기화해둬야 한다.</p><p>그래서 Map 의 버킷은 타협을 일정량의 버킷만 생성하고 몇가지 전략으로 버킷 충돌을 관리한다 (Open Addressing, Separate Chaining). Java 에서 사용하는 버킷 충돌 회피는 Separate Chaining 이며, 버킷을 일종의 LinkedList 로 관리한다.</p><p>버킷내의 충돌이 발생하면 기존 key와 신규 key의 equals 호출로 다시한번 중복여부를 검사하여 값을 교체하기에 키가 될 객체 Class 의 equals 구현은 상당히 중요하다.</p><p>hashCode 의 구현 규칙에서 <code>두 객체가 다르더라도 두 객체가 서로 다른 hashCode 를 반환하지 않아도 된다</code> 라는 건 이 때문이다.</p><p>하지만 둘다 다르게 구현하는게 Map의 성능 향상에 크게 도움이 된다. (특정 버킷에 편중되어 저장되는 현상을 회피할 수 있고, 충돌 버킷의 순회 비용이 줄어든다)</p><p>위 조건을 만족하는 hashCode 구현을 <a href="https://en.wikipedia.org/wiki/Perfect_hash_function" rel="external nofollow noopener noreferrer" target="_blank">완전 해시 함수</a> 라고도 부른다</p>]]></content>
    
    <summary type="html">
    
      equals를 재정의하려거든 hashCode도 재정의하라
    
    </summary>
    
      <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
  </entry>
  
  <entry>
    <title>Equals 구현과 리스코프 치환 법칙 (Effective java 3th - Item10)</title>
    <link href="https://blog.javarouka.me/2018/11/27/object-equals-liskov/"/>
    <id>https://blog.javarouka.me/2018/11/27/object-equals-liskov/</id>
    <published>2018-11-26T15:00:00.000Z</published>
    <updated>2019-04-07T12:49:45.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="equals-구현-규칙"><a href="#equals-구현-규칙" class="headerlink" title="equals 구현 규칙"></a>equals 구현 규칙</h2><p>equals 는 정해진 법칙에 따라 다양한 객체에서 호출되고 있다.</p><p>규칙을 지키지 않은 구현으로 의존성 객체에 처리를 맡긴다면, 의도하지 않은 동작이 발생하고 디버깅을 어렵게 만든다.</p><p>규칙들은 다음과 같다.</p><ul><li>반사성</li><li>null은 항상 false</li><li>대칭성</li><li>추이성</li><li>일관성</li></ul><h3 id="반사성"><a href="#반사성" class="headerlink" title="반사성"></a>반사성</h3><p>context 와 null이 아닌 인자가 같을 경우 항상 true 가 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.equals(context); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="대칭성"><a href="#대칭성" class="headerlink" title="대칭성"></a>대칭성</h3><p>context 가 어떤 대상 some 과 같다면 그 역방향도 true 가 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.equals(some); <span class="comment">// true</span></span><br><span class="line">some.equals(context); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>상속관계가 아닌 타입이 다른 객체에서 객체의 equals 비교로 true를 반환하는 구현은 거의 99.99% 대칭성 위반에 걸린다.</p><h3 id="추이성"><a href="#추이성" class="headerlink" title="추이성"></a>추이성</h3><p>말이 어려운데, A와 B가 같고 B와 C가 같다면 A와 C는 같아야 한다는 어디선가 본 논리적 법칙이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">context.equals(some); <span class="comment">// true</span></span><br><span class="line">some.equals(another); <span class="comment">// true</span></span><br><span class="line">context.equals(another); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>이 구현에서 주의할 것은 상속관계가 얽힐 때다.</p><p>특정 클래스를 확장하여 새로운 필드등을 추가한 클래스는 추이성을 만족시킬 수 없다.</p><p>특정 클래스를 특정지어 비교하는 방법으로 구현된 equals 의 경우 언뜻 조건 만족을 하는 것 같지만 리스코프 치환 법칙을 위배하기에 쓸 수가 없다.</p><p>이 경우에는 <a href="https://www.geeksforgeeks.org/association-composition-aggregation-java/" rel="external nofollow noopener noreferrer" target="_blank">컴포지션</a> 을 통해 문제를 해결할 수 있다.</p><h4 id="리스코프-치환-법칙"><a href="#리스코프-치환-법칙" class="headerlink" title="리스코프 치환 법칙"></a>리스코프 치환 법칙</h4><p>서브타입은 언제나 자신의 상위 타입으로서의 기능을 해야 한다.</p><p>만일 상위 클래스가 직사각형이고, 하위 클래스를 정사각형이라고 해보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(height, width);</span><br><span class="line">        <span class="keyword">if</span>(height != width) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionException(<span class="string">'cannot create!'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> height, <span class="keyword">int</span> width)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height != width) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionException(<span class="string">'cannot create!'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">super</span>(height, width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>직사각형(Rectangle) 은 마음대로 크기 조절이 가능하지만 정사각형(Square) 은 크기 조절에 제약이 있다.</p><p>일견 문제가 없어 보이지만 문제는 정사각형이 직사각형의 문맥에서 사용될 때다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 직사각형 문맥 로직 수행</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeWideSize</span><span class="params">(Rectangle rec)</span> </span>&#123;</span><br><span class="line">    dim.setSize(dim.getHeight(), dim.getWidth() * <span class="number">2</span>); <span class="comment">// throw Exception.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사용자 측에서는 직사각형이라고 생각하고 인자를 처리하고 있다.</p><p>하지만 불행히도 객체지향의 인자는 <a href="https://edykim.com/ko/post/what-is-coercion-and-anticommunism/" rel="external nofollow noopener noreferrer" target="_blank">반공변적(contravariant)</a>이다. 이 뜻은 인자는 실제 객체의 하위타입이 올 수 있다는 뜻이다.</p><p>예제에서는 <strong>직사각형(Rectangle) 뿐 아니라 정사각형(Square)</strong> 도 올 수 있다는 뜻이다.</p><p>그리고 어떤 객체가 오느냐에 따라 코드의 동작은 변한다. 이럴 경우 리스코프 치환 법칙이 깨졌다고 설명할 수 있다. 정사각형 객체의 가로세로의 크기가 달라져 버렸다.</p><h3 id="일관성"><a href="#일관성" class="headerlink" title="일관성"></a>일관성</h3><p>몇번을 호출해도 어떤 상황에서 호출해도 두 대상 객체의 내용이 같다면 결과는 항상 같아야 한다.</p><p>equals 는 언제나 해당 객체를 대상으로 동치성을 비교해야 하는데, 다른 조건을 참고해가며 비교하게 되면 이 조건이 깨지기 쉽다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">context.equals(some); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception ignore) &#123;&#125;</span><br><span class="line">    context.equals(some); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      equals 는 일반 규약을 지켜 재정의하라
    
    </summary>
    
      <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
  </entry>
  
  <entry>
    <title>객체 소멸자의 슬픈 디자인 (Effective java 3th - Item8, 9)</title>
    <link href="https://blog.javarouka.me/2018/11/26/Finalizer%EC%99%80-Cleaner/"/>
    <id>https://blog.javarouka.me/2018/11/26/Finalizer와-Cleaner/</id>
    <published>2018-11-25T15:00:00.000Z</published>
    <updated>2018-11-27T12:56:34.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Finalizer"><a href="#Finalizer" class="headerlink" title="Finalizer"></a>Finalizer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>finalize</code> 메서드를 Override 하면 해당 객체가 JVM 에게 Garbage Collection 을 해야 할 대상이 될 때 호출된다. 객체가 없어지기 전 다른 연관 자원을 정리하려는 의도로 작성된다.</p><p>하지만 이 메서드는 사용해서는 안되며 실제로 java9+ 부터 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#finalize--" rel="external nofollow noopener noreferrer" target="_blank">Deprecated</a> 되어버렸다.</p><p>오류/시점/성능/수행성 뭐 하나 보장하지 못하며 때로는 영원히 수행되지 않거나 불행하게도 Lock 이 걸려 프로그램 전체가 블럭될 수도 있다.</p><p>java9 에서는 대안으로 Cleaner 를 지원하게 되었다</p><h2 id="Cleaner"><a href="#Cleaner" class="headerlink" title="Cleaner"></a>Cleaner</h2><p>Java9 에서 도입된 소멸자로 생성된 Cleaner 가 더 이상 사용되지 않을 때 등록된 스레드에서 정의된 클린 작업을 수행한다.</p><p>혹은 명시적으로 clean 을 수행할수도 있다. 보통 AutoCloseable을 구현해서 <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" rel="external nofollow noopener noreferrer" target="_blank">try-with-resource</a> 와 같이 사용한다. (이 편이 추천된다)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleaningRequiredObject</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cleaner cleaner = Cleaner.create​();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanData</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 여기서 클린 작업 수행</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CleanData;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CleaningRequiredObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cleanData = <span class="keyword">new</span> CleanData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 등록</span></span><br><span class="line">        <span class="keyword">this</span>.cleanable = cleaner.register(<span class="keyword">this</span>, state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자칫 Clean 작업을 실제로 수행할 클래스의 디자인에 실패해서 다른 외부 참조나 의존성이 걸릴 경우, 최악의 경우 순환의존성 덕분에 GC의 기회가 없어질 수도 있다.</p><p>이를 피하기 위해 보통은 AutoCloseable - try-with-resource 로 안전장치를 거는 편이 좋다.</p><h2 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h2><p>I/O 등의 작업에서는 어떤 모듈이 사용이 종료될 경우 해당 자원을 해지하고 없애야 할때가 많다.</p><p>보통 그럴 경우 try-finally 구문으로 처리하는데 이 경우 코드가 상당히 지저분하다.</p><p>또한 작업 메서드가 오류가 나더라도 close 를 해야 할 경우와 close 자체에서도 오류를 던지는 경우가 있어 그 두 부분을 전부 try-catch 하다보면 코드 가독성은 현저하게 저하된다.</p><p>try-with-resource 로 이런 고충을 한방에 날려버릴 수 있다.</p><p>다음 Worker 클래스는 테스트를 위해 명시적으로 오류를 내고 있다. 이 경우에 try-with-resource 를 사용하면 아주 깔끔한 코드가 나오며, 오류또한 잘 캡처된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"work Exception!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"close Exception!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 짧다!</span></span><br><span class="line">        <span class="keyword">try</span>(Worker worker = <span class="keyword">new</span> Worker()) &#123;</span><br><span class="line">            worker.work();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>출력 오류는 다음과 같다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: work Exception!</span><br><span class="line">at Boss$Worker.work(Boss.java:6)</span><br><span class="line">at Boss.main(Boss.java:16)</span><br><span class="line">Suppressed: java.lang.RuntimeException: close Exception!</span><br><span class="line">at Boss$Worker.close(Boss.java:10)</span><br><span class="line">at Boss.main(Boss.java:18)</span><br></pre></td></tr></table></figure><h2 id="Cleaner-Finalizer-둘다-애매하다"><a href="#Cleaner-Finalizer-둘다-애매하다" class="headerlink" title="Cleaner / Finalizer 둘다 애매하다."></a>Cleaner / Finalizer 둘다 애매하다.</h2><p>하지만 둘다 일반적으로는 사용이 불필요하다.</p><p>둘다 성능에 문제가 많고, Serialize 를 통한 보안 이슈가 존재하며, 수행 시점이 보장되지 않는다.</p><p>JVM 구현에 따라 동작도 매우 달라질 여지가 많다.</p><p>사용할수밖에 없을때는 다음과 같은 케이스가 있다</p><ul><li>JNI</li><li>Off-Heap 메모리 사용시 (DirectBuffer 류 사용시)</li></ul><h2 id="읽을만한-글"><a href="#읽을만한-글" class="headerlink" title="읽을만한 글"></a>읽을만한 글</h2><ul><li><a href="https://dzone.com/articles/javas-finalizer-is-still-there" rel="external nofollow noopener noreferrer" target="_blank">Java’s Finalizer Is Still There</a></li><li><a href="https://d2.naver.com/helloworld/329631" rel="external nofollow noopener noreferrer" target="_blank">Java Reference와 GC</a></li><li><a href="https://www.logicbig.com/tutorials/core-java-tutorial/gc/phantom-reference.html" rel="external nofollow noopener noreferrer" target="_blank">Java Garbage Collection - Understanding Phantom Reference with examples</a></li></ul>]]></content>
    
    <summary type="html">
    
      finalizer 와 cleaner 사용을 피하라
    
    </summary>
    
      <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
      <category term="try-with-resource" scheme="https://blog.javarouka.me/tags/try-with-resource/"/>
    
  </entry>
  
  <entry>
    <title>String과 Boxing, 그리고 객체생성 (Effective java 3th - Item6)</title>
    <link href="https://blog.javarouka.me/2018/11/25/%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4%EC%83%9D%EC%84%B1-%ED%9A%8C%ED%94%BC/"/>
    <id>https://blog.javarouka.me/2018/11/25/불필요한-객체생성-회피/</id>
    <published>2018-11-24T15:00:00.000Z</published>
    <updated>2018-11-27T12:56:34.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="객체-재활용"><a href="#객체-재활용" class="headerlink" title="객체 재활용"></a>객체 재활용</h2><p>불변 객체이고, 재활용이 자주 되는 객체는 매번 생성해서 좋을게 없다. 미리 만들어두고 참조만 지정하면서 재사용하는게 유리하다.</p><p>Java 내부 구현에서도 String 이 이런 패턴을 따른다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String hello = <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure><p>나중에 다시 “world” 문자열이 필요해서 다음과 같이 선언해도 같은 객체를 사용함이 보장된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!isEnd()) &#123;</span><br><span class="line">    String world = <span class="string">"world"</span>; <span class="comment">// 계속 같은 인스턴스 참조</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 동작하는 이유는 Java에서 쓰이는 모든 String 객체는 상수풀에서 관리되며 프로그램 종료때까지 유지되기 때문이다.</p><p>강제로 상수풀의 문자열을 사용하게 하는 메서드로 <a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#intern--" rel="external nofollow noopener noreferrer" target="_blank">intern</a> 이 있다.</p><p><em>intern</em> 된 문자열은 상수 풀에서 사용되기에 true 를 반환한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hello = <span class="string">"world"</span>;</span><br><span class="line">hello == <span class="keyword">new</span> String(<span class="string">"world"</span>); <span class="comment">// false</span></span><br><span class="line">hello == <span class="keyword">new</span> String(<span class="string">"world"</span>).intern(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Auto-Boxing-Auto-UnBoxing"><a href="#Auto-Boxing-Auto-UnBoxing" class="headerlink" title="Auto-Boxing / Auto-UnBoxing"></a>Auto-Boxing / Auto-UnBoxing</h2><p>Primitive 타입의 박싱에서 주의해야 할게 잘못 코딩할 경우 원치않는 객체 생성이 일어난다. 비슷하게 쓸 수 있다고 해서 루프문이나 과도한 계산에 박싱타입과 Primitive 타입을 섞어 쓸 경우에는 끔찍한 성능 이슈를 겪을수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> first = <span class="number">3L</span>;</span><br><span class="line"><span class="keyword">long</span> second = <span class="number">2L</span>;</span><br><span class="line">Long value = first + second; <span class="comment">// 객체 생성.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      불필요한 객체 생성을 피하라
    
    </summary>
    
      <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
  </entry>
  
  <entry>
    <title>신규 통합 CS 시스템 관리 개발기 # 혼란편</title>
    <link href="https://blog.javarouka.me/2018/11/23/new_project_2/"/>
    <id>https://blog.javarouka.me/2018/11/23/new_project_2/</id>
    <published>2018-11-22T15:00:00.000Z</published>
    <updated>2018-11-24T01:41:59.364Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><a href="/2018/10/28/new_project_1/">신규 통합 CS 시스템 관리 개발기 # 설계편 #</a></li><li>신규 통합 CS 시스템 관리 개발기 # 혼란편 #</li></ul><hr><h2 id="생각-이상으로-많이-생기는-Behavior-DTO-문제"><a href="#생각-이상으로-많이-생기는-Behavior-DTO-문제" class="headerlink" title="생각 이상으로 많이 생기는 Behavior, DTO 문제"></a>생각 이상으로 많이 생기는 Behavior, DTO 문제</h2><p>단순 조회라도 Controller -&gt; Service -&gt; Behavior -&gt; Repository 로 이어진다.</p><p>그리고 그 레이어간의 통신시마다 각자의 레이어들이 요구하는 DTO 를 만들다보면, 필드 값들이 매우 유사한 많은 Class 가 정의된다.</p><p>특히 단순 아이디 조회건의 경우에는 형식적인 각 레이어 관련 class 들이 생성되고 그에 대응하는 동일 필드의 DTO 들이 정의되며, 그를 위한 변환 로직이 들어간다.</p><p align="center"><br><img src="/asset/new_project/boxes.jpeg" alt="수많은..."><em>많다…</em><br></p><p>각 도메인의 지식이 명확하고 이해도가 깊다면, 모든 Layer 에서 참고할 수 있는 Top-Level 레이어 수준으로 Entity (JPA Entity 말고) 를 만들어볼 수 있겠지만, 현실은 쉽지 않았다. 전사 도메인이 그렇게 일관된 통일성이 있는게 아니라 A 비즈니스 팀 에서 해야할 일을 B 비즈니스 팀에서 하는 일도 있고 자주 바뀌기에 이것에 대응하려는 설계는 참으로 어려웠다.</p><p>하지만 정석은 언제나 통한다고 생각한다. 많은 시간을 들여 분석해가며 설계하면 이런 점까지 커버할 수 있는 시스템을 만들 수 있다.</p><p>하지만 이번에는 일단 초기에 만든 규칙대로 다수의 파일 생성도 감안하며 가는 방식을 선택했다. 후에 리팩토링을 통해서라도 개선하고 싶다.</p><h2 id="API-분할과-정의-문제"><a href="#API-분할과-정의-문제" class="headerlink" title="API 분할과 정의 문제"></a>API 분할과 정의 문제</h2><p><a href="https://blog.javarouka.me/2018/10/28/new_project_1/#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%86%A0%EB%A7%89%EC%B9%98%EA%B8%B0">전 글</a> 에서 언급한 <code>데이터 토막치기</code> 로 간단히 데이터를 합쳐서 한방에 내려주는 방식이 아닌 각각의 논리적 단위로 데이터를 가져오는 방식으로 변하면서, 서버 API 설계가 상당히 중요해졌다.</p><p>API 를 전체적으로 알지 못하면 같은 데이터가 필요할 때 비슷한 기능의 API 가 생성될 수도 있고, 적절한 관리가 안될 경우 나중엔 비슷비슷한 응답의 endpoint 만 조금씩 다른 API가 많아질 수 있다.</p><p>이번에 작업한 내용은 <code>주문정보</code> 라는 컨텐츠 하나였지만 그 안에서도 서로 비슷한 필드 몇개만이 다른 endpoint API 가 몇개 정도 존재하게 되었고 그대로 product 배포 상태이다.</p><p>이 점은 문서화와 관련이 깊다고 생각한다.</p><p>나중에 문서화를 위해 다급히 <a href="https://swagger.io/" rel="external nofollow noopener noreferrer" target="_blank">swagger</a> 를 붙이고 주석 <code>annotation</code> 을 코딩했지만 만족스럽진 않다.</p><p align="center"><br><img src="/asset/new_project/use-swagger.png" alt="문서"><em>문서 정리는 언제나 귀찮다</em><br></p><p>개발단계에서 보다 쉽게 API 를 파악할 방법이 있다면 좋겠는데.</p><h2 id="Client-에서의-요청-증가-문제"><a href="#Client-에서의-요청-증가-문제" class="headerlink" title="Client 에서의 요청 증가 문제"></a>Client 에서의 요청 증가 문제</h2><p>역시 <code>데이터 토막치기</code> 로 인해 기존에 한방에서 여러 요청으로 나뉘면서 Http Request 의 숫자가 늘어났다.</p><p>데이터 각자가 자신이 필요한 데이터만 응답하기에 경량화된건 사실이다. 하지만 화면에서는 여전히 여러 데이터가 필요하고 그 데이터를 구하려면 필요한 수 만큼의 API 요청을 해야 한다.</p><p>복잡한 도메인이 포함된 비즈니스로 구성되는 컨테이너의 경우 많은 요청으로 인해 느릴 수밖에 없고 네트워크의 Latency 가 나쁜 상황에서는 몇배로 느려진다.</p><p align="center"><br><img src="/asset/new_project/receipts.jpeg" alt="많은 영수증"><br></p><p>이 때문에 논리적인 데이터 토막을 잘 정의하는게 매우 중요하다.</p><p>데이터를 과하게 합쳐 응답할 경우 특정 UI 나 비즈니스만을 위한 API 가 되고, 과도하게 나눠 응답할 경우 Client 로직이 복잡해지고 Http request 가 증가한다.</p><p>이에 대해서는 확실한 기준을 세우지 못했다. 대략적으로 만든 아래와 같은 기준이 있을 뿐이다.</p><ul><li>반복적으로 조회되며 변경율이 낮은 상수 데이터는 앱 초기에 로딩하여 store 에 저장한다</li><li>키 조회 API 는 분리한다 (상품, 주문, 취소, 반품 …)</li><li>정책 API 는 분리한다 (취소가능, 배송지 변경가능, 접수 수정가능 …)</li><li>복수의 데이터의 조합으로 결정되는 데이터는 합친다 (회원 특별등급, 3P,Retail 배송상태 …)</li><li>데이터의 변경/생성/삭제 에 대해서는 최소한의 파라미터로 한번의 트랜잭션으로 처리한다</li></ul><h2 id="Client-로직에서의-Container-단위-정의-문제"><a href="#Client-로직에서의-Container-단위-정의-문제" class="headerlink" title="Client 로직에서의 Container 단위 정의 문제"></a>Client 로직에서의 Container 단위 정의 문제</h2><p>데이터를 분할해서 받았으니 역시 분할된 데이터를 조립해야 한다.</p><p>그 영역은 Container 라 부르는 Redux Store 에 <a href="https://github.com/reduxjs/react-redux/blob/master/docs/api.md#connect" rel="external nofollow noopener noreferrer" target="_blank">connect</a> 되는 영역에서 처리하기로 했다.</p><p>각 <a href="https://github.com/erikras/ducks-modular-redux" rel="external nofollow noopener noreferrer" target="_blank">Ducks</a> 를 확장한 <a href="https://github.com/alexnm/re-ducks" rel="external nofollow noopener noreferrer" target="_blank">ReDucks</a> 에서 <a href="https://github.com/alexnm/re-ducks#selectors" rel="external nofollow noopener noreferrer" target="_blank">selector</a> entity 들의 데이터를 잘 조합하는 Container 용 selector 를 만든다. (selector 는 메모이징을 지원하도록 <a href="https://github.com/reduxjs/reselect" rel="external nofollow noopener noreferrer" target="_blank">reselect</a> 를 사용했다)</p><p>Container 는 특정 목적의 비즈니스의 집합이라 UI 와 강하게 결합되기에 그냥 한파일에 selector 를 넣었다.</p><p>이렇다보니 Container 를 잘못 정의할 경우 엄청난 크기의 selector 가 만들어진다. 그렇다고 모든 UI Component 들을 Container 화 할 경우 모든 UI 에 entitiy selector 가 달리게 되고, 데이터 구조 변경에 강한 영향을 받게 된다.</p><p>현재는 데이터의 응집력(나름대로의…) 단위로 나눠두긴 했는데, 이것도 불명확하긴 매한가지.</p><p>참고할 만한 기준따위 있을리도 없고, 결국에는 실전 운영으로 타협점을 찾아가는게 좋을 듯 하다.</p><h2 id="Webpack-Code-Splitting-문제"><a href="#Webpack-Code-Splitting-문제" class="headerlink" title="Webpack Code Splitting 문제"></a>Webpack Code Splitting 문제</h2><p>asset(js, css, images…)들의 로딩은 단일 서버 운영에서는 문제가 일어나지 않는다.</p><p>하지만 복수의 서버로 운영되는 환경에서 운영되는 배포 프로세스중에는 <a href="https://martinfowler.com/bliki/CanaryRelease.html" rel="external nofollow noopener noreferrer" target="_blank">Canary Release</a> 라는 방식이 있다.</p><blockquote><p>Canary Release 는 새로운 버전의 소프트웨어를 운영 환경에 배포할 때, 전체 사용자들이 사용하도록 모든 인프라에 배포하기 전에 소규모의 사용자들에게만 먼저 배포함으로써 리스크를 줄이는 기법이다.<br>- <a href="https://m.blog.naver.com/PostView.nhn?blogId=muchine98&amp;logNo=220262491992&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F" rel="external nofollow noopener noreferrer" target="_blank">너굴너굴 블로그</a></p></blockquote><p>이 환경에서는 일정 기간동안은 asset 의 버전이 다른 미배포 서버와 canary 서버가 다를 수 있는데 canary 서버의 변경이 있는 상태에서 변경되지 않은 미배포 서버의 asset 을 로딩할 경우 asset 버전 불일치로 인한 장애가 발생할 수 있다.</p><p>꼭 canary 방식이 아니더라도 순차적으로 N대씩 배포되는 환경에서는 문제가 발생한다.</p><p>Webpack 에서는 기본 전략으로 asset 파일들을 hash 문자열로 변환하여 배포시마다 파일이름이 <code>[hash].[ext]</code> 형식으로 번들되어 배포되는데, 문제는 canary 서버가 배포된 뒤 이 서버에서 asset 을 미배포 서버에 요청하게 되는 일이다. 당연히 해당 asset 은 없어서 404 error 가 발생한다.</p><p>파일 이름을 강제로 고정 이름 (예를 들면 534fsdnfg23543gf.js 가 아닌 main.js) 으로 정해도 되지만, 이 경우 client cache 를 피하기 어렵다.</p><p align="center"><br><img src="/asset/new_project/code-split.png" alt="코드 분할"><br></p><p>운 좋게 canary 서버가 요청한 asset 을 canary 가 받았다 하더라도, Chunck 등의 <a href="https://webpack.js.org/guides/code-splitting/" rel="external nofollow noopener noreferrer" target="_blank">Code Splitting</a> 이나 <a href="https://webpack.js.org/guides/lazy-loading/" rel="external nofollow noopener noreferrer" target="_blank">Lazy Loading</a> 등을 적용해뒀다면 Chunk Loading Error 도 보게 된다.</p><p>처음에는 장애 포인트를 알 수 없어서 Canary Release 를 건너뛰고 항상 Deploy All 을 했었다.</p><p>해결책은 S3빌드번호를 webpack 번들링 타이밍에 인자로 넘겨 output 설정에 <a href="https://webpack.js.org/guides/public-path/" rel="external nofollow noopener noreferrer" target="_blank">Public Path</a>를 만드는 방법이었다.</p><p>Public Path 가 고정되니 배포 Scope 으로 asset 을 요청하게 되고 자신의 배포버전에 맞는 asset 을 서버에서 로딩하도록 유도할 수 있었다.</p><p>이부분에서 꽤나 많은 시행착오가 있었던걸로 기억한다.</p><h2 id="익숙하지-않은-도구들-문제"><a href="#익숙하지-않은-도구들-문제" class="headerlink" title="익숙하지 않은 도구들 문제"></a>익숙하지 않은 도구들 문제</h2><h3 id="styled-component"><a href="#styled-component" class="headerlink" title="styled-component"></a>styled-component</h3><p align="center"><br><img src="/asset/new_project/styled-component.png" alt="Styled Component"><br></p><p>스타일 도구로 <a href="https://www.styled-components.com/" rel="external nofollow noopener noreferrer" target="_blank">styled-component</a> 를 사용했는데, 기존의 css 와 className 개념과는 아주 달랐다. Component 에서 Style 의 요소를 Component 로 분리하는 생각이 생각대로 잘 되지 않았다.</p><p>별도 파일로 분리해야 하는 것인가, 기존 css 처럼 하나의 파일에 전부 모아두고 selection import 하는 방식인 것인가부터, 어느 레벨로 그룹해야 하는지도 혼란스러웠다.</p><p>문법적으로도 3.x 버전과 4.x 버전의 과도기에 사용해서 라이브러리의 구조가 변했고, 대응하느라 리소스의 낭비도 있었다.</p><p>사용하면서 내린 나름의 결론은 이렇다.</p><ul><li>각 컴포넌트는 가급적 <a href="https://reactjs.org/docs/fragments.html" rel="external nofollow noopener noreferrer" target="_blank">React.Fragment</a> 로 래핑한다</li><li>부모 레벨이 자식 컴포넌트의 스타일을 지정할 수 있게 한다. StyleComponent 로 자식을 감싸서 사용한다는 뜻이다</li><li>StyleComponent 든 DataComponent 든 네이밍과 파일 단위는 동일하게 한다. 사용 측에서는 이 컴포넌트가 Style 인지 Data 인지 알 필요가 없다.</li></ul><p>현재 (2018.11.23) 운영 배포된 소스는 위의 룰을 지키지 못했다. 천천히 수정해야 할 일이다.</p><h3 id="Redux-Saga"><a href="#Redux-Saga" class="headerlink" title="Redux-Saga"></a>Redux-Saga</h3><p align="center"><br><img src="/asset/new_project/redux-saga.png" alt="Redux Saga"><br></p><p><a href="https://github.com/redux-saga/redux-saga" rel="external nofollow noopener noreferrer" target="_blank">Redux-Saga</a> 의 사용에 미숙하여 여러 착오를 겪었다.</p><p>제일 심하게 겪은 문제는 <a href="https://redux-saga.js.org/docs/api/#takepattern" rel="external nofollow noopener noreferrer" target="_blank">take</a> 관련인데 <code>Ajax 등의 비동기 Side-Effect 를 동반하는 Task</code> 일 경우 같은 요청이 다수가 중복된다면 첫번째만 처리하는 것이 보통 효율이 좋다. 이런 경우는 대부분 사용자의 반복된 클릭등으로 요청되는게 대부분이기 때문이다.</p><p>Saga 에서는 <a href="https://redux-saga.js.org/docs/api/" rel="external nofollow noopener noreferrer" target="_blank">Helper 함수</a>로 <code>takeLatest</code>, <code>takeEvery</code>, <code>takeLeading</code> 등을 지원한다</p><ul><li>takeEvery<ul><li>매번 요청건 처리</li></ul></li><li>takeLatest<ul><li>제일 마지막 건만 처리</li></ul></li><li>takeLeading<ul><li>제일 첫번째 건만 처리</li></ul></li></ul><p>개발 초기에는 대부분의 Saga Watcher 에 takeLeading (1.x) 을 걸어두었다. 중복 요청일 경우 두번째는 무시하기 위해서이다.</p><p>하지만 나중에 테스트와 액션 리포트를 보면 사용자의 반복 요청에 막히는 것은 거의 없고 오히려 특정 사이드이펙트 action watcher (트리거 action이 여러개 존재하는 watcher) 가 서로 다른 action dispatch 에 영향받게 되면서 나중 요청을 전부 씹는 상황이 발생했다</p><p>예를 들면 주문 상세를 트리거하는 ORDER_DETAIL 액션으로 주문 A 를 trigger 했다가 바로 B 를 trigger 하면 주문 A 의 정보를 로딩하는 watcher 들이 takeLeading 방식이라 나중에 들어온 B 정보 action 을 dispatch 하지 않고 주문 A 관련만을 처리하게 되는 것이다.</p><p><code>take</code> 디자인에도 생각없이 하면 안된다는 걸 깨닫고 액션과 UI 의 관계에 따라 다른 <code>take</code> 전략을 사용해야 한다는 걸 깨달았다. 잘 모르겠으면 <a href="https://redux-saga.js.org/docs/api/#saga-helpers" rel="external nofollow noopener noreferrer" target="_blank">take helper</a> 들을 안쓰는 것도 좋은 방법인것 같다.</p><p><code>fork</code> 된 액션은 부모의 try-catch 에 영향이 없다라든지 <code>call</code> 과 <code>fork</code> Blocking 차이라든지 하는 Redux-Saga 이해도가 부족한 것에서 오는 어려움도 있었지만 이런건 <a href="https://mskims.github.io/redux-saga-in-korean/" rel="external nofollow noopener noreferrer" target="_blank">Document</a> 를 잘 봤으면 해결될 문제라…</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>CS 상담 시스템 개편이 현재 시간 기준 한창 테스트중이다.</p><p>여러모로 아쉬운 점이 많은 프로젝트였다. 여기엔 적지 않았지만 잘못된 시간분배나 플래닝, 계획들도 큰 장애거리였다.</p><p>테스트 결과와는 관계없이 기록을 남겨 나중에 기술 선택에 좀더 도움이 되길 바랄 뿐이다.</p>]]></content>
    
    <summary type="html">
    
      혼란하다
    
    </summary>
    
      <category term="Tech" scheme="https://blog.javarouka.me/categories/tech/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="javascript" scheme="https://blog.javarouka.me/tags/javascript/"/>
    
      <category term="scaffolding" scheme="https://blog.javarouka.me/tags/scaffolding/"/>
    
      <category term="legacy" scheme="https://blog.javarouka.me/tags/legacy/"/>
    
      <category term="new-cs-system" scheme="https://blog.javarouka.me/tags/new-cs-system/"/>
    
  </entry>
  
  <entry>
    <title>Dependency Inject &amp; Dispatch (Effective java 3th - Item5)</title>
    <link href="https://blog.javarouka.me/2018/11/21/dependency-inject/"/>
    <id>https://blog.javarouka.me/2018/11/21/dependency-inject/</id>
    <published>2018-11-20T15:00:00.000Z</published>
    <updated>2018-11-27T12:56:34.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>java 객체지향은 많은 모듈들의 의존성으로 이뤄진다. 다만 의존성을 코드상에 명시할 경우 그 의존성이 클라이언트 코드에 강하게 결합되게 된다.</p><p>다음과 같은 싱글턴 클래스가 있다. 만화 드래곤 볼에 나오는 드래곤 레이더이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DragonBallRadar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HeightMap heightMap = <span class="keyword">new</span> EarthMap();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DragonBallRadar</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coordinate <span class="title">detect</span><span class="params">()</span> </span>&#123; <span class="comment">/* 구현 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 드래곤 레이더는 지구에서는 아주 잘 동작할 것이다. 지구에 대한 데이터가 미리 주어지기 때문에 지구에 대해 드래곤 볼의 위치를 잘 표시할 수 있다.</p><p>하지만 작중에서 피콜로가 죽고 나메크별로 무대가 옮겨지는 때가 있다. 안타깝지만 부르마와 Z 전사들은 이 드래곤 레이더로 나메크성의 드래곤볼을 찾을 수 없게 될것이다.</p><p>이 레이더는 지구맵만 지원하고 있기 때문이다.</p><p><code>높이맵 (HeightMap)</code> 을 바꾸기 위해 <code>setHeightMap</code> 를 추가할수도 있지만, 싱글톤 객체에 setter 를 추가하는건 멀티환경에서는 오류를 내기 쉽다.<br>다수의 스레드의 접근 상태에서 setter 를 호출할 경우 의도하지 않은 오류가 발생할 수 있고 문법적으로 매우 어색하다.</p><p>정적 클래스의 메서드는 같은 상태일 때 A 를 호출하면 B 를 받는 순수 함수의 형태가 되어야 옳다. 상태를 가지는 것도 물론 어색하다.</p><blockquote><p>사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다<br>-Effective Java 3th 29 page</p></blockquote><p>이 경우에는 정적 메소드는 지양해야 하며, 사용자 측에서 높이맵을 바꿔줄 수 있어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DragonBallRadar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HeightMap heightMap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DragonBallRadar</span><span class="params">(Supplier&lt;HeightMap&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.heightMap = supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coordinate <span class="title">detect</span><span class="params">()</span> </span>&#123; <span class="comment">/* 구현 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Framework 를 사용하면서 자연스럽게 쓰고 있을 규칙이지만, 간혹 static 과 의존성을 섞어 쓰는 사례가 있는데 조심해야 한다. 의존성이 추가되기 전에도 정적 메서드는 호출할 수 있으며, Spring Application Context 가 완전히 초기화되기 전에 정적 메서드가 호출된다면 문제가 생길 것이다.</p><p>간단한 변경으로 나메크별의 높이맵 생성 팩토리를 만들어 주입한 결과 이제 프리저보다 먼저 드래곤볼을 찾을 수 있게 됨은 물론, 나중에 지구에서도 사용할 수 있는 만능 레이더가 되었다.</p>]]></content>
    
    <summary type="html">
    
      자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
    
    </summary>
    
      <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
      <category term="di" scheme="https://blog.javarouka.me/tags/di/"/>
    
      <category term="double dispatch" scheme="https://blog.javarouka.me/tags/double-dispatch/"/>
    
  </entry>
  
  <entry>
    <title>LazyHolder 기법 (Effective java 3th - Item4)</title>
    <link href="https://blog.javarouka.me/2018/11/20/no-instance/"/>
    <id>https://blog.javarouka.me/2018/11/20/no-instance/</id>
    <published>2018-11-19T15:00:00.000Z</published>
    <updated>2018-11-27T12:56:34.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>Java 에서의 생성자는 접근제어로 통제할 수 있기에 객체 생성에 생성자를 쓰고 싶지 않다면, private 접근제어를 줘서 막자.</p><p align="center"><br><img src="/asset/images/effective/item4-cannot-extends-because-private.png"><br></p><p>위 그림의 예제처럼, 상속을 방어하는 효과도 있다.</p><p>클래스 A 는 B의 생성자를 체이닝하려 하지만 접근이 막혀 컴파일 오류를 발생시킨다.</p><h2 id="LazyHolder-기법"><a href="#LazyHolder-기법" class="headerlink" title="LazyHolder 기법"></a>LazyHolder 기법</h2><p>책에는 소개되지 않지만 싱글턴 기법으로 <code>LazyHolder</code> 라는 방법이 있다.</p><p>책에서는 Enum 방식을 안전하다고 제안하고 있지만 Android 같이 <a href="https://www.google.co.kr/search?q=androlid+Context" rel="external nofollow noopener noreferrer" target="_blank">Context</a> 의존성이 있는 환경일 경우, Singleton의 초기화 과정에 Context라는 의존성이 끼어들 가능성이 있다.</p><p><code>LazyHolder</code> 는 그에 대한 대안으로 나온 방법이다. JVM에게 객체의 초기화를 떠님기는 방식으로, 멀티스레드 환경에서도 객체의 단일성을 보장할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlyOne</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OnlyOne</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OnlyOne <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.IT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> OnlyOne IT = <span class="keyword">new</span> OnlyOne();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>객체 생성을 담당할 내부클래스를 하나 정의하는데, 이것이 <code>LazyHolder</code> 다.<br>OnlyOne 클래스는 초기에는 아무런 상태가 없기에 LazyHolder 클래스를 초기화하지 않지만, <code>getInstance</code> 메서드가 호출될 때 LazyHolder 가 로딩되며 초기화가 진행된다.</p><p>클래스의 내부의 클래스는 외부의 클래스가 초기화될때 초기화되지 않고, 클래스의 static 변수는 클래스를 로딩할 때 초기화되는 것을 이용한 기법이다.</p><p>Class 를 로딩하고 초기화하는건 JVM 의 영역이고 <code>Thread Safe</code> 를 보장한다.</p>]]></content>
    
    <summary type="html">
    
      인스턴스화를 막으려거든 private 생성자를 사용하라
    
    </summary>
    
      <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
      <category term="singleton" scheme="https://blog.javarouka.me/tags/singleton/"/>
    
      <category term="lazyholder" scheme="https://blog.javarouka.me/tags/lazyholder/"/>
    
  </entry>
  
  <entry>
    <title>Java 의 Serialize (Effective java 3th - Item3)</title>
    <link href="https://blog.javarouka.me/2018/11/19/serialize-java/"/>
    <id>https://blog.javarouka.me/2018/11/19/serialize-java/</id>
    <published>2018-11-18T15:00:00.000Z</published>
    <updated>2018-11-27T12:56:34.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Serialize"><a href="#Serialize" class="headerlink" title="Serialize?"></a>Serialize?</h2><p>JVM 메모리 - Heap or Stack - 에 있는 객체 데이터를 바이트 형태로 변환하는 기술. 이 역방향 변환을 Deserialize 라고 한다.</p><p>Java 에서의 <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" rel="external nofollow noopener noreferrer" target="_blank">Primitive Data Types</a>은 별도의 처리 없이도 Serialize 가 가능하다. 다만 Object 형식의 객체는 <a href="https://docs.oracle.com/javase/9/docs/api/java/io/Serializable.html" rel="external nofollow noopener noreferrer" target="_blank">java.io.Serializable</a> 을 구현해야 Serialize 대상이 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Serializable 를 구현해서 Serialize 가능하게 한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sleep</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> duration;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sleep</span><span class="params">(<span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Serialize 에는 <a href="https://docs.oracle.com/javase/9/docs/api/java/io/ObjectOutputStream.html" rel="external nofollow noopener noreferrer" target="_blank">java.io.ObjectOutputStream</a> 을 사용한다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Sleep sleep = <span class="keyword">new</span> Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    ByteArrayOutputStream arraySerializer = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream objectSerializer = <span class="keyword">new</span> ObjectOutputStream(arraySerializer);</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 실제 Serialize 수행</span></span><br><span class="line">    objectSerializer.writeObject(sleep);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 배열로 저장</span></span><br><span class="line">    persistSerialized(arraySerializer.toByteArray());</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span>(IOException serializeFailed) &#123;</span><br><span class="line">    handleSerializeFail(serializeFailed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p>Serialize/Deserialize 간에 Serialize 대상의 고유 번호 표시이다.</p><p>Serialize 인터페이스를 상속한 클래스는 가급적 이 번호도 추가하는게 좋다.</p><p><code>serialVersionUID</code>는 명시적인 선언 없이도 자동으로 생성되나 없을 경우 <a href="https://docs.oracle.com/javase/10/docs/specs/serialization/class.html#inspecting-serializable-classes" rel="external nofollow noopener noreferrer" target="_blank">특정 알고리즘을 사용</a> 하여 클래스의 해시값으로 지정된다.</p><p>Serialize 는 상당히 까다롭게 동작한다.</p><p>클래스가 같더라도 Serialize/Deserialize 시에 serialVersionUID 값이 다르다면 InvalidClassException 이 던져진다</p><p>자동 생성된 serialVersionUID 는 클래스의 해시값이기에 클래스 구조에 변화가 생기면 다를 수밖에 없다. 또한, 명시적인 선언이 있어도 데이터 타입이 변경될 경우 오류가 발생한다. 이 경우에는 InvalidClassException 이 던져진다.</p><h2 id="Pre-Process-Methods"><a href="#Pre-Process-Methods" class="headerlink" title="Pre-Process Methods"></a>Pre-Process Methods</h2><p>Serialize/Deserialize 중 Singleton 등의 인스턴스 제한, 알수없는 데이터에 대한 Deserialize 검증 등의 특수한 처리가 필요할 경우가 종종 있다.</p><p>이럴 경우에 대해 Serialize 전처리 메서드들이 준비되어 있다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br><span class="line"><span class="function">Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br><span class="line"><span class="function">Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br></pre></td></tr></table></figure><h3 id="writeObject-readObject"><a href="#writeObject-readObject" class="headerlink" title="writeObject/readObject"></a>writeObject/readObject</h3><p>해당 class 에 위의 전처리 메서드를 구현할 경우 Serialize/Deserialize 시에 호출된다. 보통은 해당 클래스의 상태에 전처리를 할때 사용한다.</p><p>특정 데이터를 writeObject 시에 추가한뒤 readObject 시에 다시 읽거나, 외부 시스템으로부터 받은 수상한 데이터에 대한 방어 목적으로도 사용할 수 있다. 객체에 특정 서명을 추가하거나 해서 어느정도의 보안도 적용 가능해진다.</p><p>만일 이 메서드에서 NotSerializableException 을 던지게 되면 Serialize 가 불가능하게 된다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * place 필드는 transient 로 실제 직렬화 대상이 아니지만</span></span><br><span class="line"><span class="comment"> * writeObject/readObject 구현으로 추가로 직렬화에 포함시켰다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sleep</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> duration;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String place;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sleep</span><span class="params">(<span class="keyword">int</span> duration, String place)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.duration = duration;</span><br><span class="line">        <span class="keyword">this</span>.place = place;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.defaultWriteObject(); <span class="comment">// static, transient 필드를 제외하고 현재 객체에서 데이터를 읽는다.</span></span><br><span class="line">        out.writeObject(<span class="keyword">this</span>.place);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        in.defaultReadObject(); <span class="comment">// static, transient 필드를 제외하고 현재 객체로 데이터를 읽는다. </span></span><br><span class="line">        <span class="keyword">this</span>.place = (String) in.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readObjectNoData"><a href="#readObjectNoData" class="headerlink" title="readObjectNoData"></a>readObjectNoData</h3><p><a href="https://stackoverflow.com/questions/7445217/java-when-to-add-readobjectnodata-during-serialization/7445415" rel="external nofollow noopener noreferrer" target="_blank">https://stackoverflow.com/questions/7445217/java-when-to-add-readobjectnodata-during-serialization/7445415</a></p><h3 id="writeReplace-readResolve"><a href="#writeReplace-readResolve" class="headerlink" title="writeReplace/readResolve"></a>writeReplace/readResolve</h3><p>이 메서드를 구현해서 원래 Serialize/Deserialize 대상 객체를 변경할 수 있다.<br>직렬화에 대한 프록시 기능이나 인스턴스 수 제한에 유용하다.</p><p>링크 하나 공유한다.</p><p><a href="http://thecodersbreakfast.net/index.php?post/2011/05/12/Serialization-and-magic-methods" rel="external nofollow noopener noreferrer" target="_blank">Serialization and magic methods</a></p>]]></content>
    
    <summary type="html">
    
      private 생성자나 열거 타입으로 싱글턴임을 보장하라
    
    </summary>
    
      <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
      <category term="serialize" scheme="https://blog.javarouka.me/tags/serialize/"/>
    
  </entry>
  
  <entry>
    <title>빌더 패턴 (Effective java 3th - Item2)</title>
    <link href="https://blog.javarouka.me/2018/11/14/builder/"/>
    <id>https://blog.javarouka.me/2018/11/14/builder/</id>
    <published>2018-11-13T15:00:00.000Z</published>
    <updated>2018-11-27T12:56:34.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="객체-생성시에-거슬리는-요인"><a href="#객체-생성시에-거슬리는-요인" class="headerlink" title="객체 생성시에 거슬리는 요인"></a>객체 생성시에 거슬리는 요인</h2><ul><li>많은 인자<ul><li>인자의 순서를 실수할 경우가 잦아진다</li></ul></li><li>기본값<ul><li>옵셔널 기본값을 주고 싶지만 주기 어렵다</li></ul></li><li>많은 멤버<ul><li>수많은 멤버를 가진 객체의 경우 생성자가 비대해진다</li></ul></li></ul><p>기본 생성자 호출 뒤 Setter로 하나하나 세팅하는 방법도 있지만 시간의 흐름에 따라 멤버가 초기화되기에 일관성이 해쳐진다.</p><p>그리고 불변객체를 만들 수 없어 스레드, 코딩 안정성이 저하된다.</p><h2 id="그래서-준비했습니다"><a href="#그래서-준비했습니다" class="headerlink" title="그래서 준비했습니다"></a>그래서 준비했습니다</h2><h3 id="일반적인-빈즈의-빌더-패턴"><a href="#일반적인-빈즈의-빌더-패턴" class="headerlink" title="일반적인 빈즈의 빌더 패턴"></a>일반적인 빈즈의 빌더 패턴</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Car &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Car</span><span class="params">(String name, <span class="keyword">int</span> price, Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name; <span class="comment">// 필수값</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> price = <span class="number">0</span>; <span class="comment">// 기본값</span></span><br><span class="line">        <span class="keyword">private</span> Color color = Color.RED; <span class="comment">// 기본값</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">price</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.price = price;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">color</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.color = color;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Car <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Car(</span><br><span class="line">                <span class="keyword">this</span>.name, </span><br><span class="line">                <span class="keyword">this</span>.price, </span><br><span class="line">                <span class="keyword">this</span>.color</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="사용"><a href="#사용" class="headerlink" title="사용"></a>사용</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car superMyCar = <span class="keyword">new</span> Car.Builder(<span class="string">'내 애마'</span>)</span><br><span class="line">    .price(<span class="number">9999999999</span>)</span><br><span class="line">    .color(Color.INDIGO)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok!"></a>Lombok!</h2><p><a href="https://projectlombok.org/features/Builder" rel="external nofollow noopener noreferrer" target="_blank">@Builder</a></p>]]></content>
    
    <summary type="html">
    
      생성자에 매개변수가 많다면 빌더 패턴을 고려하라
    
    </summary>
    
      <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
      <category term="serialize" scheme="https://blog.javarouka.me/tags/serialize/"/>
    
  </entry>
  
  <entry>
    <title>객체 생성 정적 팩토리 메서드를 쓰는게 왜 유리한가 (Effective java 3th - Item1)</title>
    <link href="https://blog.javarouka.me/2018/11/12/static-creator/"/>
    <id>https://blog.javarouka.me/2018/11/12/static-creator/</id>
    <published>2018-11-11T15:00:00.000Z</published>
    <updated>2019-05-06T07:38:57.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="생성자-기본지식"><a href="#생성자-기본지식" class="headerlink" title="생성자 기본지식"></a>생성자 기본지식</h2><p>java 에서의 보통의 객체 생성은 new 를 사용한다</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>공개된(public) 생성자를 new 연산자와 함께 호출해서 객체를 생성한다.</p><p>이 과정에서 알아둘 생성자에 대한 몇가지 기본적인 지식이 있다</p><ul><li>class 정의 시 생성자를 정의하지 않았다면 기본적으로 인자가 없는 생성자가 언어레벨에서 지원된다.</li><li>Subclassing 된 class 라면 자식 생성자 호출 시 부모의 생성자도 연쇄적으로 호출한다. 생성자 체이닝이라고도 부른다.</li><li>어떤 클래스가 기본 생성자가 아닌 생성자가 정의되었다면 Subclass 도 반드시 생성자를 정의해야 한다. 그리고 그 생성자에는 super로 명시적 체이닝을 해줘야 한다</li></ul><p>생성자 호출은 모듈에는 Spring 등의 <a href="https://en.wikipedia.org/wiki/Dependency_injection#Dependency_injection_frameworks" rel="external nofollow noopener noreferrer" target="_blank">DI Framework</a> 를 쓰고, 일반 객체는 <a href="https://johngrib.github.io/wiki/builder-pattern/" rel="external nofollow noopener noreferrer" target="_blank">Builder 패턴</a> 을 사용하게 되면 거의 쓸일이 없어진다.</p><p>하지만 독자 레이어링 시에는 간간히 호출하는 경우가 있기에 알아두면 좋을 것 같다.</p><h2 id="정적-팩토리-메서드"><a href="#정적-팩토리-메서드" class="headerlink" title="정적 팩토리 메서드"></a>정적 팩토리 메서드</h2><p>이 책에서 생성자 대신 정적 팩토리 메서드 생성을 추천하는 이유로 5가지를 들고 있다.</p><h3 id="이름을-가질-수-있다"><a href="#이름을-가질-수-있다" class="headerlink" title="이름을 가질 수 있다"></a>이름을 가질 수 있다</h3><p>객체 생성의 목적은 상황에 따라 다르다. 그리고 그 결과가 어떤 값이 될련지는 생성자 정의에 따라 달라지지만 <code>new XXX</code> 로 호출하는 표현에는 명시적으로 나와있지 않다.</p><p>이름을 가지게 되면 해당 생성의 목적을 이름에 표현할 수 있어 가독성이 증가한다.</p><h3 id="객체-생성-제한이-가능하다"><a href="#객체-생성-제한이-가능하다" class="headerlink" title="객체 생성 제한이 가능하다"></a>객체 생성 제한이 가능하다</h3><p>객체 생성에 제한을 걸거나, 불변 객체를 매번 반환하는 등의 요령을 쓸 수 있다.<br>상황에 따라 신규 생성인지 기존 객체 반환인지도 정할 수 있다.</p><h3 id="SubClass-를-반환할-수-있다"><a href="#SubClass-를-반환할-수-있다" class="headerlink" title="SubClass 를 반환할 수 있다"></a>SubClass 를 반환할 수 있다</h3><p>상속 계층과 타입 상 하위 객체를 반환할 수 있고, 사용자는 그걸 모른채로 사용할 수 있다.</p><p>특정 버전의 class 정적 팩토리 메서드가 하위클래스 A를 반환하다가, 역시 Sub-Classing 된 B 를 반환하더라도 Client 코드에서는 그걸 신경쓰지 않고 작업이 가능하다.</p><p>기본적인 생성자를 사용한다면 구현체 자체가 바뀌었기에 Client 코드의 변경이 불가피해진다.</p><h3 id="입력-매개변수에-따라-다른-타입으로-반환-가능하다"><a href="#입력-매개변수에-따라-다른-타입으로-반환-가능하다" class="headerlink" title="입력 매개변수에 따라 다른 타입으로 반환 가능하다"></a>입력 매개변수에 따라 다른 타입으로 반환 가능하다</h3><p>위 <code>SubClass 를 반환할 수 있다</code> 랑 비슷한 이점이다. 매개변수에 따라 선택적인 Sub-Classing 된 객체를 반환할 수 있다.</p><h3 id="실제-구현체-클래스가-없어도-된다"><a href="#실제-구현체-클래스가-없어도-된다" class="headerlink" title="실제 구현체 클래스가 없어도 된다"></a>실제 구현체 클래스가 없어도 된다</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">newTruck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; truckClz = Class.forName(<span class="string">"me.javarouka.vehicle.Truck"</span>);</span><br><span class="line">        <span class="keyword">return</span> truckClz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">newBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; busClz = Class.forName(<span class="string">"me.javarouka.vehicle.Bus"</span>);</span><br><span class="line">        <span class="keyword">return</span> busClz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드처럼 처음 클래스가 로더에 존재하지 않아도 동적으로 현재 코드가 실행되는 클래스 로더에 해당 클래스 (예제에서는 com.vehicle.Truck, com.vehicle.Bus) 들을 로딩한다.</p><p>그리고 그 클래스의 인스턴스를 생성해서 반환할 수 있다.</p><blockquote><p>추가적으로 Class.forName 으로 로딩된 클래스들은 static 구문을 수행한다 . 보통 JDBC 3.x 이하를 써본 사람은 많이 본 코드일 것이다</p></blockquote><h2 id="정적-팩토리-메서드의-단점"><a href="#정적-팩토리-메서드의-단점" class="headerlink" title="정적 팩토리 메서드의 단점"></a>정적 팩토리 메서드의 단점</h2><p>책에서는 2가지를 소개하고 있지만 큰 단점으로 보이지 않는다.</p><ul><li>Sub-Classing 어려움</li><li>문서화</li></ul><p>하지만 둘다 큰 단점으로 보이진 않는다.<br>오히려 이시대의 사회악처럼 되어버린 상속을 방지하는 부가효과(?) 가 있고, 문서화는 코드 표현과 네이밍으로 대체할 수 있기 때문이다.</p><p>주로 쓰는 네이밍들은 다음과 같다.</p><ul><li>from<ul><li>매개변수 하나인 메서드</li></ul></li><li>of<ul><li>매개변수가 N개인 메서드</li></ul></li><li>getInstance<ul><li>인스턴스를 생성한다. 앞서 반환한 객체와 같을 수도 있다.</li></ul></li><li>newInstance<ul><li>인스턴스를 생성한다. 앞서 반환한 객체와는 항상 다르다.</li></ul></li><li>getSomeType<ul><li>인스턴스를 생성하지만 자신의 타입이 아닌 다른 타입 (SomeType) 으로 반환한다. 다른 내용은 <code>getInstance</code> 와 같다</li></ul></li><li>newSomeType<ul><li>인스턴스를 생성하지만 자신의 타입이 아닌 다른 타입 (SomeType) 으로 반환한다. 다른 내용은 <code>newInstance</code> 와 같다</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      객체 생성 정적 팩토리 메서드를 쓰는게 왜 유리한가 (Effective java 3th - Item1)
    
    </summary>
    
      <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
      <category term="serialize" scheme="https://blog.javarouka.me/tags/serialize/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java 3th 정리노트</title>
    <link href="https://blog.javarouka.me/2018/11/10/effective-java/"/>
    <id>https://blog.javarouka.me/2018/11/10/effective-java/</id>
    <published>2018-11-09T15:00:00.000Z</published>
    <updated>2018-11-28T14:05:20.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-3th-정리노트"><a href="#Effective-Java-3th-정리노트" class="headerlink" title="Effective Java 3th 정리노트"></a>Effective Java 3th 정리노트</h2><ul><li><a href="/2018/11/12/static-creator">Item 1 객체 생성 정적 팩토리 메서드를 쓰는게 왜 유리한가</a></li><li><a href="/2018/11/14/builder">Item 2 생성자에 매개변수가 많다면 빌더 패턴을 고려하라</a></li><li><a href="/2018/11/19/serialize-java">Item 3 private 생성자나 열거 타입으로 싱글턴임을 보장하라</a></li><li><a href="/2018/11/20/no-instance">Item 4 인스턴스화를 막으려거든 private 생성자를 사용하라</a></li><li><a href="/2018/11/20/dependency-inject">Item 5 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라</a></li><li><a href="/2018/11/25/불필요한-객체생성-회피">Item 6 불필요한 객체 생성을 피하라</a></li><li><a href="/2018/11/26/Finalizer와-Cleaner">Item 8,9 finalizer 와 cleaner 사용을 피하라 &amp; Try-With-Resource</a></li><li><a href="/2018/11/27/object-equals-liskov">Item 10 equals 는 일반 규약을 지켜 재정의하라</a></li><li><a href="/2018/11/28/java의-HashMap-구현에-대해">Item 11 equals를 재정의하려거든 hashCode도 재정의하라</a></li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      책 읽고 간단히 정리한 흔적들
    
    </summary>
    
      <category term="Effective Java" scheme="https://blog.javarouka.me/categories/effective-java/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="effective" scheme="https://blog.javarouka.me/tags/effective/"/>
    
  </entry>
  
  <entry>
    <title>신규 통합 CS 시스템 관리 개발기 # 설계편</title>
    <link href="https://blog.javarouka.me/2018/10/28/new_project_1/"/>
    <id>https://blog.javarouka.me/2018/10/28/new_project_1/</id>
    <published>2018-10-27T15:00:00.000Z</published>
    <updated>2018-11-24T00:16:26.091Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>신규 통합 CS 시스템 관리 개발기 # 설계편 #</li><li><a href="/2018/11/23/new_project_2/">신규 통합 CS 시스템 관리 개발기 # 혼란편 #</a></li></ul><hr><h2 id="Customer-Service-관리-시스템-개발"><a href="#Customer-Service-관리-시스템-개발" class="headerlink" title="Customer Service 관리 시스템 개발"></a>Customer Service 관리 시스템 개발</h2><p>전자상거래의 CS 관리 시스템이라는 건 생각보다 복잡하다.</p><ul><li>회원정보 조회</li><li>회원 정보 (아이디, 계좌, 주소지 …때로는 탈퇴처리) 변경</li><li>이 회원이 주문한 내역</li><li>이 회원이 최근 주문한 상품</li><li>이 회원의 상담 이력</li><li>상품 판매 업체와 연동</li><li>택배 연동</li><li>메시지, 전화 등의 Channel 연동</li><li>etc …</li></ul><p>사실상 전자상거래의 모든 도메인이 다뤄진다고 볼 수 있다.</p><p>그만큼 의존성이 문어발 식으로 연결되어있고, 그 만큼 타 도메인의 변화에 영향을 많이 받는다.</p><p align="center"><br><img src="/asset/new_project/octocat.png" alt="나...?"><em>나 말하나…?</em><br></p><p>과장하면 타 도메인에서 재채기를 하면 감기에 걸릴수도 있는게 CS 관리 프로그램이다.</p><h2 id="버틸수가-없다"><a href="#버틸수가-없다" class="headerlink" title="버틸수가 없다"></a>버틸수가 없다</h2><p>MSA(<code>M</code>icro <code>S</code>ervice <code>A</code>rchitecture) 환경에서 동시다발적으로 벌어지는 각 도메인들의 변화를 추적하고 반영하다보면, 쉴새없는 오류와, 호환성 문제를 겪게 된다.</p><p>이런 상황을 잘 관리하지 못하면 결과는 끔찍하다.</p><p>쓰레기를 가득 실은 트럭이 도로 제한속도를 넘어 과속하는 것만으로 위험한데, 이 트럭이 사고가 나 전복된다면 쓰레기들이 도로를 가득 메우는 상황이 펼쳐질 것이다.</p><p>아마 CS 개발자 대부분이 어떤 로직에 추가사항을 넣으려고 할때</p><blockquote><p>이 코드는 누가 만들었지?!</p></blockquote><p>하며 <code>git blame</code> 을 (혹은 annotation) 을 안해본 사람이 없을 것이다.</p><p>(때로는 만든 사람이 자신인 웃기는 경우도 있다…)</p><p>테스트 코드 부재는 예사이고, 팀원들끼리 충분한 커뮤니케이션이 없으면 중복된 코드가 각자의 개성으로 암세포처럼 자라난다.</p><p>그 코드가 관련된 도메인이 변할 경우 이곳저곳에서 자란 해당 코드 모두가 수정되어야 한다.<br>새 기능이 추가될 때 하나라도 이 부분을 누락하면 바로 장애로 이어지거나 유지보수 이슈가 등록된다.</p><p>리팩토링에도 한계가 있다.</p><p>리팩토링 범위를 아무리 최소로 해도 하다보면 너무나 광범위한 영역을 다루게 되며 결국 포기하는 일이 많다. 리팩토링이 때로는 새로운 버그를 만들기도 한다. 이건 이 경우와는 별개로 애초에 잘못된 습관 탓도 있고, 다른 상황에서도 마찬가지인 경우가 많긴 하다.</p><p align="center"><br><img src="/asset/new_project/zealot.jpeg" alt="버틸..."><em>버틸수가 없다!</em><br></p><p>이런 환경속에서 부족한 리소스로 일을 진행하면서 몇차례의 개편을 하다보니 코드의 유지보수성에 많은 생각을 하게 되었다.</p><ul><li>외부 변화에 큰 타격이 없을 것</li><li>도메인 대응이 늦어도 해당 도메인의 기능을 제외하고는 정상 동작해야 할것</li><li>서버와 클라이언트의 분리가 될 것</li><li>새 기능의 추가가 쉬울 것</li><li>프로그램 속도에 문제가 없을 것</li><li>코드가 Readable 할 것</li><li>재미있을 것(?)</li></ul><p>이런 생각이 정리되어 가던 때에 드디어 다시한번 개편을 시도할 기회가 생기게 되었다. 신규 주문정보의 개편이 시작된 것이다. 이번이 나에겐 4번째이다.</p><p>그동안 고민했던 문제들을 쭉 펼쳐보고 기존에서 바꾼 방법을 하나하나 적어보겠다.</p><p>모든 것은 <code>팀원들과의 회의를 통해 결정</code> 했다. 이 과정은 상당히 길고 잦었지만 그 시간은 상당히 유익했던 시간이었다</p><h2 id="새로운-방법"><a href="#새로운-방법" class="headerlink" title="새로운 방법"></a>새로운 방법</h2><h3 id="Layer"><a href="#Layer" class="headerlink" title="Layer"></a>Layer</h3><p>기존의 구조는 Spring 의 Controller - Service - Repository or Domain API 의 정석적인(?) 구조였다.</p><p><a href="https://zetawiki.com/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_%EC%A3%BC%EB%8F%84_%EC%84%A4%EA%B3%84_DDD" rel="external nofollow noopener noreferrer" target="_blank">DDD</a> 방식으로의 전환도 고려해보았지만, 5년을 넘게 일해도 이해할 수 없는 여러 비즈니스들과 도메인 개념들, 그리고 팀 전체적으로 (나 포함) 낮은 DDD 숙련도 등으로 그냥 전통적인 Controller - Service - Repository or Domain API 로 결정했다.</p><p>약간 아쉽기도 하지만, 시간이라는 제약도 있고 익숙하지 않은 모험을 하기에는 약간 위험했다.</p><p>다만 저 기본적인 흐름에 레이어링을 적용하기로 했다.</p><ul><li><code>Controller</code><ul><li>외부 요청을 처리하는 용도. 일반적인 Controller.</li></ul></li><li><code>Service</code><ul><li>요청에 대한 비즈니스 로직의 묶음. 비즈니스가 변할 경우 서비스만 재작성하면 된다.</li><li>여러 비즈니스 단위 모듈 의존성을 주입받아 처리한다. 하나의 의존성만 있을 수 있고, 여러 비즈니스가 얽힌 의존성이 처리될 수도 있다.</li></ul></li><li><code>Business Logic Behavior</code><ul><li>단일 비즈니스를 처리하기 위한 모듈</li><li>Repository 등에 의존성이 있다.</li></ul></li><li><code>Repository</code><ul><li>팀 오너십 데이터에 대한 CRUD 및 외부 API 에 대한 래퍼.</li><li>Repository 와 Api 를 나누려고 했으나 그냥 하나의 레이어로 래핑하기로 함.</li></ul></li><li><code>Helper</code><ul><li>유틸리티. 무상태이거나 Controller, Service, Behavior, Repository 에는 의존성이 없는 모듈.</li><li>순수 함수들의 집합.</li></ul></li></ul><p>Helper 를 제외한 각 레이어끼리는 의존성을 걸지 않는게 기본이다.</p><p>초창기에는 Collector Layer 도 추가했지만, 나중에 설명할 <code>데이터 토막치기</code> 덕분에 잘 쓰이지 않아 사장되었다. Collector 는 각 데이터를 Aggregation 하는 레이어였다.</p><h3 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h3><p>DTO 도 구분했다.</p><p align="center"><br><img src="/asset/new_project/dto.jpeg" alt="박스"><em>데이터의 포장에도 각자의 목적이 있다</em><br></p><p>기본적으로 Request 로 받는 Condition 류를 제외한 모든 DTO 에는 모든 필드가 <code>final</code> 로 불변객체이다.</p><p>불변이 아닐 경우 각 로직이나 레이어를 거치면서 전달되는 객체의 필드가 실제 값이 있는지, 중간에 값이 어떻게 변하는지, 등의 상황에서 한 레이어만 보고서는 추적이 되지 않기 때문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 확장성이 없고 반드시 필요한 순서대로 호출해야만 한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 주문정보를 읽는다</span></span><br><span class="line">DetailOrderDTO order = <span class="keyword">this</span>.readOrderData(orderId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주문에 상품정보를 넣는다</span></span><br><span class="line">order = productModule.appendProductData(order);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주문에 업체정보를 넣는다</span></span><br><span class="line">order = vendorModule.appendVendorData(order);</span><br></pre></td></tr></table></figure><p>이러한 로직이 있을 경우 <code>productModule.appendProductData</code>, <code>vendorModule.appendVendorData</code> 는 주문의 특정 필드의 nullable 여부가 중요해진다. 게다가 상품에 업체정보가 있으므로 앞선 로직에서 상품정보가 정상적이지 않을 경우 다음 업체정보도 얻을 수 없게 된다.</p><p>이 상황에서는 필드의 초기화 여부와 각 모듈의 호출 순서가 매우 중요하다. 이 규칙아래 에서 모듈 의존성 뿐 아니라 로직 의존성까지 발생한다.</p><p>리팩토링을 할 때도 문제가 된다.</p><p>각 모듈 호출 순서를 반드시 지켜야 하며 각 모듈안의 로직을 자세히 살펴보고 완전히 로직을 파악한 뒤에야 리팩토링을 할 수 있다.</p><p>하지만, 모든 필드가 <code>final</code> 일 경우 어떠한 DTO 를 전달받았을 경우 각 필드들이 반드시 초기화가 되었다는 걸 의미하기에 앞선 문제의 대부분이 해소된다. 어디선가 전달받은 객체라도 값의 내용물에 대해 안심하고 쓸 수 있다는 뜻이다. (필드의 Null 여부가 아니라 초기화 여부를 말한다)</p><p>각 레어이간 데이터는 다음과 같은 기준으로 정했다. 네이밍이 약간 이상한것 같지만 그런가보다 하자;</p><ul><li><code>VO</code><ul><li>Repository 등에서 얻는 기본 데이터.</li></ul></li><li><code>Condition</code><ul><li>Client 의 요청 데이터. 불변처리가 힘들기에 일반적인 Setter 가 달려있다.</li></ul></li><li><code>Form</code><ul><li>비즈니스 로직 단위의 요청 폼. 대부분 서비스에서 생성되어 각 비즈니스 처리기에 전달된다.</li></ul></li><li><code>Result</code><ul><li>각 VO 를 수집하여 Client 가 요구하는 데이터로 빌드되는 DTO</li></ul></li></ul><p>예를 들면, MemberFindCondition 으로 요청되면 서비스는 그 요청으로 각 비즈니스에 MemberFindForm, MemberBlockForm, MemberXXXForm 등을 만들어 처리하고 그 결과를 MemberFoundResult 로 응답한다.</p><h3 id="Data-Aggregation"><a href="#Data-Aggregation" class="headerlink" title="Data Aggregation"></a>Data Aggregation</h3><p>다양한 도메인을 한번에 다루는 CS 특성상 여러 도메인의 데이터를 조합하는 경우가 많다.</p><p align="center"><br><img src="/asset/new_project/bibim.jpeg" alt="비빔밥" title="비빔밥"><em>재료를 잘 섞어야 맛있다.</em><br></p><p>어디에도 끼는 회원이나 상품 말고도 CS의 99% 이상의 문의가 주문 관련이니 주문 데이터와 주문에 따라오는 배송 데이터 등은 항상 데이터 조합 대상이다.</p><p>기존 시스템은 클라이언트 요청에 서버는 각 도메인의 데이터를 한번에 합쳐서 보여주는 방식으로 동작했다. 가령 회원이 최근에 주문한 데이터를 봐야 한다면 회원정보, 주문정보, 상품정보, 배송정보, 취소정보를 읽은 뒤 조합했다.</p><p>요청이 하나만 있을 경우에는 이 방법도 나쁘지 않지만, 요청이 다수가 겹칠 경우 문제가 될 수 있다. 요청하는 데이터끼리 중복되는 데이터를 포함할 수 있기 때문이다.</p><p>최근 주문목록을 보여주는 컴포넌트가 있고 주문목록에서 특정 주문을 선택할 경우 다시 해당 주문의 상세를 보여주는 UI가 있다고 가정한다면,<br>매 요청의 응답에는 공통적으로 연관 상품정보, 취소정보, 결제정보, 배송정보가 포함되게 된다.</p><p>불필요한 반복적 요청이 되는 셈이다.</p><p>게다가 비즈니스의 변화로 데이터에 변화가 생길 경우 각 화면별로 더 추가되거나 제거될 수 있어 수정도 동시에 여러 군데에서 일어난다.</p><p>이런 방법보다 데이터의 조합은 연관결합도가 높은 것끼리만 하고, 공통적인 데이터는 분할 요청하는 방식을 선택했다.</p><p>난 이걸 <code>데이터 토막치기</code> 라고 (나 혼자 쓰는 용어이다) 명명했다.</p><h3 id="데이터-토막치기"><a href="#데이터-토막치기" class="headerlink" title="데이터 토막치기"></a>데이터 토막치기</h3><p align="center"><br><img width="320" src="/asset/new_project/Dr Salvador.jpg" alt="닥터 살바도르" title="닥터 살바도르"><em>토막쳐보자… 부우우우우웅!!</em><br></p><p>최근 주문목록에 필요한 데이터를 조합한다고 가정해보자</p><ol><li>회원정보 요청</li><li>회원이 주문한 내역 리스트 데이터를 최근 순으로 요청</li><li>주문내의 정보로 다음 정보 요청<ul><li>주문 내의 상품정보로 상품 정보 요청</li><li>주문 아이디로 결제 정보 요청</li><li>주문 아이디로 취소 정보 요청</li></ul></li><li>상품 정보가 응답되면 그 정보로 다시 업체 정보 요청</li><li>상품 정보로 상품의 각 배송타입, 유형, 카테고리 정보 요청</li></ol><p>각 정보를 조합해서 화면에 표시한다.</p><p>여기서 다시 특정 주문의 상세를 보고 싶다고 한다면 앞서 요청한 상품상세와 각 메타데이터, 업체, 결제, 취소 정보는 요청하지 않아도 된다.<br>필요한 상세 데이터를 추가 요청한뒤 데이터를 조합하면 끝이다.</p><p>그리고 다른 주문번호를 보다가 다시 같은 주문 상세를 조회할 경우, 이미 로딩된 정보를 활용할 수도 있다.<br>어떤 데이터 종류는 갱신이 자주 되는 데이터는 만료 관리가 필요하거나 아예 새로 로딩해야 할 때도 있지만, 대부분의 경우 앞서 설명한 <code>로딩된 데이터끼리의 조합</code> 방식이 훨씬 유리하다.</p><p>이렇게 데이터를 최대한 분할하여 재활용성과 서버 자원 낭비를 줄이고 성능 향상도 고려했다. 모든 데이터를 토막치는게 아닌 비즈니스나 UI 상황, 효율및 결합도에 따라 데이터 구성을 하여 합치는게 유리하다는 것도 잊지 않았다.</p><p>마침 적용하려고 하는 상태관리기 <a href="https://lunit.gitbook.io/redux-in-korean/" rel="external nofollow noopener noreferrer" target="_blank">Redux</a> 의 selector 개념과 이를 보좌해주는 <a href="https://github.com/reduxjs/reselect" rel="external nofollow noopener noreferrer" target="_blank">Reselect</a> 는 이런 방식에 찰떡 궁합이었고, 디렉토리 구조도 그에 맞게 가져갔다.</p><h2 id="서버-기반을-수정해보자"><a href="#서버-기반을-수정해보자" class="headerlink" title="서버 기반을 수정해보자"></a>서버 기반을 수정해보자</h2><p>서버 개발에서는 특별한 개선을 하기 어려웠다.</p><p>프로젝트를 온전하게 새로 설정했으면 좋았겠지만, 기존부터 쌓인 코드에 의존성이 상당하고 타 팀의 코드도 섞여 있기에 서버의 완전한 새판 짜기는 불가능했다. 위에 설명했던 레이어링 및 패키지와 설정 파일의 분리 정도가 가능했고, 나머지 모듈 의존성 등은 크게 손댈 수 없었다.</p><p>기회가 된다면 Spring Boot 부터 Mbean 등을 좀 더 잘 써보고 싶은데… 한다면 팀 스탠드얼론이 가능한 프로젝트에나 도입할 수 있을 것 같아 아쉽다.</p><p align="center"><br><img width="320" src="/asset/new_project/simu.jpg" alt="ㅠㅠ" title="ㅠㅠ"><em>OTL</em><br></p><h2 id="클라이언트-기반을-수정해보자"><a href="#클라이언트-기반을-수정해보자" class="headerlink" title="클라이언트 기반을 수정해보자"></a>클라이언트 기반을 수정해보자</h2><p>클라이언트는 이야기가 달라서 완전한 재설정이 가능했다.</p><p>클라이언트쪽은 기존의 나쁜 냄새를 모두 제거하기 위해 바닥부터 새로 시작하기로 했다.</p><ul><li>Global N Sub 방식의 Multi-Store</li><li>클라이언트 사이드 라우팅</li><li>스크립트 용량 축소</li><li>컴포넌트의 재사용성</li><li>사용자 액션 추적</li><li>에러 리포트</li></ul><h3 id="Multi-Store"><a href="#Multi-Store" class="headerlink" title="Multi Store"></a>Multi Store</h3><p>Redux 는 기본적으로 단일 스토어를 추천한다.</p><p>하지만 새로 개편하는 어플리케이션에는 단일 스토어의 이점이 전혀 떠오르지 않았다.</p><p>데이터가 각 회원 혹은 주문 단위로 휘발성이며 상태들의 재사용성이나 히트율이 낮고, 동일한 구조의 회원이나 주문 등의 컨텍스트만 다른 데이터가 대다수이다.</p><p>이 역시 컨텍스트가 바뀌면 버려진다.</p><p>게다가 개편 대상인 어플리케이션은 동적 탭 단위의 구조이다. 같은 탭이 여러개 열릴 수도 있다. 그러면 탭마다 관리되는 상태는 컨텍스트마다 종속 데이터를 관리해야 한다.</p><p>또한 탭이 바뀌거나 하면 화면의 모든 요소를 새 화면의 컨텍스트에 맞게 계산하고, 컴포넌트를 렌더링해야 한다. 탭 하나가 굉장히 많은 데이터를 가질텐데, 단순한 탭의 스위칭만으로 모든 요소가 새로 그려질 것이고 그만큼 화면의 부하는 커진다.</p><p>컨텍스트에 따른 reducer - state 설계도 만만치 않은데다, 성능저하는 단일 스토어에 대해 깊이 생각해보게 되었다.</p><p>결론은 전역 스토어는 하나 두고, 특정 컨텐츠 탭에 대해서는 서브 스토어를 생성하며 스토어를 가진 탭이 닫힐 경우 상태를 정리하는 것보다 그냥 그 스토어를 버리는 구조로 정하게 되었다.</p><p>자식 스토어는 선택적으로 부모 스토어에서 상태를 구독할 수 있고, 액션중 특정 <a href="https://developer.mozilla.org/ko/docs/Glossary/Symbol" rel="external nofollow noopener noreferrer" target="_blank">Symbol</a> 을 통해 전역 스토어에도 dispatch 를 할 수 있도록 설계했다.</p><h3 id="클라이언트-라우팅"><a href="#클라이언트-라우팅" class="headerlink" title="클라이언트 라우팅"></a>클라이언트 라우팅</h3><p align="center"><br><img width="320" src="/asset/new_project/routing.jpeg" alt="표지판" title="표지판"><em>이리저리 가시오</em><br></p><p>라우팅 기능을 하는 <a href="https://github.com/ReactTraining/react-router" rel="external nofollow noopener noreferrer" target="_blank">React-Router</a> 라는 훌륭한 라이브러리가 이미 존재하고, 이걸 쓰면 되겠지 라고 생각했다.</p><p>그러나 이리저리 돌려본 결과는 실제 CS 툴에는 그리 어울리지 않다는 결론을 내렸다.</p><p>다음과 같은 이유에서다.</p><ul><li>단일 스토어에 최적화되어 있다.</li><li>라우팅이 바뀔 경우 현재 스토어의 state 에 따라 컴포넌트를 새로 렌더링하는데, 만들려는 어플리케이션은 잦은 라우팅 변경이 있어서 성능 문제가 생긴다</li><li>props 가 아닌 state 의 관리가 어렵다</li></ul><p>결국 React Router 에서 Route 기능만을 빌려와서 직접 라우팅 시스템을 구현할 수밖엔 없었다.</p><p>겸사겸사 React Router 에서 지원하기 좀 애매한 동적 모듈 로딩 라우팅도 적용했다. (개발 당시에는 없었는데 <a href="https://reactjs.org/docs/code-splitting.html##reactlazy" rel="external nofollow noopener noreferrer" target="_blank">지금 버전에서는 잘 지원</a>하고 있더라…)</p><p>사용한 라이브러리는 <a href="https://github.com/kriasoft/universal-router" rel="external nofollow noopener noreferrer" target="_blank">Univasal-Router</a> 이다.</p><p>단순하지만 프로젝트에서 필요로 하는 모든 기능이 들어있었다.</p><h3 id="스크립트-용량-축소"><a href="#스크립트-용량-축소" class="headerlink" title="스크립트 용량 축소"></a>스크립트 용량 축소</h3><p>위에 잠깐 언급되었지만 기존 시스템의 스크립트 용량은 무려 5mb 였다.</p><p>어플리케이션에 사용되는 모든 스크립트를 하나의 파일로 만들어서 한번어 로딩하는 방식이었기 떄문이다.</p><p>이 방법으로 인해 성능이 느리거나 네트워크가 불량할 경우 어플리케이션이 상당히 느려졌었고, 브라우저으 javascript 성능이 다소 안좋을 경우 (IE…) 페이지가 한참동안 흰색으로 보이거나 Timeout 에 걸리는 <code>백화 현상</code> 이라는 일이 발생했었다.</p><p>이번에는 필요한 자원이 있을때 로딩하는 동적 로딩을 도입하기로 했다.</p><p>동적 로딩은 간단했다. webpack, babel 조합으로 간단히 import 구문으로 구현할 수 있었고, webpack 의 chunkName 조합으로 디버깅 및 파일 이름 지정도 가능했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 동적 컴포넌트 예시</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loadComponent = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'component/DynamicComponent'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        DynamicComponent: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        loadComponent().then(<span class="function"><span class="params">DynamicComponent</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                DynamicComponent</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; DynamicComponent &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">if</span>(!DynamicComponent) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;DynamicComponent /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>적용 후 첫 로딩 스크립트의 용량이 300kb 도 안될 정도로 좋아진 걸 보고 꽤나 좋았던 기억이 난다.</p><h3 id="컴포넌트-재사용성"><a href="#컴포넌트-재사용성" class="headerlink" title="컴포넌트 재사용성"></a>컴포넌트 재사용성</h3><p>이 문제는 참 어렵다.</p><p>재사용성을 아무리 고려해도 실제 이리저리 재활용을 하려고 하면 각자의 조금씩 다른 요구사항과 스타일 등에 버려지는 케이스가 많기 때문이다. 재활용성이 높은 컴포넌트는 무엇보다 이런 고민이 잘 커버되는 설계가 상당히 중요하다.</p><p>설계 능력이 그리 좋지 못한 덕분에 나는 아직도 재활용성이 높은 컴포넌트가 뭔지 헤메이고 있다.</p><p>그래도 노력이 나를 조금이나마 동정했는지, 몇몇 컴포넌트는 재사용성을 확보할 수 있었다. 디자인 요소를 배제할수록, 도메인 이해도가 높을 수록 재사용성이 높았던 것 같다.</p><ul><li>PureComponent 를 최대한 다수를 생성하려고 했다. 재활용의 시작이 되니까. React 16.6 에서는 <a href="https://reactjs.org/docs/react-api.html#reactmemo" rel="external nofollow noopener noreferrer" target="_blank">React.memo</a> 라는 것도 지원해서 PureComponent 사용이 더 좋아졌다.</li><li>재활용 요소는 가급적 <a href="https://reactjs.org/docs/fragments.html" rel="external nofollow noopener noreferrer" target="_blank">React.Fragment</a> 로 래핑한다. 이 요소가 어느 레이아웃으로 재활용될지 모르기 때문이다.</li><li>스타일 요소는 하나하나를 스타일링하지 말고 Styled-Component 로 대체할 수 있게 디자인한다.</li></ul><h3 id="사용자-액션-추적-에러-리포트"><a href="#사용자-액션-추적-에러-리포트" class="headerlink" title="사용자 액션 추적 / 에러 리포트"></a>사용자 액션 추적 / 에러 리포트</h3><p>이 문제는 사실 Redux의 middleware 만 잘 활용하면 달성이 쉽다.</p><p>다만, 액션으로 잡히지 않는 것까지 모두 처리하려면 직접적인 상태 변화가 없는 (다시 말하면 reducer 에서 처리하지 않는) 액션까지 디테일하게 설계해야 한다.</p><p>이런 건 보통 사이드이펙트 뿐인 작업을 수행할 때 발생하는데, 이런 것에 잘 어울리는 방식을 찾다가 Redux-Saga 를 도입하기로 했다.</p><p><a href="https://github.com/redux-saga/redux-saga" rel="external nofollow noopener noreferrer" target="_blank">Redux-Saga</a> 는 Redux 플로우에서 사이드이펙트를 관리하기 위한 미들웨어이다.</p><p>Redux Saga 로 사용자의 모든 행동은 Saga 를 통해 로깅되며 사이드이펙트로 서버에 리포트되도록 했다.</p><p>이런 액션 로깅은 <a href="https://www.elastic.co/kr/products/elasticsearch" rel="external nofollow noopener noreferrer" target="_blank">Elastic Search</a> 등으로 쌓아서 통계나 어플리케이션 사용 행태를 분석하는 용도로 쓰려고 준비중이다.</p><p>사용자의 흐름이나 행동 및 발생하는 에러를 분석하면 버그나 기능 개선, 사용율 체크에 큰 도움이 되지 않을까 한다. 에러 시에는 현재 상태의 스냅샷을 전송한다면 재현도 어렵지 않게 할 수 있기에 처리가 좀 더 쉬울것이라 예상한다.</p><p>서비스를 해봐야 알겠지만…</p><h3 id="클라이언트-단독-개발이-가능하도록"><a href="#클라이언트-단독-개발이-가능하도록" class="headerlink" title="클라이언트 단독 개발이 가능하도록"></a>클라이언트 단독 개발이 가능하도록</h3><p align="center"><br><img width="320" src="/asset/new_project/front-back.jpg" alt="프론트 엔드 백엔드" title="Front Castle on Back"><em>프론트 엔드 성 아래의 백 엔드 심해</em><br></p><p>요청사항에 따라 클라이언트 개발만 진행하거나 소소한 수정건이 있을 수 있다. 이런 경우 예전의 구조에서는 클라이언트 수정이라도 로컬 서버를 먼저 실행시키고 로컬 서버를 구동하여 개발을 진행했다.</p><p>이 방법이 나쁜건 아니나 어차피 현재 구조에서는 페이지 라우팅을 클라이언트에서 하는데다가, 인증과 데이터 말고는 서버가 화면에 하는 일이 없기때문에 굳이 클라이언트 수정할때 무거운 local WAS 를 실행시킬 필요가 없다고 생각했다.</p><p>이 구조에서는 데이터만 제공된다면 클라이언트 개발에는 무리가 없다.</p><p>가상 데이터를 제공할 수 있는 mock 서버를 시작하고 가상 데이터를 내려주는 로컬 서버를 시작하고 webpack-dev-server 를 mock 서버에 연결하는 작업으로 로컬서버만으로 개발이 가능하게 되었다.</p><p>mock 서버는 <a href="https://github.com/smollweide/node-mock-server" rel="external nofollow noopener noreferrer" target="_blank">node-mock-server</a> 을 사용했다.</p><p>문서가 다소 부족해서 사용법 사용에 애를 먹었지만, 파일 기반으로 GET, POST, PUT, DELETE 등 지원에 커스텀 파라미터에 따른 커스텀 데이터 생성기능까지 쓸만한 기능은 다 있어서 단순한 기능 사용에는 문제가 없었다.</p><p>webpack-dev-server 와 mock 연동에는 <a href="https://www.npmjs.com/package/express-http-proxy" rel="external nofollow noopener noreferrer" target="_blank">express-http-proxy</a> 를 사용했다.</p><p>이 방법으로 mock 연계를 하고나니 좀 더 나아가서 실제 서버로 화면 개발을 진행할 수 있을것 같았다.</p><p>추가 개발은 proxy 에 https 지원을 추가하고 npm 스크립트를 몇개 수정한 것 뿐으로 훌륭한 실서버 &lt;==&gt; webpack-dev-server 의 연계가 만들어졌다.</p><p>이 작업으로 클라이언트 개발 매우 편해져서 작업 효율이 크게 증가했다.</p><h2 id="아직이다"><a href="#아직이다" class="headerlink" title="아직이다"></a>아직이다</h2><p>지금까지 개선과 설계 방향을 쭉 나열한 것 같다.</p><p><a href="/2018/11/23/new_project_2/">다음 글</a> 에는 이러한 개념을 적용하며 겪은 문제점과 아쉬운 부분을 나열해보겠다.</p>]]></content>
    
    <summary type="html">
    
      일단 지른다
    
    </summary>
    
      <category term="Tech" scheme="https://blog.javarouka.me/categories/tech/"/>
    
    
      <category term="java" scheme="https://blog.javarouka.me/tags/java/"/>
    
      <category term="javascript" scheme="https://blog.javarouka.me/tags/javascript/"/>
    
      <category term="scaffolding" scheme="https://blog.javarouka.me/tags/scaffolding/"/>
    
      <category term="legacy" scheme="https://blog.javarouka.me/tags/legacy/"/>
    
      <category term="new-cs-system" scheme="https://blog.javarouka.me/tags/new-cs-system/"/>
    
  </entry>
  
  <entry>
    <title>Inline styles</title>
    <link href="https://blog.javarouka.me/2018/01/01/inline-styles/"/>
    <id>https://blog.javarouka.me/2018/01/01/inline-styles/</id>
    <published>2017-12-31T15:00:00.000Z</published>
    <updated>2018-11-20T11:36:26.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="인라인-스타일에-대한-생각"><a href="#인라인-스타일에-대한-생각" class="headerlink" title="인라인 스타일에 대한 생각"></a>인라인 스타일에 대한 생각</h2><ul><li>스타일이 각각의 엘레먼트에 있음으로 인해 HTML 문서의 용량이 증가. 이는 과한 트래픽으로 이어진다. CSS 의 경우엔 첫 로딩 이후에는 일반적으로 캐시되며 트래픽 감소 효과가 있다.</li><li>공통적 스타일을 변경할 경우 해당하는 모든 스타일을 수정해야 한다.</li><li>요소에 붙은 스타일을 보고 어떤 스타일인지 추론하는 것이 불가능하다. 예를 들어 highlight-box 라는 클래스네임이 있다면 강조 성격의 UI 블럭요소라고 추론해볼 수 있지만 인라인일 경우 직접 스타일 코드를 읽어야 한다.</li><li>Left-To-Right, Right-To-Left 등의 언어 방식의 경우 대응이 힘들어진다.</li></ul>]]></content>
    
    <summary type="html">
    
      Inline styles
    
    </summary>
    
      <category term="Tech" scheme="https://blog.javarouka.me/categories/tech/"/>
    
    
      <category term="css" scheme="https://blog.javarouka.me/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Lerna</title>
    <link href="https://blog.javarouka.me/2018/01/01/lerna/"/>
    <id>https://blog.javarouka.me/2018/01/01/lerna/</id>
    <published>2017-12-31T15:00:00.000Z</published>
    <updated>2018-11-20T11:36:26.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lerna"><a href="#Lerna" class="headerlink" title="Lerna"></a>Lerna</h2><h3 id="Official-Site"><a href="#Official-Site" class="headerlink" title="Official Site"></a>Official Site</h3><p><a href="https://lernajs.io/" rel="external nofollow noopener noreferrer" target="_blank">https://lernajs.io/</a></p><h3 id="links"><a href="#links" class="headerlink" title="links"></a>links</h3><ul><li><a href="https://gist.github.com/nolanlawson/457cdb309c9ec5b39f0d420266a9faa4" rel="external nofollow noopener noreferrer" target="_blank">Why we dropped Lerna from PouchDB</a></li><li><a href="https://hackernoon.com/the-highs-and-lows-of-using-lerna-to-manage-your-javascript-projects-ff5c5cd82a99" rel="external nofollow noopener noreferrer" target="_blank">The highs and lows of using Lerna to manage your JavaScript projects</a></li><li><a href="https://medium.com/trabe/monorepo-setup-with-lerna-and-yarn-workspaces-5d747d7c0e91" rel="external nofollow noopener noreferrer" target="_blank">Monorepo setup with Lerna and Yarn workspaces</a></li><li><a href="https://medium.com/@deptno/monorepo-yarn-workspace-e81e3e078100" rel="external nofollow noopener noreferrer" target="_blank">Monorepo? Yarn Workspace!</a></li><li><a href="https://medium.com/@patrickleet/mono-repo-or-multi-repo-why-choose-one-when-you-can-have-both-e9c77bd0c668" rel="external nofollow noopener noreferrer" target="_blank">Mono-repo or multi-repo? Why choose one, when you can have both?</a></li></ul><h3 id="What-Lerna"><a href="#What-Lerna" class="headerlink" title="What Lerna?"></a>What Lerna?</h3><p>Lerna 는 여러 패키지로 구성된 대규모 npm 프로젝트를 관리하기 위한 도구이다.<br>세분화된 구성 요소로 구성된 대구모 프로젝트의 경우 각 서브 프로젝트들의 의존성을 서로 관리하다보면 각 프로젝트별 업데이트 관리가 꽤나 힘들어진다.<br>이럴 경우 lerna 를 사용하여 대규모 프로젝트 관리에 큰 도움을 받을 수 있다.</p>]]></content>
    
    <summary type="html">
    
      Lerna 는 여러 패키지로 구성된 대규모 npm 프로젝트를 관리하기 위한 도구이다.
    
    </summary>
    
      <category term="Tech" scheme="https://blog.javarouka.me/categories/tech/"/>
    
    
      <category term="npm" scheme="https://blog.javarouka.me/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>운영되던 서비스, ES5 에서 ES6 으로 옮긴 이야기 2 (feat Webpack)</title>
    <link href="https://blog.javarouka.me/2017/05/14/convert-legacy-to-webpack-bundle-2/"/>
    <id>https://blog.javarouka.me/2017/05/14/convert-legacy-to-webpack-bundle-2/</id>
    <published>2017-05-14T14:30:17.000Z</published>
    <updated>2018-11-14T13:59:12.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2016년 5월부터 2016년 6월까지 진행된 나의 to ES6 삽질을 기록해본다. 100% Real 은 아니고… 95% 정도?</p></blockquote><p><a href="/2017/05/03/convert-legacy-to-webpack-bundle-1/">전 글</a></p><h2 id="버틸수가-없다"><a href="#버틸수가-없다" class="headerlink" title="버틸수가 없다"></a>버틸수가 없다</h2><p>전 포스트의 막바지에 썼듯이 실무는 실전이었다.</p><p>다음과 같은 문제를 부딪히며 하나하나 해결해 나갈 수 밖에 없었다.</p><h3 id="컨트롤러-매핑-문제"><a href="#컨트롤러-매핑-문제" class="headerlink" title="컨트롤러 매핑 문제"></a>컨트롤러 매핑 문제</h3><p>requirejs 를 쓰면서 AMD 식으로 필요할 때 스크립트를 로딩했는데, 이 부분부터 고쳐야 했다</p><p>Controller 의 이름이 만일 <code>order/MemberController</code> 라면 다음과 같은 방법으로 컨트롤러를 로딩한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const controllerPath = 'order/MemberController';</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">`controller/<span class="subst">$&#123;controllerPath&#125;</span>`</span>], ControllerClass =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> controlelr = <span class="keyword">new</span> ControllerClass(contentElement, controllerPath)</span><br><span class="line">    controlelr.execute();</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이 방법은 필요할 때 비동기로 네트워크 상에서 스크립트를 로딩하고, 완료 시 콜백 함수의 인자를 통해 모듈을 사용한다</p><p>일단은 기본적으로 모든 모듈이 바로 접근 가능해야 하는 ES6의 모듈은 이런것을 허용하지 않았다.</p><p>결국 아래와 같은 controllerMap 을 만들었다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file controllerFactory.js</span></span><br><span class="line"><span class="keyword">import</span> EmptyController <span class="keyword">from</span> <span class="string">'./EmptyController'</span></span><br><span class="line"><span class="keyword">import</span> MainController <span class="keyword">from</span> <span class="string">'./OrderController'</span></span><br><span class="line"><span class="keyword">import</span> OrderController <span class="keyword">from</span> <span class="string">'./order/OrderController'</span></span><br><span class="line"><span class="keyword">import</span> MemberController <span class="keyword">from</span> <span class="string">'./member/MemberController'</span></span><br><span class="line"><span class="keyword">import</span> MemberBlockController <span class="keyword">from</span> <span class="string">'./member/MemberBlockController'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... Controller import Statement 다수</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> controllerMap = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="string">'MainController'</span>: MainController,</span><br><span class="line">    <span class="string">'order/OrderController'</span>: OrderController,</span><br><span class="line">    <span class="string">'member/MemberController'</span>: MemberController,</span><br><span class="line">    <span class="string">'member/MemberBlockController'</span>: MemberBlockController,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이름으로 매핑해둔 컨트롤러를 반환한다.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">conrollerPath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> controllerMap[conrollerPath] || <span class="keyword">new</span> EmptyController();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이런식으로 미리 Controller 모듈을 로딩해두고 맵으로 관리되게 한 다음, 반환하는 Factory 모듈을 만들어서 처리했다.</p><p>동적 로딩을 완전히 포기하고 초기에 모든 스크립트를 로딩하게 한 선택이다.</p><p>물론 초기 스크립트 로딩 용량이 굉장히 커지고 컨텐트와 컨트롤러가 추가될수록 증가하지만, 별 방법이 없다고 생각했다.</p><p><a href="https://webpack.github.io/docs/code-splitting.html" rel="external nofollow noopener noreferrer" target="_blank">require.ensure</a> 를 사용하여 동적 로딩을 선택할 수도 있었지만 동적 로딩도 동적 문자열로 모듈을 로딩하는건 불가능하기에, 각 컨트롤러의 매핑마다 동적 로딩 코드를 적어주어야 했다.</p><p>다음과 같이 말이다. 별로 마음에 들지 않았다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @file asyncControllerFactory.js</span></span><br><span class="line"><span class="keyword">import</span> EmptyController <span class="keyword">from</span> <span class="string">'./EmptyController'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> controllerMap = &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="string">'MainController'</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">require</span>.ensure([], () =&gt; resolve(<span class="built_in">require</span>(<span class="string">'./MainController'</span>)))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="string">'order/OrderController'</span>]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">require</span>.ensure([], () =&gt; resolve(<span class="built_in">require</span>(<span class="string">'./order/OrderController'</span>)))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">conrollerPath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> factory = controllerMap[conrollerPath];</span><br><span class="line">    <span class="keyword">return</span> factory ? </span><br><span class="line">        factory().then(<span class="function"><span class="params">Controller</span> =&gt;</span> <span class="keyword">new</span> Controller().execute())</span><br><span class="line">        :</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> EmptyController().execute());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>저 <code>ensure</code> 구문은 반드시 저렇게 패스와 같이 적어줘야지 별도로 분리하게 되면 webpack 번들링 후 실제 로딩이 잘 동작하지 않았다.</p><p>컨트롤러 수가 작업 당시에는 그렇게 많지 않았고 동적 로딩 시 종종 Timeout 등의 네트워크 오류도 났기에 그냥 전체를 한번에 번들링해버리는 선택을 했다.<br>(그리고 나중에 엄청 후회했다…)</p><h4 id="Webpack2-에서의-Async-Module-Loading"><a href="#Webpack2-에서의-Async-Module-Loading" class="headerlink" title="Webpack2 에서의 Async Module Loading"></a>Webpack2 에서의 Async Module Loading</h4><p>Webpack 2 에서는 <code>import</code> 와 <code>async/await</code> 를 사용해서 동적 로딩을 할 수 있다.<br>이런식의 코딩이 가능. 표준을 준수한다는 것 외엔 특별한 외형 차이는 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES7 의 async 와 await 를 사용한다</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadOrderCancelController</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Controller = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./OrderCancelController'</span>);</span><br><span class="line">    <span class="keyword">return</span> Controller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadOrderCancelController()</span><br><span class="line">    .then(<span class="function"><span class="params">Controller</span> =&gt;</span> <span class="keyword">new</span> Controller().execute());</span><br></pre></td></tr></table></figure><p></p><p>이제 각 컨트롤러를 매핑해주고 컨텐츠 로더가 그것을 잘 사용할 수 있게 수정하는 노가다만 남은듯 했다.</p><p>하지만 현실은 …</p><h3 id="ES6-모듈과-commonjs-amd-모듈은-달랐다"><a href="#ES6-모듈과-commonjs-amd-모듈은-달랐다" class="headerlink" title="ES6 모듈과 commonjs, amd 모듈은 달랐다."></a>ES6 모듈과 commonjs, amd 모듈은 달랐다.</h3><p>Webpack 은 분명 AMD 와 commonjs 모듈도 사용할 수 있다. 실제로도 그렇다.<br>하지만, 이 두 스펙의 모듈 정의를 ES6 모듈과 함께 사용할때는 큰 문제가 발생했다.</p><p>ES6 모듈 정의에는 <code>default export, named export</code> 라는 AMD, commonjs 에 없는 개념이 있었기 때문이다.</p><p><img src="/asset/howthefuck.jpg" alt="뭐냐..."></p><p>다음에 세가지 스타일로 모듈을 정의해보았다.<br>이 모듈의 이름은 <code>rouka/blog/module</code> 이라고 해보자</p><p>먼저, AMD 모듈은 다음과 같은 형식이다.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">define([ <span class="string">'jquery'</span>, <span class="string">'moment'</span> ], <span class="function"><span class="keyword">function</span> <span class="title">factory</span>(<span class="params">$, moment</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> YMD_FORMAT_STR = <span class="string">'YYYYMMDD'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getEl(selector, context) &#123;</span><br><span class="line">            <span class="keyword">return</span> $(selector, context || <span class="built_in">document</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        todayString() &#123;</span><br><span class="line">           <span class="keyword">return</span> moment().format(YMD_FORMAT_STR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>commonjs 의 모듈은 다음과 같은 형식이다<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>); </span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">'moment'</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> YMD_FORMAT_STR = <span class="string">'YYYYMMDD'</span>;</span><br><span class="line"></span><br><span class="line">exports.getEl = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $(selector, context || <span class="built_in">document</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.todayString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moment().format(YMD_FORMAT_STR);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>ES6 모듈은 다음과 같은 형식이다.<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>; </span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> YMD_FORMAT_STR = <span class="string">'YYYYMMDD'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getEl</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $(selector, context || <span class="built_in">document</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">todayString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moment().format(YMD_FORMAT_STR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>여기까지는 세개 다 비슷해 보인다. 모듈을 로딩할때 쓰는 statement 나 문법만 다른 정도.<br>하지만 위의 정의 모듈을 사용할때 달라진다.</p><p>먼저 AMD 와 commonjs 는 기본적으로 형태만 다를 뿐 기본적인 사용은 같다.</p><p>모듈을 로딩하고, 해당 모듈을 객체를 얻으면 그 모듈을 사용할 수 있다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'rouka/blog/module'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">blogModule</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(blogModule.todayString()); <span class="comment">// 오늘 날자...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// commonjs</span></span><br><span class="line"><span class="keyword">const</span> blogModule = <span class="built_in">require</span>(<span class="string">'rouka/blog/module'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(blogModule.todayString()); <span class="comment">// 오늘 날자...</span></span><br></pre></td></tr></table></figure><p>하지만 이 모듈을 ES6 에서 사용하려면 좀 다르다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="comment">// 이 부분이 다르다!</span></span><br><span class="line"><span class="keyword">import</span> &#123; todayString &#125; <span class="keyword">from</span> <span class="string">'rouka/blog/module'</span></span><br><span class="line"><span class="built_in">console</span>.log(todayString()); <span class="comment">// 오늘 날자...</span></span><br></pre></td></tr></table></figure><p>import 시에 실제 사용할 기능 프로퍼티 이름을 적어주고 있다.<br>만일 그냥</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">import</span> blogModule <span class="keyword">from</span> <span class="string">'rouka/blog/module'</span></span><br><span class="line"><span class="built_in">console</span>.log(blogModule.todayString()); <span class="comment">// throw TypeError</span></span><br></pre></td></tr></table></figure><p>이런식으로 사용할 경우 오류를 낸다.</p><p>위의 문법은 <code>rouka/blog/module</code> 에서 default 모듈을 사용하겠다는 뜻이다.<br>ES6 모듈에는 <code>default export</code> 라는게 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>; </span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getEl</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $(selector, context || <span class="built_in">document</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">todayString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> moment().format(YMD_FORMAT_STR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default export</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">setTodayOnEl</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">    getEl(selector, context).html(todayString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>default export 로 해당 엘리먼트에 오늘 날자를 HTML 로 넣어주는 함수를 정의했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default 모듈 사용</span></span><br><span class="li