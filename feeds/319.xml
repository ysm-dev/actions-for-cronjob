<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://moonjong93.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://moonjong93.github.io/" rel="alternate" type="text/html" /><updated>2018-11-01T07:26:10+00:00</updated><id>https://moonjong93.github.io/</id><title type="html">MoongJong93</title><subtitle>웹 개발에 관한 이야기, Node.js와 Vue.js를 사용하는 개발자</subtitle><entry><title type="html">타입스크립트 코리아 강좌 정리</title><link href="https://moonjong93.github.io/study/hello-typescript" rel="alternate" type="text/html" title="타입스크립트 코리아 강좌 정리" /><published>2018-10-30T00:00:00+00:00</published><updated>2018-10-30T00:00:00+00:00</updated><id>https://moonjong93.github.io/study/hello-typescript</id><content type="html" xml:base="https://moonjong93.github.io/study/hello-typescript">&lt;h1 id=&quot;1-typescirpt-에-관하여&quot;&gt;1. Typescirpt 에 관하여&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;tpyscript 는 자바스크립트를 포함한 프로그래밍 언어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;타입스크립트는 ‘Compiled Language’이다&lt;/li&gt;
  &lt;li&gt;자바스크립트는 ‘Interpreted Language’이다&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;그러나 엄밀히 따지자면 컴파일 언어라고 보기는 힘들고 메타 프로그래밍이라고도 하며, 트랜스파일(바밸 등) 언어라고도 보기도한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Compiled&lt;/th&gt;
      &lt;th&gt;Interpreted&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;컴파일이 필요&lt;/td&gt;
      &lt;td&gt;컴파일이 필요없음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;컴파일러가 필요&lt;/td&gt;
      &lt;td&gt;컴파일러가 필요없음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;컴파일하는 시점이 있음&lt;/td&gt;
      &lt;td&gt;컴파일하는 시점이 없음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;컴파일된 결과물 실행&lt;/td&gt;
      &lt;td&gt;코드 자체를 실행&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;컴파일 언어는 최적화 과정을 거침 * 특히 타입스크립트는 타입을 체크하는 과정을 거침&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;정적타입-언어-vs-동적-타입-언어&quot;&gt;정적타입 언어 VS 동적 타입 언어&lt;/h2&gt;

&lt;h3 id=&quot;정적타입-언어&quot;&gt;정적타입 언어&lt;/h3&gt;

&lt;p&gt;미리 타입을 정의 해놓고 사용함&lt;/p&gt;

&lt;h3 id=&quot;동적-타입언어&quot;&gt;동적 타입언어&lt;/h3&gt;

&lt;p&gt;타입이 정의되어 있지 않고 자유럽게 변화가 가능&lt;/p&gt;

&lt;p&gt;타입스크립트는 정적타입 언어의 장점을 자바스크립트에 결합한 언어이다.&lt;/p&gt;

&lt;h2 id=&quot;traditional-compiled-language&quot;&gt;Traditional Compiled Language&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;컴파일 언어라고 한다&lt;/li&gt;
  &lt;li&gt;C, C++, go 등&lt;/li&gt;
  &lt;li&gt;일반적으로 실행시 기계어로 바꾸는 방식(인터프리터 언어)보다 빠르다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TS =&amp;gt; JS&lt;/p&gt;

&lt;p&gt;이 강좌에서 배우는 것은 컴파일은 어떤 역할을 하는지 어떤 도구들이 있고 올바르게 사용하는 방법과, 타입스크립트 자체를 이해&lt;/p&gt;

&lt;h1 id=&quot;2-개발-환경-구축&quot;&gt;2. 개발 환경 구축&lt;/h1&gt;

&lt;h2 id=&quot;nodejs-설치&quot;&gt;Node.js 설치&lt;/h2&gt;

&lt;p&gt;강좌 외적으로 저는 Node.js 의 버전을 자유롭게 바꾸다보니 NVM 사용을 권장합니다. 예) Lambda 에서 지원하는 버전과 React 에서 지원하는 버전이 전혀 다르면서 생기는 문제 등등&lt;/p&gt;

&lt;p&gt;curl 을 이용해 설치&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -o https://raw.githubusercontent.com/creationix/nvm/v0.26.1/install.sh | bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;browser-설치&quot;&gt;Browser 설치&lt;/h2&gt;

&lt;p&gt;Chrome, firefox 와 같이 검사가 있는 브라우저를 추천 함&lt;/p&gt;

&lt;h2 id=&quot;tpyscript-compiler-설치&quot;&gt;Tpyscript compiler 설치&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;npm i typescript -g // 전역으로 설치됩니다
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ide-설치&quot;&gt;IDE 설치&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://visualstudio.microsoft.com/ko/?rr=https%3A%2F%2Fwww.google.co.kr%2F&quot;&gt;vscode(무료)&lt;/a&gt;, intelliJ(유료)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;visual studio code 는 Typscript 로 만들어졌다.&lt;/li&gt;
  &lt;li&gt;타입스크립트 지원이 강력하다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tsc-init&quot;&gt;tsc init&lt;/h2&gt;

&lt;p&gt;tsc 설정 파일을 init 함
target, module, strict 정도가 기본 설정으로 되어있음.&lt;/p&gt;

&lt;h2 id=&quot;ts-lint&quot;&gt;ts lint&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;npm i tslint -D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tslint –init&lt;/p&gt;

&lt;h1 id=&quot;3-compiler-options&quot;&gt;3. Compiler Options&lt;/h1&gt;
&lt;h2 id=&quot;tsconfig&quot;&gt;tsconfig&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://json.schemastore.org/tsconfig&quot;&gt;ts config 가이드&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;최상위-프로퍼티&quot;&gt;최상위 프로퍼티&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;CompileOnSave: 파일 저장시 자동 컴파일, Visual studio에서 사용 가능&lt;/li&gt;
  &lt;li&gt;extends: v2.1 new spec&lt;/li&gt;
  &lt;li&gt;compileOptions
    &lt;ul&gt;
      &lt;li&gt;다양한 옵션이 제공됨&lt;/li&gt;
      &lt;li&gt;typeRoots: 배열 안에 들어있는 경로들 아래에 모듈만 가져옴&lt;/li&gt;
      &lt;li&gt;types: 배열 안에 모듈, ./node_modules/@types/ 안의 모듈 이름에서 찾아옴&lt;/li&gt;
      &lt;li&gt;typeRoots, types와 함께 사용하지 않음&lt;/li&gt;
      &lt;li&gt;target: 컴파일 해서 어떤 자바스크립트 버전으로 downgrade 시킬거냐 기본은 es3이다&lt;/li&gt;
      &lt;li&gt;lib: 기본 type definition 라이브러리를 어떤 것을 사용할 것이냐
        &lt;ul&gt;
          &lt;li&gt;lib를 지정하지 않을때&lt;/li&gt;
          &lt;li&gt;target이 ‘es3’이고 디폴트로 lib.d.ts를 사용함&lt;/li&gt;
          &lt;li&gt;target이 ‘es5’이면, 디폴트로 dom, es5, scripthost를 사용함&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;outDir: 소스 구조의 전부를 컴파일 하려면 사용&lt;/li&gt;
      &lt;li&gt;outFile: 구조 상관없이 컴파일 하려면 사용&lt;/li&gt;
      &lt;li&gt;module: 결과물이 어떤 js파일을 쓸건지 target이 es6면 es6가 기본값, es6가 아니면 ‘commonjs’가 기본값&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;files:
    &lt;ul&gt;
      &lt;li&gt;상대 혹은 절대 경로의 리스트 배열&lt;/li&gt;
      &lt;li&gt;exclude 보다 우선순위 높음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;include
    &lt;ul&gt;
      &lt;li&gt;exclude 보다 우선순위 낮음&lt;/li&gt;
      &lt;li&gt;*같은걸 사용하면 .ts / .tsx 등 설정한 것만 include 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;exclude
    &lt;ul&gt;
      &lt;li&gt;설정 안하면 기본 4가지를 설정 (node_modules, browser_components, jspm_packages, outDIr)를 기본적으로 제외&lt;/li&gt;
      &lt;li&gt;outDir은 항상 제외&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;4-typescript-basic-type&quot;&gt;4. typescript basic type&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Typescript에서 프로그램 작성을 위해 기본 제공하는 데이터 타입&lt;/li&gt;
  &lt;li&gt;Javscript 기보 자료형을 포함
    &lt;ul&gt;
      &lt;li&gt;ECMAScript 표준에 따른 기본 자료형은 6가지&lt;/li&gt;
      &lt;li&gt;Boolean&lt;/li&gt;
      &lt;li&gt;String&lt;/li&gt;
      &lt;li&gt;Null&lt;/li&gt;
      &lt;li&gt;Undefined&lt;/li&gt;
      &lt;li&gt;Symbol&lt;/li&gt;
      &lt;li&gt;Array: Object형&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그래밍을 도울 몇가리 타입이 더 제공됨
    &lt;ul&gt;
      &lt;li&gt;Any&lt;/li&gt;
      &lt;li&gt;Void&lt;/li&gt;
      &lt;li&gt;Never&lt;/li&gt;
      &lt;li&gt;Enum&lt;/li&gt;
      &lt;li&gt;Tuple: Object&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;literal&quot;&gt;literal?&lt;/h2&gt;
&lt;p&gt;값자체가 변하지 않는 값을 의미함
상수와 다른 것은 상수는 가리키는 포인터가 고정이라는 것이고, 리터럴은 그 자체가 값이자 리터럴&lt;/p&gt;

&lt;h2 id=&quot;권장-소문자를-사용해라&quot;&gt;권장 소문자를 사용해라&lt;/h2&gt;
&lt;p&gt;new Number(5) -&amp;gt; number(5);&lt;/p&gt;

&lt;p&gt;new Boolean(false) -&amp;gt; boolrean(false);&lt;/p&gt;

&lt;h2 id=&quot;any&quot;&gt;Any&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 타입이든 상관없음&lt;/li&gt;
  &lt;li&gt;그러나 권장하지 않음 (이걸 쓸꺼면 그냥 es6바밸 문법을 사용해라)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tuple&quot;&gt;Tuple&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;배열인데 한가지 타입이 아닐 경우&lt;/li&gt;
  &lt;li&gt;객체&lt;/li&gt;
  &lt;li&gt;사용할때 주의가 필요함&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;5-var-let-const&quot;&gt;5. var, let, const&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;var
    &lt;ul&gt;
      &lt;li&gt;es5&lt;/li&gt;
      &lt;li&gt;함수 스코프&lt;/li&gt;
      &lt;li&gt;호이스팅이 가능&lt;/li&gt;
      &lt;li&gt;재선언 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;let, const
    &lt;ul&gt;
      &lt;li&gt;es6&lt;/li&gt;
      &lt;li&gt;블록 스코프&lt;/li&gt;
      &lt;li&gt;호이스팅 불가능&lt;/li&gt;
      &lt;li&gt;재선언 불가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;var 말고 let, const를 사용하자&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;let-const-차이점&quot;&gt;let, const 차이점&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let a: string = &quot;에이&quot;;
let a = &quot;에이&quot;; //자동으로 String으로 타입을 맞춰줌

const b: string = &quot;비&quot;;
const b = &quot;비&quot;; //별도의 타입을 만들어 주지 않음
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;6-type-assersions&quot;&gt;6. Type assersions&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;형변환과는 다름
    &lt;ul&gt;
      &lt;li&gt;형변형은 실제 데이터 구조를 바꿔줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;‘타입이 이것이다’라고 컴파일러에게 알려주는 것을 의미함
    &lt;ul&gt;
      &lt;li&gt;그래서 작성자가 100% 신뢰하는 것이 중요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;문법적으로는 두가지 방법이 있다
    &lt;ul&gt;
      &lt;li&gt;변수 as 강제할 타입&lt;/li&gt;
      &lt;li&gt;
        &lt;강제할 타입=&quot;&quot;&gt;변수
```javascript
let a: any = &quot;this is a string&quot;;
let b: number = (someValue as a).length;
```

&lt;/강제할&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;타입-별칭&quot;&gt;타입 별칭&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;인터페이스와 유사해 보임&lt;/li&gt;
  &lt;li&gt;Primitive, Union Type, Tuple&lt;/li&gt;
  &lt;li&gt;기타 직접 작성해야하는 타입을 다른 이름에 저장할 수 있다.&lt;/li&gt;
  &lt;li&gt;만들어진 타입의 refer로 사용하는 것이지 타입을 만드는것은 아니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;union&quot;&gt;Union&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let a: any;
let b: string | number;

b = &quot;스트링&quot;;
b = 0;

//만약 사례가 복잡하다면?

function test(arg: string | number): string | number {
    return arg;
}
//위와 같이 작성할때마다 해주는게 힘들다보니 사용함
type StringOrNumber = string | number; //이게 union타입

function test(arg: StringOrNumber): StringOrNumber {
    return arg
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;interface&quot;&gt;interface&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
//interface가 없다면
const person: {name: string; age: number} = {
    name: 'MrMoon',
    age: 12
};

//interface를 사용한다면
interface Person{
    name: string;
    age: number
}
const person: Person = {
    name: 'mrMoon',
    age: 12
}

// 주요 사용처
function hello(p: Person): void {
    console.log(`안녕하세요 ${p.name} 입니다`)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;interface-optional&quot;&gt;interface optional&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;interface Person {
    name: string;
    age?: number; //age를 강제하지 않음
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;indexable-type&quot;&gt;indexable type&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;interface Person {
    name: string;
    [index: string]: string;
}
const person : Person = {
    name: &quot;mark&quot;;
}
person.anybody = &quot;Anna&quot;;

//여기서 접근하는 index를 어레이로 선언했기 때문에 가능 함
interface Person2 {
    [index: number]: string;
}

const p2: Person2 = {};
p2[0] = &quot;hi&quot;;
p2[100] = &quot;hello&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 array에 string이나 number로 interface를 만들어줄 순 있지만 array는 아님&lt;/p&gt;

&lt;h2 id=&quot;interface-in-funciton&quot;&gt;interface in funciton&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;interface Person {
    name: string;
    hello(): string;
}

const person: Person = {
    name: 'mark',
    hello(): string{
        return 'hello world';
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;class-implements-interface&quot;&gt;class implements interface&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;interface IPerson {
    name: string;
    hello(): void;
}

class Person implements IPerson {
    name: string = null;

    constructor(name: string) {
        this.name = name;
    }
    hi(): void {
        console.log('This is hi');
    }
    hello(): void {
        console.log(`hello i am ${name}`);
    }
    
}

const person: IPerson = new Person(&quot;moon&quot;);
const person: Person = new Person(&quot;moon&quot;);
//두가지 모두 사용 가능하다
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;IPerson의 타입을 가지고 있는 person은 interface에서 정의하지 않은 hi 함수에 접근할 수 없다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;string-or-number&quot;&gt;string OR number&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;interface StringArray {
    [index: number]: string;
}

const sa: StringArray = {};
sa[100] = '백';
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;7-클래스&quot;&gt;7. 클래스&lt;/h1&gt;

&lt;h2 id=&quot;class&quot;&gt;class&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Person {
    name: string;
    age: number;
    // 모든 프로퍼티는 public
    constructor(name: string) {
        this.name = name
    }

    // 할당하지 않는 변수는 undefined가 되어서 나오지 않음
    // 그래서 = null이라고 해주는게 일단 좋음 (기본적인 프로그래밍 방식)
}

const person = new Person('Mark');
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
  &lt;li&gt;생성사 함수가 없으면 디폴트 생성자가 불린다.&lt;/li&gt;
  &lt;li&gt;클래스의 프로퍼티 혹은 멤버 변수가 정의되어 있지만, 값을 대입하지 않으면 undefined이다.&lt;/li&gt;
  &lt;li&gt;접근 제어자는 public이 디폴트 이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;접근-제어자---private&quot;&gt;접근 제어자 - private&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Person {
    private _name: string = 'Mark';
    private _age: number;
}

const person = new Person('Mark');
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;디폴트 값은 public 이고 private 로 선언한 프로퍼티 접근 불가능 (c#과 흡사)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;protected&quot;&gt;protected&lt;/h2&gt;
&lt;p&gt;private는 부모 클래스건 어디서건 절대로 접근이 안되는 반면에 protected는 부모에서는 접근이 가능함&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Person {
    protected _name: string = 'amark';
    private _age: number = null;
}

class Child extends Person {

    constructor() {
        super(); // constructor에서 무언가 작업을 하기 위해서는 super를 해줘야함 (상속 받았을 때)

        this._name += '아들';

    }
    getName() {
        return this._name
    }
    getAge() {
        return this._age //접근이 안됨
    }
}

const person: Child = new Child();

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;클래스와-메서드&quot;&gt;클래스와 메서드&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Person {
    // protected _name: string = 'amark';
    // private _age: number = null;

    // 굳이 변수 선언없이 이렇게 해도 가능
    constructor(protected name: string, protected age: number){

    }

    hello(): void {
        console.log(this.name);
    }

    //arrow function도 가능
    printHello = (): void =&amp;gt; {
        console.log('hello world');
    }
}

const person: Person = new Person('Moon', 35);

class Child extends Person {

    constructor() {
        super('Mark Jr', 5);
    }
}

const child: Child = new Child('Mark', 35);
child.hello();
// console : Mark Jr
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;클래스를 상속받아서 사용하려면 꼭 constructor 에서 super()를 해줘야함&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;클래스의-getter-setter&quot;&gt;클래스의 getter, setter&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;
interface IPerson {
    getName();
}

//인터페이스에서 이렇게 사용할 수도 있음

class Person implements IPerson{
    private _name: string;
    private _age: number;

    constructor(name: string, age: number) {
        this._name = name;
        this._age = age;
    }

    get name() {
        return this._name;
    }
    
    set name(name: string) {
        this._name = name;
    }

    // get set을 안쓰고 이방법도 사용 가능

    getName(): string {
        return this._name;
    }
}

const person: IPseron = new Person('moon', 26);
console.log(person.name); // moon
person.name = 'moon jong min';
console.log(person.name); // moon jong min

const person: IPerson = new Person('Mark', 35);
person.getName();

// interface를 활용 하면 이런식으로도 사용 가능함
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;class의-static-프로퍼티-메서드&quot;&gt;class의 static 프로퍼티, 메서드&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Person {
    public static HEIGHT: number;

    public static Talk(): void {
        console.log('안녕하세요');
    }
}

const person: Person = new Person();
person.HEIGHT // 접근안됨

Person.HEIGHT // 접근됨 (클래스 자체에 프로퍼티가 동적으로 생성됨)
Person.Talk(); // 동일함
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;동적으로 생성된다는 얘기에 좀 집중을 해봐야 할것 같은데 변화도 가능하다는 점이다.&lt;/li&gt;
  &lt;li&gt;리엑트할 때도 사용되는 default props 같은 경우에 사용됨&lt;/li&gt;
  &lt;li&gt;역시 static을 너무 사용하면 좋지 않음&lt;/li&gt;
  &lt;li&gt;public static은 의미가 있음&lt;/li&gt;
  &lt;li&gt;private static의 의미는 고민이 필요함&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;anstract-class---미완된-클래스&quot;&gt;Anstract Class - 미완된 클래스&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;abstract class APerson {
    protected _name: string = 'Mark';
    abstract setName(name: string): void;
    // 이렇게 미완성으로 만들어 놓고 상속받거나 할때 사용 가능함
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;class와-private-constructor&quot;&gt;class와 private constructor&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// 싱글톤 예제
class Perference {
    private static Instance: Perference = null;
    public static getInstance(): Perference {
        if(Perference.Instance === null){
            Preference.Instance = new Preference();
        }

        return Preference.Instance;
    }
    private constructor() {
        
    }

    hello() {

    }
}

const p = Perference.getInstance();
p.hello();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;class와-readonly&quot;&gt;class와 readonly&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Person {
    private readonly _name: string = null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;readonly는 get, set중에 get만 있는것과 흡사하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;8-generic&quot;&gt;8. generic&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;any -&amp;gt; generic&lt;/li&gt;
  &lt;li&gt;제네릭을 쓰는 가장 큰 이유는 템플릿 라이브러리 (cpp)처럼 타입을 변수로 주고 싶을때 사용함&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hello&amp;lt;T&amp;gt;(message: T): T {
    return message;
}

hello&amp;lt;string&amp;gt;('hello moon');
hello&amp;lt;string&amp;gt;('hello moon').length;//문자열의 내장 함수도 사용가능
hello&amp;lt;number&amp;gt;(35);

const a: string[] = [];
const b: Array&amp;lt;string&amp;gt; = [];
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;메시지가 number, string에 상관없이 가능함&lt;/li&gt;
  &lt;li&gt;장점은 any로 사용하면 헬퍼같은게 제대로 작동이 되지 않는데 제네릭은 정상 작동함&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;generic-인자&quot;&gt;generic 인자&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hello&amp;lt;T&amp;gt;(message: T[]): T{
    return message[0]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;T의 array 형태로도 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;generic-class&quot;&gt;generic class&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Person&amp;lt;T&amp;gt; {
    private _name: T;
    
    constructor(name: T) {
        this._name = name;
    }
}

const mark = new Person('Mark');
new Person&amp;lt;number&amp;gt;('Mark'); //error!
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;name의 타입이 설정하는 대로 되어줌&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;generic-with-extends&quot;&gt;generic with extends&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Person&amp;lt;T extends string | number&amp;gt; {
    private _name: T;

    constructor(name: T) {
        this._name = name;
    }
}

const mark = new Person('mark');
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;generic-with-multiple-type&quot;&gt;generic with multiple type&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;class Person&amp;lt;T, K&amp;gt; {
    private _name: T;
    private _age: K;

    constructor(name: T, age: K) {
        this._name = name;
        this._age = age;
    }
}

const mark = new Person('mark', 35);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;type-lookup-system&quot;&gt;type lookup system&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;2.1 버전에 나옴
```javascript
interface Person {
  name: string;
  age: number;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// type Test = keyof Person;&lt;/p&gt;

&lt;p&gt;// function getProperty(obj, key) {
//     return obj[key]; //가끔이 key가 없을땐 undefined 에러를 뿜는데 (나도 겪음) 이걸 해결하는데 lookup system
// }&lt;/p&gt;

&lt;p&gt;function getProperty&amp;lt;T, K extends keyof T&amp;gt;(obj: T, key: K): T[K]{
    return obj[key];
}&lt;/p&gt;

&lt;p&gt;function setProperty&amp;lt;T, K extends keyof T&amp;gt;(obj: T, key: K, value: T[K]): T[K]{
    obj[key] = value
}&lt;/p&gt;

&lt;p&gt;const person: Person = {
    name: ‘Mark’,
    age: 35
}&lt;/p&gt;

&lt;p&gt;getProperty(person, ‘name’);
setProperty(person, ‘name’, ‘anda’);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
- 상당히 자주 쓰일것 같음 
- // type Test = keyof Person; 이 부분이 좀 중요한것 같은데 keyof Person을 해줬기 때문에 Test는 리터럴로 name, age 프로퍼티를 갖게 되는것


# 9. iterator

## for...of
- es3
  - for (var i=...)
- es5
  - array.forEach
    - break 를 할 수 없었따.
- es6
  - for of
    - 원칙적으로는 배열에서만 사용 가능

## for...in
- 배열을 순회할 때는 사용하지 말것
  - index가 number가 아니라 string으로 나온다.
  - 배열의 프로퍼티를 순회할 수도 있따.
  - prototype 체인의 프로퍼티를 순회할 수도 있다.
  - 루프가 무작위로 수회할 수도 있다.
  - for of를 쓸 것
- 객체를 순회할 때
  - for(const prop of Object.keys(obj))도 사용할 수 있음

## target es3 forEach
- 트렌스파일시에 es3인데도 lib에서 잘못 판단되어서 적용이 안되고 es5 기준으로 생성됨

## Sysmbol.iterator
- 프로퍼티이며, 함수가 구현되어있으면, iterable 이라고 한다.
- Array, Map, Set, String, Int32Array, Unit32Array, etc, 에는 내장된 구현체가 있으므로 이터러블 하다.
- 그냥 객체는 이터러블하지 않다.
- 이터레이터를 통해 이터러블한 객체의 Symbol.iterator함수를 호출한다.
- traget: es3 or es5
  - Array 에만 for..of사용 가능
  - 일반 객체에 사용하면 오류
- target: es6
  - Symbol.iterator를 구현하면 사용 가능

## custom iterable
```javascript
class CustomIterable implements Iterable&amp;lt;string&amp;gt; {
    private _array: Array&amp;lt;string&amp;gt; = ['first', 'second'];

    [Symbol.iterator]() {
        var nextIndex = 0;

        return {
            next: () =&amp;gt; {
                return {
                    value: this._array[nextIndex++],
                    done: nextIndex &amp;gt; this._array.length
                }
            }
        }
    }
}

const cIterable = new CustomIterable();

for (const item of cIterable) {
    console.log(item);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;배열의 이터레이터를 돌면 예 for of 객체의 for을 돌리면 커스텀한 for of 로 돌리면 class 내부에 있는 배열도 사용 가능하기에 사용함.&lt;/li&gt;
  &lt;li&gt;사실 무슨 말 인지..&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;10-decorator&quot;&gt;10. Decorator&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;Class&lt;/li&gt;
  &lt;li&gt;Method&lt;/li&gt;
  &lt;li&gt;Property&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Parameter&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 decorator 는 function이다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;class-decorator&quot;&gt;class decorator&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hello(constructorFn: Function) {
    console.log(constructorFn);
}

function helloFactory(show: boolean) {
    if (show)
      return hello;
    else
      return null;
}

@helloFactory(false)
class Person {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;class-decorator-expert&quot;&gt;class decorator expert&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hello(constructorFn: Function) {
    constructorFn.prototype.hello = function() :void {
        console.log('hello');
    }
}

@hello
class Person {

}

const p = new Person();
(&amp;lt;any&amp;gt;p).hello(); // 이런식으로 밖에 사용해야함

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;method-decorator&quot;&gt;method decorator&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function editable(canBeEditable: boolean) {
    return function(target: any, propName: string, description: PropertyDescriptor) {
        console.log(target);
        console.log(propName);
        console.log(description);

        description.writable = canBeEditable;
    }
}

class Person {

    constructor() {
        console.log('new Person ()');
    }

    @editable(false)
    hello(): void {
        console.log('hello');
    }

}

const p = new Person();
p.hello();

p.hello = function() {
    console.log('world');
}
p.hello();

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;property-decorator&quot;&gt;property decorator&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function writetable(canBeWriteable: boolean) {
    return function(target: any, propName: string): any {
        console.log(target);
        console.log(propName);

        return {
            writetable: canBeWriteable
        }
    }
}


class Person {

    @writetable(true)
    name: string = 'Mark';

    constructor() {
        console.log('new Person ()');
    }

    hello(): void {
        console.log('hello');
    }

}

const p = new Person();
console.log(p.name);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;parameter-decorator&quot;&gt;parameter decorator&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function printInfo(target: any, methodName: string, paramIndex: number) {
    console.log(target);
    console.log(methodName);
    console.log(paramIndex);

}

class Person {
    private _name: string;
    private _age: number;

    constructor(name: string, @printInfo age: number) {
        this._name = name;
        this._age = age;
    }

    hello(@printInfo message: string): void {
        console.log(message)
    }

}


// const p = new Person('Mark', 35);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;개인적으로 decorator는 예를들면 프레임워크를 만들때나 어떠한 모듈을 만들때 변수 검증 등을 하는데 사용하면 요긴하게 쓰일것 같다는 생각이 들었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;11-type-inference&quot;&gt;11. Type Inference&lt;/h1&gt;
&lt;h2 id=&quot;타입-추론&quot;&gt;타입 추론&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기본적으로 타입을 명시적으로 스지 않을 때 추론하는 방법에 대한 규칙
    &lt;ul&gt;
      &lt;li&gt;명시적으로 쓰는 것은 타입 추론이 아니라 코드를 읽기 좋게 하는 지름길&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;let은 기본적으로 우리가아는 기본 자료형으로 추론&lt;/li&gt;
  &lt;li&gt;const는 리터럴 타입으로 추론
    &lt;ul&gt;
      &lt;li&gt;오브젝트 타입을 쓰지 않으면, 프로퍼티는 let 처럼 추론
        &lt;ul&gt;
          &lt;li&gt;const person = {name: ‘Mark’, age: 35}&lt;/li&gt;
          &lt;li&gt;person =&amp;gt; {name:string; age: number}&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대부분 추론은 쉽다.
    &lt;ul&gt;
      &lt;li&gt;단순 변수&lt;/li&gt;
      &lt;li&gt;structing, destruction&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;array, 함수의 리턴에서는 워하는데로 얻기가 힘들다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;배열-타입-추론&quot;&gt;배열 타입 추론&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const aaray1 = []; // any type으로 추론함
const array2 = ['a', 'b'] // array string
const array3 = ['a', 1, 'cone'] // union type으로 추론함

class Animal {
    name: string;
}

class Dog extends Aniaml {
    dog: string;
}

class Cat extends Animal {
    cat: string;
}

const array4 = [new Dog(), new Cat()]; // union dog | cat
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;리턴-타입-추론&quot;&gt;리턴 타입 추론&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function hello(message: string | number) { 
    // 리터럴 타입의 world이거나 0을 추론
    if(message === 'world')
      return 'world'
    else
      return 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;유니온-타입과-가드&quot;&gt;유니온 타입과 가드&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;interface Person {
    name: string;
    age: number;
}

interface Car {
    brand: string;
    wheel: number;
}

function isPerson(arg: any): arg is Person {
    return arg.name !== undefined;
} // 이 부분이 타입가드

function hello(obj: Person | Car) {
    if (isPerson(obj)) {
        obj.age;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;약 11개의 챕터이자 강좌는 14개인 타입스크립트 코리아에서 만든 이 강좌는 &lt;a href=&quot;https://www.youtube.com/watch?v=PFBRhxjIBUM&amp;amp;list=PLV6pYUAZ-ZoHx0OjUduzaFSZ4_cUqXLm0&quot;&gt;유튜브&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;

&lt;p&gt;타입스크립트를 막연하게 어렵다고만 생각했었는데 오히려 프로그램을 작성하는데 있어서 더욱더 안정성이 있다는것은 이 강좌를 통해서 확실히 알게되었다.&lt;/p&gt;

&lt;p&gt;실제로 직접 가서 참여한 세미나보다도 상당히 훌륭했고 예제들 역시 상당히 훌륭했다.&lt;/p&gt;</content><author><name></name></author><category term="Typescript" /><category term="beginer" /><summary type="html">1. Typescirpt 에 관하여</summary></entry><entry><title type="html">남궁성 자바스크립트 기초 세미나 정리</title><link href="https://moonjong93.github.io/study/namgungsung_beginer_javascript_semina" rel="alternate" type="text/html" title="남궁성 자바스크립트 기초 세미나 정리" /><published>2018-10-27T00:00:00+00:00</published><updated>2018-10-27T00:00:00+00:00</updated><id>https://moonjong93.github.io/study/namgungsung_beginer_javascript_semina</id><content type="html" xml:base="https://moonjong93.github.io/study/namgungsung_beginer_javascript_semina">&lt;h2 id=&quot;남궁성-자바스크립트에-참가하다&quot;&gt;남궁성 자바스크립트에 참가하다.&lt;/h2&gt;
&lt;p&gt;예전에 ‘난 정말 자바를 공부한적이 없다구요’라는 책을 보고 남궁성 자바라는 카페를 가입했었는데 어쩌다보니 자바는 전혀 하지 않고 Jvacsript만 주로 하게되었는데 운 좋게 남궁성님이 운영하는 세미나가 있어서 참가하게 되었다.&lt;/p&gt;

&lt;p&gt;물론 처음엔 늦게 신청해서 아쉽게도 참가권에서 밀려났지만 운이 좋게도 한자리 비어서 진행하게되었다.&lt;/p&gt;

&lt;p&gt;이 글은 내가 이 세미나를 들으며 정리하며 내용을 담기로 했다.&lt;/p&gt;

&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Javascript 역사&lt;/li&gt;
  &lt;li&gt;개발도구의 종류와 장단점 - VS code, Webstorm, Atom 등&lt;/li&gt;
  &lt;li&gt;변수의 타입과 선언&lt;/li&gt;
  &lt;li&gt;입력과 출력&lt;/li&gt;
  &lt;li&gt;연산자 - new, typeof, instanceof&lt;/li&gt;
  &lt;li&gt;조건문과 반복문 - for each, for in&lt;/li&gt;
  &lt;li&gt;배열&lt;/li&gt;
  &lt;li&gt;내장객체 형변환함수, ““와 new String(““)의 차이&lt;/li&gt;
  &lt;li&gt;함수
    &lt;ul&gt;
      &lt;li&gt;함수 기본&lt;/li&gt;
      &lt;li&gt;매개변수&lt;/li&gt;
      &lt;li&gt;변수의 스코프&lt;/li&gt;
      &lt;li&gt;클로져&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DOM과 이벤트 처리&lt;/li&gt;
  &lt;li&gt;객체와 생성자
    &lt;ul&gt;
      &lt;li&gt;생성자와 this&lt;/li&gt;
      &lt;li&gt;prototype&lt;/li&gt;
      &lt;li&gt;constructor&lt;/li&gt;
      &lt;li&gt;js에서의 다형성&lt;/li&gt;
      &lt;li&gt;상속&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;javascript의-역사&quot;&gt;Javascript의 역사&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;1995년에 Eredan Eich가 발명, ECMA가 1997년에 표준화 했음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HTML이 원래는 하이퍼링크만 주어진 단순한 문서였는데 이를 동적으로 변화하기 위해서 Javascript로 만들어졌음&lt;/p&gt;

&lt;p&gt;원래 개발당시에는 OOP를 고려하지 않았지만 현재는 상당히 많은 부분에서 사용중이고 현재는 이를 넘어서 함수형 언어가 되었음.&lt;/p&gt;

&lt;p&gt;현재는 Javascirpt가 안쓰이는 곳이 없다. 보안, 출판, Indesign은 Javascript로 책을 자동화로 만들게끔 도와준다.&lt;/p&gt;

&lt;p&gt;실무에선 Jquery를 많이 쓰이는데 탈피해서 자바스크립트 본연으로 돌아가서 JS를 사용하는 경우가 많아지고 있음&lt;/p&gt;

&lt;p&gt;오늘 세미나에서는 JAVA와 js의 차이점에서 대해서 많이 둘거고 실습을 위주로 진행함&lt;/p&gt;

&lt;p&gt;ECMA5와 ECMA6의 차이는 OOP를 추가했다는 점이며 오늘은 ECMA5위주로 진행을 함&lt;/p&gt;

&lt;p&gt;Javascript에서 window 의미하는것은 브라우저를 뜻함&lt;/p&gt;
&lt;h2 id=&quot;개발도구의-종류와-장단점&quot;&gt;개발도구의 종류와 장단점&lt;/h2&gt;

&lt;h2 id=&quot;변수의-타입과-선언&quot;&gt;변수의 타입과 선언&lt;/h2&gt;
&lt;h3 id=&quot;hoisting&quot;&gt;hoisting&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;변수나 함수 선언이 스코프에서 최상단으로 옮겨가는 것
```javascript
num = 5;
var num2 = 1
console.log(num2);
var num;
console.log(num);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;//여기서 num의 선언을 최상단으로 자동으로 올려줌&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;권장하지 않는 프로그래밍임

### Scope
- 함수 내부가 아니면 전부 전역 (var)
- 전역 선언에 경우 브라우저에 변수가 저장된다.
- 지역 변수는 함수 내부에 선언된 선언이 지역변수로 저장된다.
- 변수 선언을 함수든 어디서든 안하면 전역으로 선언됨

```javascript
function sum(a, b){
    var result = 0;
    gResult = 0;
    
    for(var i=0; i&amp;lt; arguments.length; i++){
        gResult += arguments[i];
        console.log(i);
    }
    //var i는 호이스팅에 의해서 최상단으로 올라가게됨
}

console.log(gResult) //undefined
sum(10, 50)
// 0
// 1
console.log(gResult) // 60;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// false인지 ture인지 확인하려면 그냥 타입에 !!해보면됨
console.log(!!undefined);
// false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;연산자&quot;&gt;연산자&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;’==’ ‘===’의 차이 ==는 값비교 ===는 타입까지 비교
    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var num = new Number(0);
var num1 = 0;
console.log(num === num1)
// false
// 타입이 다르다 new Number는 객체이기 때문
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;결론 ==는 쓰지마라
    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var num = new Number(0);
var num1 = 0;
console.log(num == num1);
// true
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;여기에서 num을 자동으로 형변환을 시키기 때문에 좋지 않다.&lt;/p&gt;
    &lt;h2 id=&quot;조건문과-반복문&quot;&gt;조건문과 반복문&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;배열&quot;&gt;배열&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var arr = [1,2,3,4,5];
arr[6] = 100;

console.log(arr);
//1,2,3,4,5, ,100

for(var i in arr) console.log(arr[i]);
// empty, undefined는 건너뜀 in의 특징임
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var arr = [1, 10, 20, 11, 12 ,30];
arr.sort() // 는 사전 정렬이라서 제대로 되지않음
// 그래서 이렇게함
arr.sort( (a, b) =&amp;gt; a - b);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;dom&quot;&gt;DOM&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;DOM은 기본적으로 노드로 생성된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;난-정말-자바를-공부한적이-없다구요&quot;&gt;난 정말 자바를 공부한적이 없다구요&lt;/h2&gt;
&lt;p&gt;찾아보니 남궁성님이 안쓰셨다. 잘못알고 왔다. 망했다.&lt;/p&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;p&gt;이 글을 읽은 사람이라면 누구나 왜 목차랑 인마 달라 이자식아 라는 생각을 하실 수 있다 그렇다 목차와 다르게 세미나가 진행됐다.&lt;/p&gt;

&lt;p&gt;그리고 시간이 모자라서 DOM의 이벤트는 하지 않고 지나갔다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;괜히 갔나 후회 했다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;솔직히 말하면 시간을 버렸고 돈을 버렸다고 생각했다. 기존에 전부 알던 내용이고 복습을 할거면 MSDN을 볼것이고 그것마저도 아니라면 많은 자바스크립트 교재를 한번 훑어보는게 좋다고 생각한다.&lt;/p&gt;

&lt;p&gt;물론 초보자 입장에선 이 강좌가 어떻게 다가올진 모르겠다. 좋다고 생각하는 사람도 있을것이고 그럴것 같다&lt;/p&gt;

&lt;p&gt;그러나 현재 프론트엔드나 자바스크립트 개발을 보자면 es5 기준으로 프로그래밍을 하는 경우는 전혀 없다고 확신한다.&lt;/p&gt;

&lt;p&gt;타입스크립트, ES6(바밸을 통한)면 모를까 상당히 안타까운 시간이었고 설명 자체도 본인이 가져오신 교재를 통해 읽는 것만 반복되는 느낌이었다.&lt;/p&gt;

&lt;p&gt;자바를 알고 있는 사람을 전제하에 세미나가 진행된다고 하셨는데 어느정도 자바를 아는 사람이라면 굳이 세미나를 참가하지 않고 변수 선언 등…을 살펴보기는게 좋지 않을까?&lt;/p&gt;

&lt;p&gt;완전 초보자가 듣기에는 너무 급하게 지나가서 내 옆자리 분은 실제로 제대로 이해하지 못하고 지나갔고 조금 경험이 있는 개발자는 시간이 아깝다고 느끼며 지나갔다.&lt;/p&gt;

&lt;p&gt;이도저도 아닌 세미나였어서 더 이상 쓸 말이 없다.&lt;/p&gt;

&lt;p&gt;책을 사시는것을 추천한다.&lt;/p&gt;</content><author><name></name></author><category term="Javascript" /><category term="beginer" /><summary type="html">남궁성 자바스크립트에 참가하다. 예전에 ‘난 정말 자바를 공부한적이 없다구요’라는 책을 보고 남궁성 자바라는 카페를 가입했었는데 어쩌다보니 자바는 전혀 하지 않고 Jvacsript만 주로 하게되었는데 운 좋게 남궁성님이 운영하는 세미나가 있어서 참가하게 되었다.</summary></entry><entry><title type="html">자바스크립트의 재귀함수 어떻게 이해하면 좋을까?</title><link href="https://moonjong93.github.io/study/How-to-understand-javascript-recursion-function" rel="alternate" type="text/html" title="자바스크립트의 재귀함수 어떻게 이해하면 좋을까?" /><published>2018-08-24T00:00:00+00:00</published><updated>2018-08-24T00:00:00+00:00</updated><id>https://moonjong93.github.io/study/How-to-understand-javascript-recursion-function</id><content type="html" xml:base="https://moonjong93.github.io/study/How-to-understand-javascript-recursion-function">&lt;h2 id=&quot;재귀함수-recursion-function&quot;&gt;재귀함수 (Recursion function)&lt;/h2&gt;
&lt;p&gt;재귀함수는 말 그대로 함수 내에서 자기 자신을 다시 또 호출하면서 로직을 수행하는 함수를 말한다. 재귀함수를 응용하는데 있어서 많은 글들을 읽어봤지만 사실 그렇게 크게 와닿는 글은 없었던것 같다.&lt;/p&gt;

&lt;h2 id=&quot;예제-보기&quot;&gt;예제 보기&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/ko-kr/library/wwbyhkx4(v=vs.94).aspx&quot;&gt;MSDN&lt;/a&gt;의 예제를 살펴보자&lt;/p&gt;

&lt;p&gt;팩토리얼에 재귀함수를 활용하는 예제인데&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function factorial(num)
{
    // If the number is less than 0, reject it.
    if (num &amp;lt; 0) {
        return -1;
    }
    // If the number is 0, its factorial is 1.
    else if (num == 0) {
        return 1;
    }
    var tmp = num;
    while (num-- &amp;gt; 2) {
        tmp *= num;
    }
    return tmp;
}

var result = factorial(8);
document.write(result);

// Output: 40320
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와같은 팩토리얼 함수를 재귀함수로 아래와같이 만들수 있다는 내용이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function factorial(num)
{
    // If the number is less than 0, reject it.
    if (num &amp;lt; 0) {
        return -1;
    }
    // If the number is 0, its factorial is 1.
    else if (num == 0) {
        return 1;
    }
    // Otherwise, call this recursive procedure again.
    else {
        return (num * factorial(num - 1));
    }
}

var result = factorial(8);
document.write(result);

// Output: 40320
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;간단한-예제-그러나-사용처는&quot;&gt;간단한 예제 그러나 사용처는?&lt;/h2&gt;
&lt;p&gt;본인도 그랬다 물론 이해는 되지만 ‘재귀함수’를 사용하면서 얻는 이점이 무엇이 있는지 사실 이해가 잘 가지 않았다.&lt;/p&gt;

&lt;p&gt;왜냐면 후자의 예제 역시 동작이 되며 모두다 같은 결과 값을 가져다 주기 때문이다.&lt;/p&gt;

&lt;p&gt;그러던 도중 타인에게 문제를 받아 해결하는 과정에서 재귀함수를 사용해 꽤 간단하게 문제를 풀어냈기에 이 예제를 본다면 다른 사람도 어느정도 도움이 될것 같아서 작성하게 되었다.&lt;/p&gt;

&lt;h2 id=&quot;다차원-배열을-1차원-배열로-만드는-예제&quot;&gt;다차원 배열을 1차원 배열로 만드는 예제&lt;/h2&gt;
&lt;p&gt;다차원 배열이란 배열이 한개의 차원이 아닌 여러개의 차원이 되는 그런 배열을 뜻한다. 다차원 배열이 된 이상 배열의 크기는 그렇게 중요하지 않고 어느 부분이라도 확장될수 있다.&lt;/p&gt;

&lt;p&gt;1차원 배열이란 [0,1,2,3,4,5]와 같은 배열을 말하며
2차원 배열은 [ [1,2,3], [4,5,6] ]과 같은 배열을 말한다.&lt;/p&gt;

&lt;p&gt;그러나 다 차원 배열은 저것을 넘어선 어느 부분에서건 증가가 가능해지는데 아래와 같은 배열도 다차원 배열에 속한다&lt;/p&gt;

&lt;p&gt;[ 0, [1,2, [3,2,3,1], [0,1,2,3,] ],2,3,4 [1,2,3, [4, [6] ] ] ] 과 같이 보기도 힘든 배열…도 역시 다차원 배열에 속한다.&lt;/p&gt;

&lt;p&gt;그러나 이런 배열들을 1차원 배열로 바꾸기 위해서는 어떻게 해야할까?&lt;/p&gt;

&lt;p&gt;말 그대로 위의 배열을 [ 0, 1, 2, 3, 3, 1 …]와 같이 말이다.&lt;/p&gt;

&lt;h2 id=&quot;일반적인-for문을-이용해서-푼다면&quot;&gt;일반적인 For문을 이용해서 푼다면?&lt;/h2&gt;
&lt;p&gt;그러니까 나쁜 방법부터 생각해보자 일반적인 for문을 이용한다면 어떻게 풀 수 있을까?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Solution(target){
    
    var result = []

    // 만약 배열이 아니라면 이 함수를 종료
    if(!Array.isArray(target))
        return null

    // 타갯의 길이 만큼 반복
    for(var i = 0; i &amp;lt; target.legnth; i ++){
        // 타갯의 i가 배열인지 확인
        if( !Array.isArray(  target[i] ) ){
            // 배열이 아니라면 1차원 배열에 삽입
            result.push(target[i])
        }else{
            for(var j = 0; j &amp;lt; target[i].length; j ++){
                if( !Array.isArray(  target[i][j] ) ){
                    result.push(target[i][j])
                }
            }else{
                .
                .
                .
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;와 같이 depth에 관한 정보를 모른다면 어디까지 코딩해야하는지 알 수 없다. 즉 거의 불가능에 가깝다.&lt;/p&gt;

&lt;p&gt;그렇다면 어떻게 하면 효율적으로 해결할 수 있을까?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;function Solution(target){
    // 결과를 담을 변수
    var result = [];
    
    for(var i =0 ; i &amp;lt; target.length; i++){
        // 어레이가 아니라면 push해주고 
        if( !Array.isArray( target[i] ) )
            result.push( target[i] )
        else{
            result = result.concat( Solution( target[i] ) )
        }
    }

    return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 처럼 해결할 수 있다.&lt;/p&gt;</content><author><name></name></author><category term="Javascript" /><category term="Recursion" /><summary type="html">재귀함수 (Recursion function) 재귀함수는 말 그대로 함수 내에서 자기 자신을 다시 또 호출하면서 로직을 수행하는 함수를 말한다. 재귀함수를 응용하는데 있어서 많은 글들을 읽어봤지만 사실 그렇게 크게 와닿는 글은 없었던것 같다.</summary></entry><entry><title type="html">나는 graphql을 이해했다</title><link href="https://moonjong93.github.io/study/I-understand-grahpql" rel="alternate" type="text/html" title="나는 graphql을 이해했다" /><published>2018-08-16T00:00:00+00:00</published><updated>2018-08-16T00:00:00+00:00</updated><id>https://moonjong93.github.io/study/I-understand-grahpql</id><content type="html" xml:base="https://moonjong93.github.io/study/I-understand-grahpql">&lt;h2 id=&quot;graphql은-무엇일까&quot;&gt;Graphql은 무엇일까?&lt;/h2&gt;
&lt;p&gt;대다수의 블로그를 보면 마치 정말 전지전능한 실제 기술같았다. 왜냐면 꼭 파이어베이스와 같이 서버리스 플랫폼에서 제공하는 플랫폼의 ‘라이벌’이라고 얘길 해서 나는 Firebase(‘이하’ 파이어베이스) 같이 별다른 설정 없이 사용할 수 있는줄 알았다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;잘못된 이해였다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;실제로 Graphql과 RESTfullAPI의 설계는 많은 차이를 보이지만 결국엔 내가 컨트롤 한다는 점에선 변화가 없고 대신 라우터의 관리 파라미터의 관리가 엄청 쉬워진다는 장점이 있다.&lt;/p&gt;

&lt;p&gt;기존에 JWT토큰을 발행하기 위해서 /login/createjwttoken이라는 라우터에서 파라미터를 받아서 컨트롤 하기 위해서 Node.js에 새로운 라우터를 만들고……..&lt;/p&gt;

&lt;p&gt;이런 행위를 하지 않고 모든 라우터를 graphql에 묶어서 관리해주면된다.&lt;/p&gt;

&lt;h2 id=&quot;그럼-무엇을-잘못-이해했을까&quot;&gt;그럼 무엇을 잘못 이해했을까?&lt;/h2&gt;

&lt;p&gt;나는 Graphql을 접하기전에 파이어베이스를 먼저 접했다. 파이어베이스는 별다른 설정없이 데이터를 설계하고 스키마 설계를 필요하지도 않고 단지 그냥 그저 쓸 뿐이었다.&lt;/p&gt;

&lt;p&gt;난 Graphql이 그런건줄 알았다. 대다수의 블로그 글들은 Query와 Mutaion과 같은 데이터를 불러오는 예제만 기록되어있었다.&lt;/p&gt;

&lt;p&gt;Node.js에서 별다른 설치없이 데이터베이스와 연결만하면 Sequlize라는 ORM 기반 모듈처럼 데이터베이스도 알아서 만들어주고 테이블도 알아서 관리해주는줄 알았다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그러나 완전히 반대였다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;그러면-내가-이해한-graphql은&quot;&gt;그러면 내가 이해한 Graphql은?&lt;/h2&gt;

&lt;p&gt;이번 개인프로젝트에 적극적으로 도입해서 모든 요청은 Graphql로 처리하고있다,&lt;/p&gt;

&lt;p&gt;가장 이해하기 힘든 부분은 ‘로그인’에 대한 처리였는데 이걸 이해하고선 Graphql을 빨리 이해할 수 있었다.&lt;/p&gt;

&lt;p&gt;우선 Graphql은 데이터베이스를 직접적으로 만들어주지 않는다. Resolver라는 부분을 통해서 요청이 들어오면 해당 요청을 검토하고 데이터를 컨트롤 해야한다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;export default {
    // 로그인 -&amp;gt; JWT토큰 만들어서 token을 리턴해줌 
Query: { 
        login: (_, {email, password}, ctx) =&amp;gt; {
            console.log(ctx)
            return models.User.findByEmail({email, password})
            .then( (user) =&amp;gt; {
                if(user.password == createHash(password)){
                    return createJWTToken(user.id, user.displayName)
                    .then((token) =&amp;gt; {
                        return { token }
                    })
                }else{
                    return new Error('not matched password')
                }
            })
            .catch((err) =&amp;gt; {
                return new Error('not found user')
            })
        },
    },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위와 같이 결국 데이터를 직접 조회해서 해당 데이터를 비교후에 리턴값으로 Token이라는 기존에 저작되어있는 타입을 리턴해준다 Token의 값은 단순 String에 속한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;type User {
        id: ID!
        email: String! @isUnique
        password: String!
        displayName: String!
    }

type Token {
    token: String!
}

type Query {
    login(email: String!, password: String!): Token
}

type Mutation {
    register(email: String!, password: String!, displayName: String!): User
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결국엔 Json으로 들어온 객체를 통해 받아온 데이터를 활용해서 알맞는 리턴값을 구해서 만들어줘야한다는 점이다.&lt;/p&gt;

&lt;p&gt;결국에 내가 생각했던 ‘연결만 하고 타입설정만 하면 끝’이라는 것과는 너무 큰 차이가 있었다.&lt;/p&gt;

&lt;h2 id=&quot;graphql을-사용하면서의-이점&quot;&gt;Graphql을 사용하면서의 이점&lt;/h2&gt;
&lt;p&gt;아무리 그래도 직접 Router를 통해서 하나하나 Post부터 시작해서 Get등 다양한 메서드를 갖는 라우터를 설계하는것보단 훨씬 작업 속도가 빨랐다.&lt;/p&gt;

&lt;h2 id=&quot;graphql을-앞으로도-계속-사용할건지&quot;&gt;Graphql을 앞으로도 계속 사용할건지?&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;네!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;당장 스텍오버플로우만 봐도 그렇듯 상당히 많은 수요가있다. 그리고 막상 사용해보니 처음 이해할때만 조금 어려웠고 막상 이해하고 나니 파일관리도 편하고 기본적으로 Apollo 라는 모듈을 사용할땐 서버를 별다른 설정을 하지 않아도 테스트할 수 있게 서버를 만들어줘서 상당히 편리했다.&lt;/p&gt;</content><author><name></name></author><category term="graphql" /><category term="mysql" /><summary type="html">Graphql은 무엇일까? 대다수의 블로그를 보면 마치 정말 전지전능한 실제 기술같았다. 왜냐면 꼭 파이어베이스와 같이 서버리스 플랫폼에서 제공하는 플랫폼의 ‘라이벌’이라고 얘길 해서 나는 Firebase(‘이하’ 파이어베이스) 같이 별다른 설정 없이 사용할 수 있는줄 알았다.</summary></entry><entry><title type="html">MongoDb를 처음 접한 내가, 잘못이해했던 RDS</title><link href="https://moonjong93.github.io/study/I-was-wrong-understand-RDS" rel="alternate" type="text/html" title="MongoDb를 처음 접한 내가, 잘못이해했던 RDS" /><published>2018-07-13T00:00:00+00:00</published><updated>2018-07-13T00:00:00+00:00</updated><id>https://moonjong93.github.io/study/I-was-wrong-understand-RDS</id><content type="html" xml:base="https://moonjong93.github.io/study/I-was-wrong-understand-RDS">&lt;h2 id=&quot;mongodb를-접하다&quot;&gt;MongoDb를 접하다&lt;/h2&gt;
&lt;p&gt;그랬다. MognoDb’이하 몽고디비’를 접했었다. 그것은 내가 샀던 Node.js 책에서 저자가 정말 너무나도 추천을 했었고 당시 유행했던 ‘MEAN STACK’ 프로젝트의 구성요소 때문이기도 했었다.&lt;/p&gt;

&lt;p&gt;몽고디비는 정말로 핫했고 지금도 물론 너무나도 좋은 데이터베이스임에 분명하다 NoSql중 단연 으뜸이기도 하다&lt;/p&gt;

&lt;p&gt;Oracle, Mysql, Ms Sql, PostgreSQL, MongoDb라는 순위를 &lt;a href=&quot;https://db-engines.com/en/ranking&quot;&gt;데이터베이스 랭킹&lt;/a&gt;에서 확인 할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;mongodb가-가진-장점의-이해&quot;&gt;MongoDb가 가진 장점의 이해&lt;/h3&gt;
&lt;p&gt;나는 당시에 Nosql이 가진 가장 큰 장점은 ‘확장성’이라고 생각했다. 단지 확장성 하나 때문에 Mysql을 안사용하고 몽고디비를 써야겠다고 생각했다. 그러나 이것은 정말로 큰 오해였다.&lt;/p&gt;

&lt;h2 id=&quot;mysql에-관심을-가지게된-계기부터&quot;&gt;Mysql에 관심을 가지게된 계기부터&lt;/h2&gt;
&lt;p&gt;나는 사실 서버도 좋아하고 프론트엔드도 좋아하는 어쩌면 잡 개발자라고 할수 있다 사실 아직은 이렇다할 정체성을 가지지 못하고 있다. 두개다 재밌기 때문인데.&lt;/p&gt;

&lt;p&gt;최근 면접에서 단연코 많이 하는 질문은 ‘RDS’에 관한 이해였다.&lt;/p&gt;

&lt;p&gt;RDS는 중요했다. 웹을 지탱하는 데이터베이스 중 그것은 단연 으뜸이다.&lt;/p&gt;

&lt;p&gt;그러나 나는 사실 이런 RDS에 대해 자세히 이해하지 못했었는데 그것은 전혀 관심이 없기 때문이었다.&lt;/p&gt;

&lt;p&gt;그러나 다음 면접을 위해선 반드시 공부해야겠다고 생각했고 최근까지도 RDS로 토이프로젝트를 만들며 배워보고있다.&lt;/p&gt;

&lt;h2 id=&quot;rds의-확장성&quot;&gt;RDS의 확장성&lt;/h2&gt;
&lt;p&gt;정말 확장성이 없을까?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;그렇다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;내 개념에선 적어도 그랬다. 왜냐면 애초에 테이블을 ‘설계’해야하고 이 테이블은 사실상 바뀌기 힘들었기 때문이다.&lt;/p&gt;

&lt;p&gt;Nosql을 예를 들자면 그냥 도큐먼트에 새로운 객체 하나만 추가하면 만들어지는 데이터베이스 와는 정반대로&lt;/p&gt;

&lt;p&gt;‘수정’을 해야한다고 생각했기 때문이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그러나 그것은 잘못된 이해였다.
RDS를 반대로 이해한것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;데이터베이스의-정규화&quot;&gt;데이터베이스의 정규화&lt;/h2&gt;
&lt;p&gt;‘정규화’를 이해하지 못했기 때문에 확장성이 없다고 판단한것이었다. 데이터베이스의 정규화란 몇가지의 형식이 있으며 정말로 간단하게 설명하자면&lt;/p&gt;

&lt;p&gt;기존에 내가 이해했던 RDS란 하나의 테이블의 모든 데이터를 꾸겨넣는다고 생각했다.&lt;/p&gt;

&lt;p&gt;예를 들어 성적에 관한 데이터베이스를 만든다면&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th&gt;국어&lt;/th&gt;
      &lt;th&gt;영어&lt;/th&gt;
      &lt;th&gt;수학&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;종민&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;90&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;준형&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;와 같은 형식으로 만들었을 것이다.&lt;/p&gt;

&lt;h3 id=&quot;그러나-정규화를-이해하고-나선-조금-달라진다&quot;&gt;그러나 정규화를 이해하고 나선 조금 달라진다.&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;이름&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;종민&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;준형&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이라는 테이블을 하나 만들고&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;pub_id&lt;/th&gt;
      &lt;th&gt;국어&lt;/th&gt;
      &lt;th&gt;영어&lt;/th&gt;
      &lt;th&gt;수학&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;90&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;22&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;과 같이 만들것이다.&lt;/p&gt;

&lt;p&gt;pub_id란 위의 종민 준형의 id값을 가리키는 Foreign key’FK’가 된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;즉 관계형 데이터베이스를 관계정 데이터베이스 답게 이해하게 된것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;이제는-확장성에-대해서-고민할-필요가-없다&quot;&gt;이제는 확장성에 대해서 고민할 필요가 없다.&lt;/h2&gt;
&lt;p&gt;혹시 아직도 RDS의 확장성에 대해서 고민할 수 있을까? 절대로 그래선 안된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;만약 내가 새로운 데이터를 추가하고 싶다면 원 테이블을 고민하는게 아니라 새로운 테이블을 만들어 관계를 추가하면 되기 때문이다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="RDS" /><category term="Mysql" /><summary type="html">MongoDb를 접하다 그랬다. MognoDb’이하 몽고디비’를 접했었다. 그것은 내가 샀던 Node.js 책에서 저자가 정말 너무나도 추천을 했었고 당시 유행했던 ‘MEAN STACK’ 프로젝트의 구성요소 때문이기도 했었다.</summary></entry><entry><title type="html">Firestore 이해하기</title><link href="https://moonjong93.github.io/development/firestore-knowlage" rel="alternate" type="text/html" title="Firestore 이해하기" /><published>2018-06-25T00:00:00+00:00</published><updated>2018-06-25T00:00:00+00:00</updated><id>https://moonjong93.github.io/development/firestore-knowlage</id><content type="html" xml:base="https://moonjong93.github.io/development/firestore-knowlage">&lt;h2 id=&quot;순서&quot;&gt;순서&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Firebase의 등장 배경&lt;/li&gt;
  &lt;li&gt;그래서 등장한 Firestore&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;firebase의-등장-배경&quot;&gt;Firebase의 등장 배경&lt;/h2&gt;
&lt;p&gt;정말 간단히 말하자면 클라이언트 개발자의 새로운 개발을 위해 생겼다고 볼 수 있다. 지금은 물론 구글의 인수 이후로 정말 날개를 단듯 MLkit이라던지 내부적으로도 많은 업데이트를 진행하고 있지만 기본적인 출발은 ‘시작을 빠르게’라는 취지로 누구나 웹 개발, 앱 개발을 더 이상 서버까지 고민하지 말고 만들자. 라는 출발이었다&lt;/p&gt;

&lt;p&gt;그 출발은 괜찮았다 Firebase(이하 ‘파이어베이스’)의 요금은 정말로 합리적이었으며 내부적으로 제공하는 Storage와 Authentications등은 데이터베이스 하나로 파이어베이스를 사용하는 것이 아니라 그 외에 부가적인 부분에서도 많은 이득을 챙길 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;나와 같은 경우 처음 파이어베이스에 대해서 듣게 되었을땐 ‘정말로 이런 서비스가 가능한가?’라는 의문도 품었었다.&lt;/p&gt;

&lt;p&gt;그러나 매끄럽게 가능했다. 파이어베이스 실시간 데이터베이스는 더욱 더 그러했다. 별다른 서버사이드 코드없이도 이제 프로토타입 그리고 어느정도 규모있는 앱까지는 충분히 만들어 볼만 했다.&lt;/p&gt;

&lt;h3 id=&quot;어느정도에-주목하자&quot;&gt;‘어느정도’에 주목하자&lt;/h3&gt;
&lt;p&gt;물론 이 글을 읽는 당신이 개인 개발자고 개인으로서 결과물이 어느정도 훌륭해서 금전적인 이득을 얻는 수준의 ‘규모’에서는 전혀 문제될게 없었다.&lt;/p&gt;

&lt;p&gt;그래서인지 해외에서도 개인이 앱을 만들어 먹고사는 ‘개인 개발자’에게 있어서는 정말로 괜찮은 서비스이었다.&lt;/p&gt;

&lt;p&gt;왜 ‘규모’에 대해서 언급하냐면 Firebase의 데이터베이스는 괘랄하다 못해서 사실 별로였다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;아니 괜찮다며;;&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;아니 정말 괜찮은 서비스임에 분명했지만, Query의 부재 그리고 속도 등의 이슈로 규모가 조금 있는 서비스라면 사용을 자제하는것이 좋다고 생각이 들었다.&lt;/p&gt;

&lt;h1 id=&quot;그래서-등장한-firestore&quot;&gt;그래서 등장한 Firestore&lt;/h1&gt;
&lt;p&gt;지금은 물론 ‘Beta’서비스 이긴 하지만 말 그대로 ‘등 - 장’했다.&lt;/p&gt;

&lt;p&gt;모름지기 개발자라면 ‘프레임워크, 라이브러리에 대한 의존성이 없어야해!’라고 말씀하셨던 선배님의 말씀이 떠오르지만 Firestore(이하 ‘파이어스토어’)에는 조금 의존을 해보고 싶었다.&lt;/p&gt;

&lt;p&gt;그동안 존재하지 않았던 Query와 더욱 더 강력해진 Rule과 이제 더 이상은 파이어베이스를 사용하지 않아도 괜찮다!&lt;/p&gt;

&lt;p&gt;파이어스토어의 몇가지 특징을 얘기하자면&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;빠른 NosSql 데이터 베이스
    &lt;ul&gt;
      &lt;li&gt;콜렉션과 도큐먼트 기반의 확장성이 용이한 데이터 베이스 설계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Query의 사용이 가능함 (Admin-sdk에서는 기능이 더욱 강함 ‘Skip’ 등)&lt;/li&gt;
  &lt;li&gt;파이어베이스부터 단련된 Rule!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등을 대표적으로 얘기할 수 있는데&lt;/p&gt;

&lt;p&gt;이런 데이터베이스를 서버사이드 코드 없이 사용할 수 있다는것은 정말 개발자로 하여금 많은 일을 가능하게 만든다.&lt;/p&gt;

&lt;p&gt;가령 기존 파이어베이스로 게시판을 만든다고 했다면 당연히 하지말라고 얘기했을 것이다 차라리 페이스북의 &lt;a href=&quot;https://graphql.org/learn/&quot;&gt;GraphQL&lt;/a&gt;을 사용하라고 하고싶었다.&lt;/p&gt;

&lt;p&gt;그러나 이번엔 다르다 빠른 NoSql의 데이터베이스는 기존 정적인 게시판이 아닌 정말 넓은 확장성을 자랑하는 게시판을 만들 수도 있으며&lt;/p&gt;

&lt;p&gt;게시판에서 빠질수 없는 검색등의 기능도 향상된 Query로 만들수 있으며&lt;/p&gt;

&lt;p&gt;거기다가 Functions의 연동을 통한다면 기존에 우리가 사용하던 데이터베이스들에 내장되어있던 Skip등의 기능이 사용가능하다는 점이 있다.&lt;/p&gt;

&lt;h3 id=&quot;내가-생각하는-가장-중요한-rule&quot;&gt;내가 생각하는 가장 중요한 ‘Rule’&lt;/h3&gt;
&lt;p&gt;그러나 파이어베이스, 스토어 사용에 있어서 가장 중요한 점은 Rule이다 바로 Rule이 Rule을 어떻게 사용하느냐에 따라 여러분의 서비스는 굳이 의미 없는 파이어스토어 사용이 될 수 도있으며 반대로 매우 매끄러운 사용이 가능해진다&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;고작 Rule하나로?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그렇다 Rule은 상당히 중요하다. Rule이 파이어스토어의 존재 이유라고 할수 있을 정도로 중요하다. 예를들자면 당신의 블로그에 설정은 당신만이 할 수 있어야만 한다. 이것을 서버사이드에서 처리하자면&lt;/p&gt;

&lt;p&gt;요즘 유행하는 Token방식의 인증으로 매기자면 Token 내부에 예를들면 ‘isAdmin’이라는 변수를 만들어놓고 새로 들어온 요청에 한해서 이것을 검증을 해서 그 다음 로직을 실행…..하게 해야한다.&lt;/p&gt;

&lt;p&gt;그러나 파이어스토어는 이런 검증을 Rule에서 해결 가능하다. 요청하는 유저의 UID값을 받아온 뒤 Rule 내부에서 또 다시 Get을 한다음에 해당 블로그의 주인만 가려놓고 만약 맞다면 Allow를 아니라면 딱히 코드를 작성하지 않아도 Permission 에러를 뿜으며 실행되지 않을것이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;응? 적고 보니까 Token 방식이 더 간단하네?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그렇다 당신이 ‘서버사이드’를 조금 공부했다면 사실 위에 방법이 더욱 쉬울 것이다. 나도 그랬다 사실 처음엔 이해가 안됐고 오히려 개발 시간이 서버를 갖는 것보다 오래 걸리기 때문에 짜증도 났다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그러나 분명한건 이것은 서버의 관리 없이도 돌아간다는 점이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;간혹 ‘서버리스’에 대해서 언급하면 꼭&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그걸 왜함?? 어차피 서버 규모 커지면 그냥 서버가 더 이득임&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라는 말을 찾아 볼 수 있는데 서버 개발자의 월급은 하늘에서 떨어지는줄 아는 사람이 많다. 생각보다 서버개발자의 임금은 높다. 데이터베이스를 매끄럽게 설계해야하는 그들은 당연히 받아가야할 임금을 받아가는 것이고 아까는 정말 단순하게 Token으로 인증하는 것을 말했지만 실제 데이터베이스 설계에선 어쩌면 더욱 많은 절차가 필요할지도 모른다.&lt;/p&gt;

&lt;h2 id=&quot;그래서&quot;&gt;그래서&lt;/h2&gt;
&lt;p&gt;일단 함 써보세요 진짜 Rule만 잘 이해하면 이만한 서버리스 프로젝트가 없을겁니다.&lt;/p&gt;

&lt;p&gt;그러나 최근 AWS에 &lt;a href=&quot;https://aws.amazon.com/ko/appsync/&quot;&gt;AppSync&lt;/a&gt;가 GraphQL을 도입해 비슷한 서비스를 하고 있으니 한번 찾아보시는 것도 추천합니다.&lt;/p&gt;</content><author><name></name></author><category term="서버리스" /><category term="Firebase" /><category term="Firestore" /><summary type="html">순서 Firebase의 등장 배경 그래서 등장한 Firestore</summary></entry><entry><title type="html">Tac.photos를 개발이야기 - 배운게 많다</title><link href="https://moonjong93.github.io/career/tac-photos-develop-after" rel="alternate" type="text/html" title="Tac.photos를 개발이야기 - 배운게 많다" /><published>2018-04-23T00:00:00+00:00</published><updated>2018-04-23T00:00:00+00:00</updated><id>https://moonjong93.github.io/career/tac-photos-develop-after</id><content type="html" xml:base="https://moonjong93.github.io/career/tac-photos-develop-after">&lt;h2 id=&quot;시작하기-앞서&quot;&gt;시작하기 앞서&lt;/h2&gt;
&lt;p&gt;올해에 들어 SPA를 접하고 여러가지 개발을 하면서 꼭 개인프로젝트 하나를 해야겠다는 생각을 했다. 시작은 정말 거대 했다.&lt;/p&gt;

&lt;p&gt;애초에 계획은&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;로그인
    &lt;ul&gt;
      &lt;li&gt;Token을 활용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Serverless
    &lt;ul&gt;
      &lt;li&gt;모든 부분에 Serverless 적용&lt;/li&gt;
      &lt;li&gt;S3에 업로드 하며 당연히 썸네일도 필요할것이라 예측&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;태그 검색&lt;/li&gt;
  &lt;li&gt;비밀 이미지&lt;/li&gt;
  &lt;li&gt;등등..&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;등 상당히 많은 계획과 방대한 양의 기획이 있었다. 실제로 로그인도 구현했으며 이메일 인증은 AWS의 SES를 통한 메읿 발송과 Nodemailer를 활용해 나름 멋스럽게 Table단위의 폼도 적용해서 보내기 까지 만들었다..&lt;/p&gt;

&lt;p&gt;그러나 결과적으로 모든걸 다 없애고 그냥 이미지 업로드만 냅두고 출시하게 되었다는 것이다… 상당히 애통하지만 몇가지 큰 이유들이 있었다.&lt;/p&gt;

&lt;h3 id=&quot;누가-쓰겠어&quot;&gt;누가 쓰겠어?&lt;/h3&gt;
&lt;p&gt;처음 계획은 이미지를 누구나 쉽게 공유하고 업로드 이후에 간단한 링크를 만들어 &lt;a href=&quot;https://imguar.com&quot;&gt;imguar&lt;/a&gt;과 같은 사이트 이지만 약간 한국의 느낌과 맞추고 싶었고 실제로 그게 정말 잘 될것 같다고 생각했다.&lt;/p&gt;

&lt;p&gt;그러나 몇가지 문제에 부딪혔다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;비용&lt;/li&gt;
  &lt;li&gt;디자인&lt;/li&gt;
  &lt;li&gt;홍보&lt;/li&gt;
  &lt;li&gt;쓰고자 하는 동기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 어느것도 충족할 수 없었다. 비용에 따른 문제를 고민하면서 서버도 고민하고 거기다가 가끔 뿜어져나오는 Serverless-http 와 그외 데이터베이스 등 많은 연동에서의 오류는 어느순간 나에게 이 프로젝트를 포기하라고 소리쳤다.&lt;/p&gt;

&lt;h2 id=&quot;무엇을-개발도중에-없앴나&quot;&gt;무엇을 개발도중에 없앴나?&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://i.tac.photos/p/rJmAmJj3M.png&quot; alt=&quot;없애버린 것들 중 하나&quot; /&gt;
그렇게 없애버린것에는 많은 것이 있었다. 대표적으로 로그인이 그렇다 소셜로그인은 Hello.js를 통해 서버에는 오로지 유저의 Email과 어떤 종류의 소셜로 로그인 했는지만 반영해서 혹시 가입되어 있지 않는 유저라면 닉네임 설정으로 넘어가게 되었고&lt;/p&gt;

&lt;p&gt;이메일 회원가입은 가입 요청과 동시에 AWS SES를 통해 이메일을 발송해서 허락이 나야만 로그인 할 수 있었다.&lt;/p&gt;

&lt;p&gt;그 외에도 이미지 태깅 검색부터 상당히 많이 부분을 아니 사실 다 날렸다고 보면된다..&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;빠르게 버리는것도 도움이 된다고 생각한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;그래서-무엇을-했나&quot;&gt;그래서 무엇을 했나?&lt;/h2&gt;
&lt;p&gt;하지만 이 프로젝트를 중간에 포기했더래도(물론 그러지 않았지만) 상당히 배운게 많았다 우선 SPA앱이 가지는 한계와 이것을 극복하기 위한 노력들.. 예를들면 Cloudfront에서는 Vue Router를 403즉 없는 페이지로 인식하는데 그런 페이지의 처리 부터 시작해서 ssl의 적용 그리고 서비스워커 템플릿을 이용했을때의 단점 등… 사실 배운것만 생각하면 최고의 프로젝트였다.&lt;/p&gt;

&lt;h3 id=&quot;무엇을-배웠을까&quot;&gt;무엇을 배웠을까?&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;SPA
    &lt;ul&gt;
      &lt;li&gt;라우터에 이동전 파라미터를 주고 받을때의 일&lt;/li&gt;
      &lt;li&gt;SPA앱을 구축하는데 특히 Head 태그를 관리하는 일&lt;/li&gt;
      &lt;li&gt;데이터를 변경하고 가져올때 제대로 된 구조화를 하지 않으면 오히려 내가 힘들다는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AWS
    &lt;ul&gt;
      &lt;li&gt;Route 53
        &lt;ul&gt;
          &lt;li&gt;Api gateWay의 Custom doamin을 위해서.&lt;/li&gt;
          &lt;li&gt;S3의 버킷 접근을 좀더 용이하게 만들기 위해서.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;S3
        &lt;ul&gt;
          &lt;li&gt;S3에서 버킷 URL을 짧게하기&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CloudFront
        &lt;ul&gt;
          &lt;li&gt;SPA앱은 존재하지 않는 파일을 요청하니 무조건 403을 내뿜기에 여러가지 세팅이 필요했다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Lambda
        &lt;ul&gt;
          &lt;li&gt;serverless-http를 사용할거면 람다에서 세팅을 하는 경우는 거의 없으며 대부분은 Serverelss.yml을 통해서 해결해야한다 (버킷 억세스 권한 등등)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그외
    &lt;ul&gt;
      &lt;li&gt;Token 인증
        &lt;ul&gt;
          &lt;li&gt;토큰 인증은 앞으로 대다수의 Session 방식을 사용하고 있는 웹에서 앞으로 지향해야할 방향이라고 생각한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Vuex
        &lt;ul&gt;
          &lt;li&gt;MVC패턴을 벗어나 Redux패턴 즉 Store 기반의 웹은 처음 도입하기에 조금 꺼려졌지만 특히 User의 정보를 담아 다양한 컴포넌트에서 활용을 하면서 사용하니까 너무나도 필요한 존재라는 것을 알게되었다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;지금 생각나는 것만 손에 꼽아도 상당히 많은 것들을 배울 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.tac.photos/p/Skx0M1o3f.png&quot; alt=&quot;고민의 흔적들&quot; /&gt;
상당히 많은 고민의 흔적들…&lt;/p&gt;

&lt;h2 id=&quot;다음프로젝트는&quot;&gt;다음프로젝트는?&lt;/h2&gt;
&lt;p&gt;무조건 Firebase를 쓸 생각이다. 데이터베이스를 관리하며 SPA앱을 만들고 거기다가 서버사이드의 RESTful API를 만들며 작업하는건 상당히 많은 시간이 걸린다는 것을 다시 한번 깨우쳤다.&lt;/p&gt;

&lt;p&gt;물론 graphQL을 한번 써서 프로젝트를 해보고 싶긴하지만 다음 프로젝트는 절대로 아니다. 앞으로의 개인프로젝트는 단순히 나의 포트폴리오 용도로 만드는것이 아니라 진짜 수익이 나는 괜찮은 앱을 만들어보고 싶기에 우선은 보여지는 프론트엔드 부분에 많은 고민을 할애하고 싶고 또 기획에 많은 고민을 하고 싶다.&lt;/p&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;서버리스 프로젝트는 너무나도 정말 최고였다. EC2서버를 운영할땐 스케쥴도 상당히 많이 체크해야 했고 동시접속을 얼마나 견딜 수 있을지 동일 요청을 얼마나 버틸지 등 많은 부분을 고민 해야 했다.&lt;/p&gt;

&lt;p&gt;앞으로의 웹은 RESTful이 대세가 이룰것이라고 확신한다 아니 100%다. 물론 과거에는 Node.js개발자나 PHP등 서버사이드 개발자가 해야할 일이 서버관리와 유연한 데이터베이스를 설계하는 일 이었다면&lt;/p&gt;

&lt;p&gt;이제는 분명히 프론트엔드와 백엔드의 무게가 동등 해지고 있다고 생각이 들었다.&lt;/p&gt;

&lt;p&gt;웹을 만든다, 라는 생각을 하면 나는 정말 무조건 드는 생각이 있는데 바로 어떻게 하면 내 서버자원을 유저가 최대한 적게 사용할까?? 라는 고민이었다. 이 고민은 나의 첫 프로젝트였던 Overdoc - 오버워치 데이터 제공 웹을 개발할때도 했던 생각이었는데&lt;/p&gt;

&lt;p&gt;나는 죽어도 내 서버를 호락호락하게…크흠 아무튼 최대한 서버 요청은 적을수록 좋다고 생각한다. 지금까지도 그렇게 생각해왔지만 이번 프로젝트를 하고 나서는 정말 그런 생각이 더욱 커졌다.&lt;/p&gt;

&lt;p&gt;앞으로의 RESTful기반 웹사이트는 당연히 서버리스가 좋다고 생각하고 이런 서버로의 요청을 조금이라고 덜 하기 위해서는 무조건적으로 프론트사이드에서 요청을 최소화 하기 위한 작업들을 많이 해줘야한다고 생각한다.&lt;/p&gt;

&lt;p&gt;그리고 아무래도 이 프로젝트는 그동안 블로그에 글을 작성하며 이미지 업로드 하기가 귀찮았는데.. 그 용도로 쓰면 될것같다.&lt;/p&gt;

&lt;p&gt;혹시라도 이 글을 읽는 분이 계신다면 &lt;a href=&quot;http://tac.photos&quot;&gt;Tac.phtoos&lt;/a&gt;한번 접속해주는 것도…&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이번 프로젝트로 정말 많은걸 배웠다.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="Node.js" /><category term="S3" /><category term="Lambda" /><category term="vue.js" /><summary type="html">시작하기 앞서 올해에 들어 SPA를 접하고 여러가지 개발을 하면서 꼭 개인프로젝트 하나를 해야겠다는 생각을 했다. 시작은 정말 거대 했다.</summary></entry><entry><title type="html">AWS의 S3에 CNAME을 연결하기</title><link href="https://moonjong93.github.io/AWS/how-to-Interlink-s3-and-cname" rel="alternate" type="text/html" title="AWS의 S3에 CNAME을 연결하기" /><published>2018-03-29T00:00:00+00:00</published><updated>2018-03-29T00:00:00+00:00</updated><id>https://moonjong93.github.io/AWS/how-to-Interlink-s3-and-cname</id><content type="html" xml:base="https://moonjong93.github.io/AWS/how-to-Interlink-s3-and-cname">&lt;h2 id=&quot;왜&quot;&gt;왜?&lt;/h2&gt;
&lt;p&gt;버킷을 처음 생성해 그 도메인 그대로 사용하면 상당히 긴 도메인이 나온다. 내가 만들고 있는 프로젝트에 이미지를 공유하는게 주된 목적인데 EX)https://s3.amazonaws.com/test.tac.photos/DASNKFDSANf134ia9s90fd.jpeg 이렇게나 긴 도메인은 보기도 힘들고 복사해서도 길이가 너무 길어서 편하자고 사용한 내 웹사이트에서 오히려&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;왜 이따구로 주소가 길어??&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라는 불편함을 느낄것 같았다.&lt;/p&gt;

&lt;h2 id=&quot;준비&quot;&gt;준비&lt;/h2&gt;
&lt;p&gt;우선 버킷의 생성이 필요하다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;내가 원하는 도메인을 구매한다.
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://kr.godaddy.com/&quot;&gt;GoDaddy&lt;/a&gt;를 추천한다.&lt;/li&gt;
      &lt;li&gt;참고로 나는 GoDaddy에서 구매후 네임서버를 ROUTE53으로 이전해서 사용중이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;버킷은 내가 사용하려고 하는 도메인의 주소와 일치하게 해서 생성
    &lt;ul&gt;
      &lt;li&gt;예) 버킷을 test.domain.com으로 생성한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 구매와 생성이 끝났다면 거의 모든일을 해냈다.&lt;/p&gt;

&lt;h2 id=&quot;어떻게&quot;&gt;어떻게?&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;버킷에 접속한다. (AWS 관리페이지를 통해서)&lt;/li&gt;
  &lt;li&gt;내가 만든 버킷에 들어간다.&lt;/li&gt;
  &lt;li&gt;버킷의 속성을 클릭한다.&lt;/li&gt;
  &lt;li&gt;‘정적 웹 사이트 호스팅’을 클릭한다.&lt;/li&gt;
  &lt;li&gt;‘이 버킷을 사용하여 웹 사이트를 호스팅합니다’를 체크
    &lt;ul&gt;
      &lt;li&gt;인덱스 문서에는 index.html&lt;/li&gt;
      &lt;li&gt;오류 문서에는 error.html을 입력&lt;/li&gt;
      &lt;li&gt;(실제 파일이 존재하지 않아도 된다)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;저장&lt;/li&gt;
  &lt;li&gt;다시 ‘정적 웹 사이트 호스팅’을 클릭&lt;/li&gt;
  &lt;li&gt;상단에 엔드포인트를 복사&lt;/li&gt;
  &lt;li&gt;현재 가지고있는 도메인의 관리 서비스로 이동&lt;/li&gt;
  &lt;li&gt;CNAME으로 등록
    &lt;ul&gt;
      &lt;li&gt;예) test.domain.com이라는 이름으로 CNAME이 가르키는 주소를 아까 복사한 엔드포인트 ‘test.test.com.s3-website-us-east-1.amazonaws.com’와 같은 URL을 입력해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;5분 정도 기다리면 내가 새로 업로드하는 어떤 이미지도 test.domain.com/test.jpg로 접근이 가능하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;물론 요청을 리다이렉션해서 2개의 버킷을 생성후 하나는 오로지 리다이렉션 정보만 담게도 설정이 가능하다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;만약 기존에 사용중인 S3 버킷이 있다면.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그러나 제일 처음부터 한다면 위에 나와있는 대로 하는게 좋을것 같다.&lt;/p&gt;</content><author><name></name></author><category term="AWS" /><category term="S3" /><category term="DNS" /><summary type="html">왜? 버킷을 처음 생성해 그 도메인 그대로 사용하면 상당히 긴 도메인이 나온다. 내가 만들고 있는 프로젝트에 이미지를 공유하는게 주된 목적인데 EX)https://s3.amazonaws.com/test.tac.photos/DASNKFDSANf134ia9s90fd.jpeg 이렇게나 긴 도메인은 보기도 힘들고 복사해서도 길이가 너무 길어서 편하자고 사용한 내 웹사이트에서 오히려</summary></entry><entry><title type="html">Google의 WEBP는 이미지의 용량을 얼마나 줄여줄까?</title><link href="https://moonjong93.github.io/development/serverless/Google-webp-how-many-less" rel="alternate" type="text/html" title="Google의 WEBP는 이미지의 용량을 얼마나 줄여줄까?" /><published>2018-03-12T00:00:00+00:00</published><updated>2018-03-12T00:00:00+00:00</updated><id>https://moonjong93.github.io/development/serverless/Google-webp-how-many-less</id><content type="html" xml:base="https://moonjong93.github.io/development/serverless/Google-webp-how-many-less">&lt;h2 id=&quot;google-webp란&quot;&gt;Google WEBP란?&lt;/h2&gt;
&lt;p&gt;Google에서 독자적으로 만든 이미지 확장자를 뜻한다, 자세한 내용은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/WebP&quot;&gt;위키피디아&lt;/a&gt;에서 확인 가능하다.&lt;/p&gt;

&lt;p&gt;간단히 정리하자면 VP8 영상 코덱 기술을 활용해 이미지의 용량을 기존 .jepg에 비하여 약 10~80%까지 줄여주는 새로운 이미지 확장자를 말한다&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;그러나 2010년에 개발되어 벌써 8년이란 시간이 흘렀기에…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;용량을-신경써야하는-이유&quot;&gt;용량을 신경써야하는 이유&lt;/h2&gt;
&lt;p&gt;일반적인 블로그나, 웹서비스를 만든다면 물론 전혀 신경쓰지 않아도 될 부분일것 같다. 하지만 내가 지금 만들고 있는 서비스는 용량에 상당히 민감하기 때문에 나 역시 서버 비용을 부담해야하는 개인 개발자 입장에선 당연 용량을 신경 쓸 수밖에 없었다.&lt;/p&gt;

&lt;p&gt;이미지를 불러오거나 갤러리형식으로 만들 수 있으며 내가 올리고 싶은 이미지를 얼마든지 올릴 수 있는 그런 형식의 웹을 만들고 있는데,&lt;/p&gt;

&lt;p&gt;대략적인 예측으로는 썸네일의 다운로드 수가 만약 100이라면 실제로 클릭하는 이미지는 약 2~5개 내외가 될 것 같았다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그러나 .png확장자 기준 250*166의 이미지 용량이 약 115kb에 달했다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;어쩌면-적을-수-있는-용량&quot;&gt;어쩌면 적을 수 있는 용량&lt;/h2&gt;
&lt;p&gt;115kb라고 해봤자 그렇게 큰 용량은 아님에 분명하다 하지만 이런 세세한 부분을 고민해야 아낄 수 있다고 생각했고&lt;/p&gt;

&lt;p&gt;.jpeg이미지 확장자로 동일 이미지를 변경해보았다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;16kb약 1/7이 절약되었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;그러나-나는-이것도-만족하기-싫었다&quot;&gt;그러나 나는 이것도 만족하기 싫었다.&lt;/h2&gt;
&lt;p&gt;Node.js입문 이후 가장 오래 고민했던 것은&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;어떻게 하면 내 서버를 적게 쓰게 만들까?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;라는 고민이었다, 너무나도 싫었다 같은 데이터를 가져오기 위해 내 서버를 들락거리는 사용자를 보고만 있을 수 없었다..&lt;/p&gt;

&lt;p&gt;이게 내가 처음 웹에 입문해서 했던 고민이었다, 당시 내가 알고 있던 유일한 기술은 ‘쿠키’하나 였는데 (Local Storage를 몰랐다) 저장해야 할 텍스트가 약 3만자가 넘었다, 이를 저장하기 위해 gzip으로 압축하고 그것도 모자라서 쿠키 사이사이에 쪼개서 넣었던 기억이 난다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그만큼 내 서버를 조금만 쓰게 하고 싶었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그 고민은 아직도 마찬가지다&lt;/p&gt;

&lt;h2 id=&quot;물론-서버는-이제-비싸지만은-않다&quot;&gt;물론 서버는 이제 비싸지만은 않다.&lt;/h2&gt;
&lt;p&gt;서버는 점점 저렴해지고, 점점 빨라지며 편해지기 까지 하고 있다. 이런 고민은 어쩌면 별거 아닌 고민일 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 앞서 언급했던것과 마찬가지로 내가 진행하는 프로젝트에선 썸네일이 가장 중요하지만 사용자는 직접적으로 썸네일을 다운받을 일이 없이 없기에 WEBP를 사용 하기로 했다.&lt;/p&gt;

&lt;h2 id=&quot;그래서-webp는-동일-이미지-용량이-얼마나-줄었나&quot;&gt;그래서 WEBP는 동일 이미지 용량이 얼마나 줄었나?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/postsImg/webp-how-many-less/one.png&quot; alt=&quot;비교 이미지&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기존 .png 확장자 대비 약 1/12나 줄어든것을 확인 할 수 있었다. .jpeg 확장자 대비해서도 약 4kb가 줄어들며 확실히 효과적이었다.&lt;/p&gt;</content><author><name></name></author><category term="개발" /><category term="aws" /><category term="serverless" /><category term="image" /><summary type="html">Google WEBP란? Google에서 독자적으로 만든 이미지 확장자를 뜻한다, 자세한 내용은 위키피디아에서 확인 가능하다.</summary></entry><entry><title type="html">aws를 사용해 serverless 프로젝트를 구성하며 느낀점</title><link href="https://moonjong93.github.io/development/serverless/serverless-with-amazon-make-some-problem" rel="alternate" type="text/html" title="aws를 사용해 serverless 프로젝트를 구성하며 느낀점" /><published>2018-03-01T00:00:00+00:00</published><updated>2018-03-01T00:00:00+00:00</updated><id>https://moonjong93.github.io/development/serverless/serverless-with-amazon-make-some-problem</id><content type="html" xml:base="https://moonjong93.github.io/development/serverless/serverless-with-amazon-make-some-problem">&lt;h2 id=&quot;serverless&quot;&gt;Serverless?&lt;/h2&gt;
&lt;p&gt;서버리스란 말 그대로 서버가없는 서비스를 구성하는 프로젝트를 말한다 나는 현재 lambda를 사용해 개발을 하고 있으며 서버리스 프레임워크 serverless http를 이용해 개발을 하고 있다.&lt;/p&gt;

&lt;h2 id=&quot;맞닦드린-문제들&quot;&gt;맞닦드린 문제들&lt;/h2&gt;
&lt;p&gt;이번은 es6(es2015)를 사용해 개발을 하고있다 특히 프론트도 vue로 하다보니 es6에 익숙해지는게 필요했다. babel을 사용해 dev프로젝트로 서비스를 가동하면 아무런 문제도 없던게 serverless-http사용해 aws lambda에 업로드하면 {forbidden:none} 에러를 뿜기 시작햇다.&lt;/p&gt;

&lt;p&gt;문제를 찾기위해 열심히 뒤졌지만 생각보다 관련 정보는 나오지 않았는데, 정말 사소한 이유였다 aws lambda는 es6문법에서 async await를 적용하지 않는다는 점이다,&lt;/p&gt;

&lt;p&gt;그렇다 모든 코드를 바꿔야했다.&lt;/p&gt;

&lt;p&gt;그 밖에도 mongodb의 연결이 안되어서 문제가 생긴경우도 있는데 이는 config파일을 제대로 읽지 못해 발생했다.&lt;/p&gt;

&lt;p&gt;exports.~~~라는 문법을 사용해서 해당 문제가 발생했다.&lt;/p&gt;

&lt;p&gt;나름 엄격한 체제를 가지고 있기 때문에 기존에 가동되던 코드도 lambda에 업로드를 하면 안되는 경우가 너무 많았다. 아무튼 지금은 어느정도 중심을 잡은것 같다&lt;/p&gt;

&lt;h2 id=&quot;route53을-설정하기&quot;&gt;Route53을 설정하기.&lt;/h2&gt;
&lt;p&gt;쉽지 않은 일이었다. 그냥 배포된 주소로 접근하면 정말 잘 되던게 꼭 api.pikiidea.com이라고 쓰면 forbidden… 구글링 결과 api의 키를 줘야한다 뭘 해야한다 이걸 해야한다…..~~ 그러나 나의 실수는 serverless-http의 공식문서를 제대로 안 읽어서 생긴 문제였다.
&lt;a href=&quot;https://serverless.com/blog/serverless-api-gateway-domain/&quot;&gt;serverless-http에서 도메인을 설정하기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;여기서 잘 읽어보면 us-east-01에서만 작동한다고 잠깐 언급이 되는데 이 부분을 제대로 읽지않아 하루를 왜 안돼지? 왜???? 도쿄리전 때문이라는 것을 알기 까지 생각보다 긴~시간을 보냈다.&lt;/p&gt;

&lt;h2 id=&quot;그럼에도-serverless&quot;&gt;그럼에도 serverless&lt;/h2&gt;
&lt;p&gt;서버리스를 처음 접한건 firebase functions를 사용하면서 였다, 당시에 간단한 정보를 크롤링해서 가져오는게 필요했는데 서버를 구성하기에는 귀찮고, 귀찮은것 만이 아니라 관리도 해야하기에 정말로 하기가 싫었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;그래서 발견하게 된것은 firebase functions&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;몇줄의 코드만으로 내가 원하는 기능을 추가할 수 있었다. 가령 이미지의 리사이즈나 업로드까지도 간편하게 추가가 가능했다.&lt;/p&gt;

&lt;p&gt;그 이후부터는 서버리스가 메인인 프로젝트를 해보고 싶었다.&lt;/p&gt;

&lt;h2 id=&quot;serverless의-유지보수는-간단하다&quot;&gt;serverless의 유지보수는 간단하다&lt;/h2&gt;
&lt;p&gt;예전에 vultr를 사용해서 서버를 가동할땐 간혹 오류가 생기면 서버가 뻣어버리는 경우가 잦았다. 나같은 개인 개발자는 서버까지 신경쓰며 거기다가 디자인까지 해야하는 경우인데 이런 경우가 생기면 그냥 프로젝트를 접고 싶은 마음이 점점 커져가고 포기한 프로젝트도 많아졌다.&lt;/p&gt;

&lt;p&gt;아마도 그래서 서버리스를 배워보고 싶었던 생각이 강했던것 같다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;
&lt;p&gt;aws 에서 serverless-http를 사용해서 구성하시려면 그냥 리전을 es-east-01에서 하세요.&lt;/p&gt;</content><author><name></name></author><category term="개발" /><category term="aws" /><category term="serverless" /><summary type="html">Serverless? 서버리스란 말 그대로 서버가없는 서비스를 구성하는 프로젝트를 말한다 나는 현재 lambda를 사용해 개발을 하고 있으며 서버리스 프레임워크 serverless http를 이용해 개발을 하고 있다.</summary></entry></feed>