<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>꿈 많은 개발자가 되자 - Taehwan</title>
        <description>I’m an Android Developer.</description>
        <link>http://thdev.tech/</link>
        <atom:link href="http://thdev.tech/feed.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Fri, 10 May 2019 06:44:32 +0000</pubDate>
        <lastBuildDate>Fri, 10 May 2019 06:44:32 +0000</lastBuildDate>
        <generator>Jekyll v3.8.5</generator>
        
            <item>
                <title>2019 Google IO - Architecture Components 정리</title>
                <description>&lt;p&gt;2019년 Google IO 중 Architecture Components 세션에서 소개한 내용을 몇 가지 정리한다.&lt;/p&gt;

&lt;p&gt;세션 내용은 아래에서 감상할 수 있다.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/Qxj2eBmXLHg&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Jetpack Architecture Components&lt;/h2&gt;

&lt;p&gt;Architecture Components는 이미 너무 많이 사용하고 있다고 하는데, 아래와 같이 수치를 공개해주었다.&lt;/p&gt;

&lt;p&gt;생각보다 많은 개발자가 Architecture Components를 사용하는데 서베이 기준 70%를 사용하고 있다고 한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_01.png&quot; alt=&quot;image_01&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_01&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;Architecture Components는 아래와 같은 과정을 거쳐 Alpha &amp;gt; Beta &amp;gt; Stable의 과정을 거쳤다고 한다.&lt;/p&gt;

&lt;p&gt;이런 내용은 처음 공개하는 내용인데 많은 커뮤니티들을 통해 피드백을 받고 업데이트했다고 한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_02.png&quot; alt=&quot;image_02&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_02&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;Kotlin First를 한 번 더 언급하였고, 이제는 KTX로만 코틀린 관련 라이브러리를 배포하지 않고, API 디자인도 코틀린을 사용한다고 한다.&lt;/p&gt;

&lt;p&gt;결국 이 말은 Java만을 사용하는 안드로이드 개발에서도 기본 Kotlin을 추가해야 사용 가능해진다는 이야기다.&lt;/p&gt;

&lt;p&gt;Kotlin은 이제 기본으로 적용해야, 앞으로 나올 Jetpack Architecture 라이브러리 활용이 가능해진다는 말이다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_03.png&quot; alt=&quot;image_03&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_03&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Data Binding&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/topic/libraries/data-binding&quot;&gt;Data Binding&lt;/a&gt;은 XML에서 Code를 바로 바인딩 할 수 있는 라이브러리이고, 아래와 같이 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;layout&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:android=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;xmlns:app=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res-auto&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;data&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;variable&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;viewModel&quot;&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.myapp.data.ViewModel&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/data&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;ConstraintLayout...&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;TextView&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;android:layout_width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;android:layout_height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;android:text=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@{viewModel.firstName}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;ConstraintLayout&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/layout&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Android Studio 3.5 베타 기준으로 아래와 같은 성능 향상이 일어났고, Incremental annotation processing을 위한 옵션이 추가되었다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_04.png&quot; alt=&quot;image_04&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_04&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;Android Studio 3.5부터 달라지는 부분&lt;/h3&gt;

&lt;p&gt;Live Class Generation이 가능해졌다. 항상 리빌드를 하던 이전과는 달리 3.5부터는 실시간으로 처리가 가능하다.&lt;/p&gt;

&lt;p&gt;아래 그림은 영상에서 확인하면 좋겠지만 xml의 TextView에 id를 추가하고, 이를 리빌드 없이 즉시 code에서 확인이 가능하다.&lt;/p&gt;

&lt;p&gt;rebuild로 인해 생기는 대기시간을 최소화할 수 있게 되었다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_05.png&quot; alt=&quot;image_05&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_05&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;Refactoring도 지원하는데, Code에서 변수 이름을 Rename을 통해서 변경하면 이 역시 즉시 반영한다.&lt;/p&gt;

&lt;p&gt;드디어… 해줬다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_06.png&quot; alt=&quot;image_06&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_06&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;또 하나 Data Binding 컴파일 오류를 확인할 수 있게 되었다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_07.png&quot; alt=&quot;image_07&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_07&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;이제서야 Data Binding을 진짜 잘 사용할 수 있게 되었다. 3.4까지 제공하던 Data Binding은 그나마 쓸 수 있을 정도였다면 3.5 버전부터는 잘 사용할 수 있게 되었다. 이제 좀 잘 사용해보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;Data Binding이 아닌 새로운 View Binding&lt;/h3&gt;

&lt;p&gt;이번 발표에서는 Data Binding이 아닌 View Binding도 소개했다.&lt;/p&gt;

&lt;p&gt;아름다운 코드 적용, 컴파일 타임 안전성을 확보하고, 빌드 속도까지 좋다고 한다. 하지만 당장 사용할 순 없다. Android Studio 3.6 버전부터 제공할 예정이다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_08.png&quot; alt=&quot;image_08&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_08&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;안전한 이유는 object로 이들을 관리함으로써 기존에 type이 맞지 않던걸 해결했다고 한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_09.png&quot; alt=&quot;image_09&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_09&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;Java에서도 지원하며, Gradle 플러그인을 통해 Binding 클래스가 만들어지고, 100% 컴파일 타임에 안전하며, Studio와 통합되어 있다. 그리고 데이터 바인딩과도 호환 가능하다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_10.png&quot; alt=&quot;image_10&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_10&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;ViewModel&lt;/h2&gt;

&lt;p&gt;ViewModel과 관련한 새로운 소식은 &lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate&quot;&gt;SavedState&lt;/a&gt;를 추가 지원한다는 것이다.&lt;/p&gt;

&lt;p&gt;ViewModel SavedState는 SavedStateHandler를 통해 제공하는데, 기존 ViewModel에 아래와 같이 추가하여 사용할 수 있다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_11.png&quot; alt=&quot;image_11&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_11&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;초기화 코드는 문서에 나와있는데, 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;vm&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ViewModelProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SavedStateVMFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SavedStateViewModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;SavedStateHandler를 사용해서 아래와 같이 read/write를 할 수 있는데,&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_12.png&quot; alt=&quot;image_12&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_12&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;handler의 LiveData를 활용해서도 이를 사용하는 게 가능하다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_13.png&quot; alt=&quot;image_13&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_13&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;하지만 SavedStateHandler를 사용하더라도 큰 기대는 하지 말길…&lt;/p&gt;

&lt;p&gt;Parcelable data를 적용해야 하고, data size는 기존과 동일하게 적용되어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;ViewModel 초기화 코드가 줄었다.&lt;/h3&gt;

&lt;p&gt;ViewModel 초기화 코드가 줄어들었다. koin을 사용하는 사람은 쉽게 이해가 가능하고, &lt;a href=&quot;https://github.com/taehwandev/LifecycleExtensions&quot;&gt;필자도 이런 비슷한 걸&lt;/a&gt; 만들어 쓰긴 했다.&lt;/p&gt;

&lt;p&gt;아래와 같이 ViewModel을 초기화했었으나,&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ViewModelProviders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MyViewModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제는 by를 사용하여 초기화 가능해졌다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;myViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MyViewModel&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;viewModels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;WorkManager&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/workmanager&quot;&gt;WorkManager&lt;/a&gt;의 활용 방법이 변경되었다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/googlesamples/android-architecture-components/tree/master/WorkManagerSample&quot;&gt;WorkManager Sample&lt;/a&gt;을 통해 바로 확인 가능하다.&lt;/p&gt;

&lt;p&gt;Application을 상속받아 구현하는 구현체에서 Configuration.Provider을 상속받아 아래와 같이 초기화한다. 이때 build() 사이에는 필요한 옵션들을 정의할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Provider&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getWorkManagerConfiguration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setMinimumLoggingLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VERBOSE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 WorkManager 활용 시 context를 넘겨서 처리할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;WorkManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 샘플은 WorkManager Sample에서 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;Worker unit test&lt;/h3&gt;

&lt;p&gt;Worker에 대한 unit test가 alpha에서 가능해진다.&lt;/p&gt;

&lt;p&gt;크게 TestWorkerBuilder와 TestListenableWorkerBuilder이다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_14.png&quot; alt=&quot;image_14&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_14&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;기본적인 work 테스트는 아래와 같은데 doWork()의 결과를 확인할 수 있다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_15.png&quot; alt=&quot;image_15&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_15&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;이번엔 listenable worker에 대한 테스트도 아래와 같다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_16.png&quot; alt=&quot;image_16&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_16&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;추가로 &lt;a href=&quot;https://github.com/googlesamples/android-architecture-components/blob/master/WorkManagerSample/app/src/androidTest/java/com/example/background/ImageOperationsTest.kt&quot;&gt;Sample에 있는 ImageOperationsTest.kt&lt;/a&gt;에 observe 형태의 테스트를 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;마지막으로 Foreground service를 지원하는데 notification 아이콘을 노출하는 조건이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Room&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/room&quot;&gt;Room&lt;/a&gt;에서 달라진 정보를 소개한다.&lt;/p&gt;

&lt;p&gt;Room 2.0에서는 아래와 같이 query를 작성하였으나,&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Architecture-Components/image_17.png&quot; alt=&quot;image_17&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_17&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;Room 2.1부터는 별도의 쿼리 대신 data class를 직접 사용할 수 있다고 한다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;@Dao&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SongDao&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;@Query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
    SELECT *
    FROM Song
    WHERE Song MATCH :query
  &quot;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;searchSongs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Song&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;Database views&lt;/h3&gt;

&lt;p&gt;Room 2.1부터 &lt;a href=&quot;https://developer.android.com/training/data-storage/room/creating-views&quot;&gt;Database views&lt;/a&gt;를 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;@DatabaseView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SELECT user.id, user.name, user.departmentId,&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;department.name AS departmentName FROM user &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;INNER JOIN department ON user.departmentId = department.id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;data class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UserDetail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?,&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;departmentId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;departmentName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이를 사용할 때는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;@Database&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entities&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arrayOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;views&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arrayOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UserDetail&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppDatabase&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RoomDatabase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;userDao&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UserDao&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;마무리&lt;/h2&gt;

&lt;p&gt;2일차에 나온 Google IO 중 Architecture Components에서 Data Binding, ViewModel, WorkManager, Room에 대해서 정리하였다. 나머지는 영상을 통해 확인 가능하다.&lt;/p&gt;
</description>
                <pubDate>Fri, 10 May 2019 00:00:00 +0000</pubDate>
                <link>http://thdev.tech/google%20io/2019/05/10/Google-IO-2019-Architecture-Components/</link>
                <guid isPermaLink="true">http://thdev.tech/google%20io/2019/05/10/Google-IO-2019-Architecture-Components/</guid>
                
                <category>Android</category>
                
                <category>Google IO</category>
                
                
                <category>Google IO</category>
                
            </item>
        
            <item>
                <title>2019 Google IO - Developer Keynote 몇 가지 정리</title>
                <description>&lt;p&gt;2019년 Google IO의 개발자 키노트 소개 중 안드로이드 관련을 정리한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://thdev.net/746&quot;&gt;2017년 Google IO 후기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://thdev.tech/google%20io/2018/05/08/Google-IO-2018-Chapter-1/&quot;&gt;2018년 Google IO Developer Kyenote 일부 정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;p&gt;자세한 내용은 What’s New Android 세션에서 자세하게 다루겠지만 주요 내용을 &lt;a href=&quot;https://events.google.com/io/schedule/events/speakers/393bf114-7e4b-4224-8b3f-c1afab0d2dfd&quot;&gt;Chet Haase&lt;/a&gt;가 짧게 정리해주었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Youtube 영상으로 확인&lt;/h2&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/zTZP7dd9-3g&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Kotlin 관련&lt;/h2&gt;

&lt;p&gt;안드로이드에서 코틀린은 이제 기본이라고 생각할 수 있다. 실제 수치로 알 수 있는데 50%의 안드로이드 개발자가 코틀린을 활용하고 있고, 가장 빠르게 성장하는 언어 중 하나라고 한다. 그만큼 코틀린으로 작성되고, 코틀린으로 만들어지는 라이브러리와 예제들이 쏫아져 나오고 있음을 알 수 있다. 완전하게 코틀린 만 사용해 안드로이드 개발을 해야 하는 건 아니지만 상당한 수치다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_01.png&quot; alt=&quot;image_01&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_01&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;안드로이드에서는 코틀린에 대한 관심도가 높다. 그에 따라 올해는 코틀린 관련 행사를 진행할 예정인데, GDG 커뮤니티와 코틀린 커뮤니티가 함께 하는 행사가 있을 예정이다.&lt;/p&gt;

&lt;p&gt;필자가 운영하는 GDG Seoul에서도 이에 대한 행사를 할 예정이니, 추후 &lt;a href=&quot;https://www.meetup.com/ko-KR/GDG-Seoul/&quot;&gt;GDG Seoul Meetup&lt;/a&gt; 또는 &lt;a href=&quot;https://www.facebook.com/groups/gdgseoul/&quot;&gt;Facebook 그룹&lt;/a&gt;에서 확인해보길 바란다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_02.png&quot; alt=&quot;image_02&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_02&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Android Jetpack&lt;/h2&gt;

&lt;p&gt;안드로이드 젯팩은 이제 안드로이드 프레임워크나 마찬가지다. 몇 가지는 네이밍의 문제가 있는 것도 있지만, 기본적으로 &lt;a href=&quot;https://developer.android.com/jetpack&quot;&gt;Jetpack&lt;/a&gt;은 필수이다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_03.png&quot; alt=&quot;image_03&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_03&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;Jetpack에는 아래와 같은 것들이 포함되어있다. 올해도 몇 가지 더 추가해주었고, 오픈소스로 공개도 해주었다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_04.png&quot; alt=&quot;image_04&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_04&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;그중 하나가 Behavior의 CameraX이다. CameraX에 대해서는 What’s New Android 세션 또는 Introduction to the CameraX Jetpack Library에서 확인이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Android Jetpack - ViewModel&lt;/h2&gt;

&lt;p&gt;AAC ViewModel은 문제가 많은 녀석이다. 일반적인 MVVM의 ViewModel이 아닌 안드로이드 로테이션과 관련한 ViewModel을 제공한다.&lt;/p&gt;

&lt;p&gt;필자도 몇 번이나 정리하고, 공유했던 내용인데, &lt;a href=&quot;https://thdev.tech/androiddev/2018/08/05/Android-Architecture-Components-ViewModel-Inject/&quot;&gt;Android Architecture Components ViewModel을 간단하게 초기화 하려면?&lt;/a&gt;을 정리한적이 있다.&lt;/p&gt;

&lt;p&gt;영상으로도 한 번 더 정리한 적이 있으니 참고하길 바란다.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/3QrEa35-pu8&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;이번엔 SavedState도 제공을 해주는 듯한데, 자세한 내용은 아래 문서에서 바로 확인 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate&quot;&gt;Saved State module for ViewModel&lt;/a&gt;&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_05.png&quot; alt=&quot;image_05&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_05&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;주요 코드는 아래와 같은데 SavedStateVMFactory가 추가되었음을 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;vm&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ViewModelProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SavedStateVMFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SavedStateViewModel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 SavedStateViewModel는 아래와 같이 구현되어있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SavedStateViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SavedStateHandle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ViewModel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Jetpack Compose&lt;/h2&gt;

&lt;p&gt;Jetpack에 compose가 추가되었다. &lt;a href=&quot;https://developer.android.com/jetpack/compose&quot;&gt;Jetpack compose&lt;/a&gt;는 UI를 코드로 쉽게 그릴 수 있는 도구이다. 코틀린에서는 anko가 있었으나, 이번에 구글에서 직접 만들어준 코틀린 만을 위한 UI 프레임웍크이고, AOSP에 포함하고 있다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_14.png&quot; alt=&quot;image_14&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_14&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;사용하는 예는 안드로이드 What’s New Android에서 소개했다고 하는데 아래와 같은 코드로 만들 수 있다.&lt;/p&gt;

&lt;p&gt;Kotlin 라이브러리이기에 굳이 Java에서 써야 할 이유는 없다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;androidx.compose.*&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;androidx.ui.core.*&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;@Composable&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Greeting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;Text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello $name!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Jetpack CameraX&lt;/h2&gt;

&lt;p&gt;Android에는 2개의 Camera를 사용할 수 있는 API가 있다. 안드로이드 4.4(API level 19)까지 사용 가능한 &lt;a href=&quot;https://developer.android.com/guide/topics/media/camera&quot;&gt;Camera&lt;/a&gt;와 Android 5.0(API level 21) 이상부터 사용할 수 있는 &lt;a href=&quot;https://developer.android.com/reference/android/hardware/camera2/package-summary.html&quot;&gt;Camera2&lt;/a&gt;가 있다. 현재까지 개발자는 5.0 이전에서는 Camera를 사용하고, 5.0 이상에서는 Camera2를 사용해야 했다.&lt;/p&gt;

&lt;p&gt;Camera2를 Jetpack을 통해 좀 더 간결하게 사용할 수 있도록 CameraX를 배포한다고 한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_11.png&quot; alt=&quot;image_11&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_11&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;CameraX에는 아래와 같은 기능을 제공하고있고,&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_12.png&quot; alt=&quot;image_12&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_12&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;CameraX를 사용하기 위해서는 Android 5.0(API level 21) 이상에서 사용할 수 있고, Architecture Components 1.1.1 이상을 함께 사용해야 한다. 사용하기 편하게 만들어주기 위해 Architecture Components를 포함한 것으로 보이는데 샘플로 제공하는 코드로 바로 확인해볼 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;previewConfig&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PreviewConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Builder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;preview&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Preview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;previewConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;textureView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TextureView&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;findViewById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textureView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// The output data-handling is configured in a listener.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;preview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setOnPreviewOutputUpdateListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;previewOutput&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;textureView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;surfaceTexture&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;previewOutput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;surfaceTexture&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// The use case is bound to an Android Lifecycle with the following code.
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CameraX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bindToLifecycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LifecycleOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;preview&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 방법 외에도 CameraX를 사용할 수 있는 방법은 Custom LifecycleOwners을 사용하는 방법과 Combine use cases을 사용하는 방법을 문서에서 알려주고 있으니 참고하길 바란다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/camerax/architecture&quot;&gt;CameraX architecture 문서&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Android App Bundle&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/platform/technology/app-bundle&quot;&gt;App Bundle&lt;/a&gt; 적용으로 APK 사이즈를 줄일 수 있었고, 실제 아래 사진과 같은 수치를 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;매년 소개하고, 문서도 나오고 하지만 아직은 많은 앱들이 적용하고 있지는 않아 보인다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_13.png&quot; alt=&quot;image_13&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_13&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Android Studio 3.5 베타 공개&lt;/h2&gt;

&lt;p&gt;Android Studio는 빠르게 업데이트 중이다. 3.5 베타이고, 다음 버전은 아직 없다고한다.&lt;/p&gt;

&lt;p&gt;Preview, Beta, 정식의 업데이트 속도가 빠르다. 이번 3.5에서는 아래와 같은 부분을 패치했다고 한다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://androidstudio.googleblog.com/2019/05/android-studio-35-beta-1-available.html?fbclid=IwAR0diJOLBlHJFlS9v5g1bhrp4m-e2CruLiQ2j-DxMrhdT-RGxPCShy5-RvY&quot;&gt;Android Studio 3.5 Beta 1 available&lt;/a&gt;&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_06.png&quot; alt=&quot;image_06&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_06&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;In-app update&lt;/h2&gt;

&lt;p&gt;사용자와 개발자 모두에게 행복할 소식일 수 있는데, 바로 &lt;a href=&quot;https://developer.android.com/guide/app-bundle/in-app-updates&quot;&gt;In-app update&lt;/a&gt;이다. 플레이스토어로 이동하지 않고, 앱 내에서 강제로 앱을 업데이트하거나, 권고할 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;참고로 시연중에 나왔던 코드와 실제 적용해야할 코드가 달라서 코드는 참고만 하길 바라며, &lt;a href=&quot;https://developer.android.com/guide/app-bundle/in-app-updates&quot;&gt;In-app updates&lt;/a&gt; 문서를 참고하세요.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_07.png&quot; alt=&quot;image_07&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_07&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;간단하게 샘플 코드와 함께 소개했는데 강제 업데이트 관련 코드 적용 시 오른쪽의 화면처럼 강제 업데이트를 할 수 있게 되었다. 당연히 권장 업데이트도 가능하다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_08.png&quot; alt=&quot;image_08&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_08&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;그리고 강제가 아닌 권장은 아래 그림과 같이 람다 표현식을 추가로 붙여주어야 한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_09.png&quot; alt=&quot;image_09&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_09&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;적용하는 방법도 간단한데 권장은 하나 더 해야 한다. 백그라운드에서 업데이트 준비를 완료하고, 이에 대한 콜백을 받을 수 있도록 노티를 처리해주어야 한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/05/Google-IO-2019-Developer-Keynote/image_10.png&quot; alt=&quot;image_10&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;image_10&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;마무리&lt;/h2&gt;

&lt;p&gt;Google developer keynote에서 안드로이드 관련 내용 몇 가지를 정리해보았다. 전체 내용도 아니라서 아래 영상을 확인하길 권한다. 일부 오류 있을 수 있는 건 댓글로 수정요청 부탁드려요.&lt;/p&gt;
</description>
                <pubDate>Wed, 08 May 2019 00:00:00 +0000</pubDate>
                <link>http://thdev.tech/google%20io/2019/05/08/Google-IO-2019-Developer-Keynote/</link>
                <guid isPermaLink="true">http://thdev.tech/google%20io/2019/05/08/Google-IO-2019-Developer-Keynote/</guid>
                
                <category>Android</category>
                
                <category>Google IO</category>
                
                
                <category>Google IO</category>
                
            </item>
        
            <item>
                <title>Kotlin Coroutines Exception 영향도 알아보기</title>
                <description>&lt;p&gt;이전 글에서 Kotlin coroutines을 제어할 수 있는 Job에 대해 알아보았다. 기본적인 Job 초기화 후 사용한데 어떤 방법이 좋을까?&lt;/p&gt;

&lt;p&gt;먼저 &lt;a href=&quot;https://thdev.tech/coroutines/2019/04/08/Init-Coroutines-Job/&quot;&gt;이전 글&lt;/a&gt;에서 초기화 때 적용했던 방법을 다시 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 CoroutineScope 초기화 시 Job을 함께 초기화하여 사용한다.(+를 이용하여 초기화한다.) 이렇게 초기화 함에 따라 CoroutineScope 사용 시 하위 child 모두 이 job의 영향을 받게 설계하였다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Exception 발생의 경우에 대해서 살펴보자&lt;/h2&gt;

&lt;p&gt;코루틴에서도 Exception이 발생하지 않으리라는 보장은 없으며, child coroutines 영향이 부모에게도 미칠 경우에 대해서 대비해야 한다.&lt;/p&gt;

&lt;p&gt;하나씩 살펴보면서 해결 방법을 정리해보려고 한다. 먼저 다음과 같은 조건을 임의로 만들어보았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2 개의 child coroutines을 만든다.&lt;/li&gt;
  &lt;li&gt;1 개의 child에서는 Exception을 임의로 발생시킨다.&lt;/li&gt;
  &lt;li&gt;2 번째 child에서는 delay를 걸어 로그를 출력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;주요 코드에서는 Job을 별도로 초기화하였고, 이 Job을 이용해서 CoroutineScope을 초기화하였다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UICoroutineScopeTest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;coroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runBlocking&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Parent job&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;childJob&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;First child is failing&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;First child is exception&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;secondJob&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Second child is success&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Second child is delay 500ms&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;childJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;secondJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3&gt;참고로&lt;/h3&gt;

&lt;p&gt;runBlocking은 GlobalScope을 이용하여 초기화하는데 필요한 Context만 변경하고 초기화하도록 내부에 구현되어있다.&lt;/p&gt;

&lt;p&gt;runBlocking 안에서 또 다른 CoroutineScope을 사용해야 하여 with으로 초기화 후 사용하였고, join으로 대기하여 내부의 CoroutineScope을 종료하고, runBlocking을 종료한다.&lt;/p&gt;

&lt;p&gt;이 경우 coroutineContext는 runBlocking과 CoroutineScope의 coroutineContext 2 개가 존재하기에 this 스쿱을 잘 활용하여 사용해야 한다.&lt;/p&gt;

&lt;p&gt;테스트 코드에서는 약간의 트릭이 필요한데 결국 delay 또는 join을 잘 활용해야 명확한 테스트가 가능해진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;당연한 이야기지만 오류가 난다. 어떻게 동작할까?&lt;/h2&gt;

&lt;p&gt;아쉽게도 본 코드는 child 2 개가 모두 동작하지 않고 종료한다.&lt;/p&gt;

&lt;p&gt;childJob은 동작 중에 exception이 발생하며, secondJob은 앞서 발생한 exception로 인해 아무것도 하지 않고 즉시 종료한다.&lt;/p&gt;

&lt;p&gt;로그상으로 아래와 같이 확인해볼 수 있는데, childJob만이 동작함을 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Parent job
First child is failing

java.lang.Exception: First child is exception

	at tech.thdev.coroutines.scope.UICoroutineScopeTest$testException$1$1$childJob$1.invokeSuspend(UICoroutineScopeTest.kt:22)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)
	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:233)
	at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.kt:116)
	at kotlinx.coroutines.BlockingCoroutine.joinBlocking(Builders.kt:76)
	at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking(Builders.kt:53)
	at kotlinx.coroutines.BuildersKt.runBlocking(Unknown Source)
	at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking$default(Builders.kt:35)
	at kotlinx.coroutines.BuildersKt.runBlocking$default(Unknown Source)
	at tech.thdev.coroutines.scope.UICoroutineScopeTest.testException(UICoroutineScopeTest.kt:17)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;이 경우 무슨 문제가 생길까?&lt;/h2&gt;

&lt;p&gt;이 경우 개발자가 유도한 건 당연히 CoroutineScope의 childJob이 모두 동작하기를 희망한다.&lt;/p&gt;

&lt;p&gt;예를 들어보면 3 개의 네트워크를 통해 데이터를 불러와서 합쳐야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이 경우 join()을 이용해서 3 개의 데이터를 모두 대기한다.&lt;/li&gt;
  &lt;li&gt;하지만 이 중 하나가 exception 발생으로 다른 데이터들도 불러오는 중에 멈추었다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예외 처리를 해야 하는데 위 예제에서 보았듯 예외 처리도 불가능한 사항이 만들어진다. try/catch로 예외 처리를 해주지 않으면 앱은 종료될 것이다.&lt;/p&gt;

&lt;p&gt;최소한 이를 잡아서 예외처리를 해야하는 데 매번 try/catch로 묶기엔 무리가 있어 좀 더 쉬운 방법을 찾아야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;그러면 해결 방법은 뭘까?&lt;/h2&gt;

&lt;p&gt;차근차근 해결 방법을 알아보도록 하자. 언제나 그렇듯 문서가 좋은데 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/&quot;&gt;Job 문서&lt;/a&gt;를 다시 보도록 하자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The most basic instances of Job are created with launch coroutine builder or with a Job() factory function. By default, a failure of any of the job’s children leads to an immediately failure of its parent and cancellation of the rest of its children. This behavior can be customized using SupervisorJob.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Job 문서에 나오는 문항이다. 몇 가지 키워드가 있는데 children의 종료에 따라 즉시 Parent와 다른 children들이 종료됨을 알 수 있는데, 다른 행동이 필요하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;SupervisorJob&lt;/code&gt;을 활용하라고 나와있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;SupervisorJob?&lt;/h2&gt;

&lt;p&gt;SupervisorJob이 기본적으로 사용하는 Job과 어떻게 다른지 문서를 통해 확인해보자.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-supervisor-job.html&quot;&gt;SupervisorJob&lt;/a&gt;에 작성되어 있는 첫 줄 그대로 가져왔다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Creates a new supervisor job object in an active state. Children of a supervisor job can fail independently of each other.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Children의 Job fail 정보를 독립적으로 관리한다고 한다. 기본적인 Job은 모든 Scope을 종료하지만 SupervisorJob은 필요한 곳에서만 종료함을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;왜 그럴까?&lt;/h2&gt;

&lt;p&gt;왜 그럴까를 알려면 결국 코드가 어떻게 다른지를 알면 되겠다. 그래서 좀 더 들여다보려고 한다.&lt;/p&gt;

&lt;p&gt;먼저 모든 Job은 interface로 정의되어 있는데 아래 그림과 같은 라이프 사이클을 가지고 있음을 &lt;a href=&quot;https://thdev.tech/coroutines/2019/04/08/Init-Coroutines-Job/&quot;&gt;이전 글&lt;/a&gt;에서 확인하였다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/04/Init-Coroutines-Job/coroutine-job.png&quot; alt=&quot;coroutine-job&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;coroutine-job&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;실제 interface는 아래와 같이 초기화되어있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;참고로 CoroutineScope 초기화 시에 CoroutineScope(Dispatchers.IO + job) 형태 사용이 가능한 이유는 CoroutineContext.Element 상속으로 인해 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Element&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 생략
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;isActive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;isCompleted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 생략
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 Job interface는 JobSupport라는 곳에서 상속받아 구현해두고 있다. 이 JobSupport가 Job을 편하게 사용하기 위해서 구현해둔 클래스인데 일반 개발자가 이를 확장하여 사용하지 못하도록 막아두었다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JobSupport&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;active&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ChildJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ParentJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SelectClause0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;// 생략
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;개발자가 커스텀 해서 이를 활용할 방법은 없고, coroutines 사용 규칙에 따라서만 사용 및 접근이 가능하다.&lt;/p&gt;

&lt;p&gt;이제 Job과 SupervisorJob 각각 초기화 코드 및 어떤 부분이 다른지 살펴보도록 하자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;Job 초기화 살펴보기&lt;/h3&gt;

&lt;p&gt;Job을 초기화할 때는 아래와 같은 function을 통해 초기화를 하고, 이를 활용할 수 있다. 필요할 경우 ParentJob을 함께 초기화하여 사용하는 것도 가능하다.&lt;/p&gt;

&lt;p&gt;이 코드에서 확인할 수 있는 건 JobImpl()이라는것을 통해 초기화함을 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;@Suppress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FunctionName&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JobImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JobImpl이라는 건 JobSupport class를 상속받아 확장한 형태이다.&lt;/p&gt;

&lt;p&gt;cancelParent를 통해 어떠한 조건에 따라 Parent를 종료하도록 유도할 수 있으며, onCancelComplete 가능하도록 하고 있다.&lt;/p&gt;

&lt;p&gt;handlesException은 false로 처리하고 있음만 사실 알 수 있다.&lt;/p&gt;

&lt;p&gt;이 코드는 JobSupport의 동작 중에 필요한 flag 값을 이용하여 간단하게 초기화함을 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JobImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JobSupport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initParentJobInternal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;cancelsParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;onCancelComplete&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;handlesException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드만으로는 어떠한 차이가 있는지 사실 알지는 못한다. 결국 SupervisorJob 초기화 코드도 보아야 이해가 가능할 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;SupervisorJob 초기화 살펴보기&lt;/h3&gt;

&lt;p&gt;SupervisorJob 역시 Job처럼 function을 통한 초기화를 알 수 있고, 여기에서도 JobImpl과 동일한 SupervisorJobImpl이라는 걸 초기화함을 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;@Suppress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FunctionName&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SupervisorJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SupervisorJobImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;SupervisorJobImpl은 JobImpl과 동일하게 JobSupport를 상속받아 필요한 값만을 초기화함을 알 수 있는데, 딱 하나 다른 점을 발견할 수 있다.&lt;/p&gt;

&lt;p&gt;childCancelled() = false라는 걸 확인할 수 있고, 나머지는 모두 JobImpl과 동일하다.&lt;/p&gt;

&lt;p&gt;결국 childCancelled이라는 값이 상위 부모에게 영향을 미칠지 말지를 결정하는 중요한 요소임을 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SupervisorJobImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JobSupport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initParentJobInternal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;cancelsParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;onCancelComplete&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;handlesException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;childCancelled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;결국&lt;/h3&gt;

&lt;p&gt;JobSupport에서 Job 동작에 관한 모든 걸 구현해두고, 이를 상속받아 구현하는 실제 동작 Job 클래스들은 필요한 flag만을 조절하는 형태로 확장하고, 이 값들 하나하나에 따라 Job의 동작이 달라짐을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;childCancelled은 어떻게 동작하고 있을까?&lt;/h2&gt;

&lt;p&gt;이 true/false의 값이 어떠한 영향을 미치는지 알면 좋을 것 같으니 좀 더 살펴보면 좋지만, 코드의 양이 많고 이해가 어려워 필요한 코드만을 분리해보았다.&lt;/p&gt;

&lt;p&gt;필자가 알고 싶은 것은 childCancelled의 return 값이 어떠한 차이를 가지고 있는지만 알고 싶었을 뿐이기에 관련 코드를 사용하는 곳을 발견했는데, 이름만으로 유추해보았다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cancelParent&lt;/code&gt;에서 이 값을 사용하고 있다. 이 cancelParent는 &lt;code class=&quot;highlighter-rouge&quot;&gt;notifyHandlers&lt;/code&gt;라는 곳에서 불러주고 있었다.(필요한 코드만 가지고 왔다)&lt;/p&gt;

&lt;p&gt;결국 어떠한 notify를 해야 하는 곳 중 parent에게 알려줘야 하는 곳이 있으며, job은 childCancelled의 값에 따라 부모에게 알려줄지 말지를 결정하게 됨을 알 수 있었다.&lt;/p&gt;

&lt;p&gt;참고로 notifyHandlers를 부르고 있는 곳은 아래와 같이 3 곳을 확인할 수 있었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;private fun makeCancelling(cause: Any?): Boolean&lt;/li&gt;
  &lt;li&gt;private fun tryMakeCancelling(state: Incomplete, rootCause: Throwable): Boolean&lt;/li&gt;
  &lt;li&gt;private fun tryMakeCompleting(state: Any?, proposedUpdate: Any?, mode: Int): Int&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;대략 유추하면서 찾아본 코드들이며, 해당 코드 중 발견한 시점의 코드를 아래와 같이 나열해본다.(이 글을 작성할 시점의 단순 참고용이며, 추후 변경 가능성이 큰 코드로 기입되어있다.)&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;notifyCancelling&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NodeList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// first cancel our own children
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;onCancellation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;notifyHandlers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JobCancellingNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;*&amp;gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// then cancel parent
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cancelParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// tentative cancellation -- does not matter if there is no parent
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;cancelParent는 아래 3개의 조건에 따라서 return의 결과가 달라진다. 앞에 종료 사항과 CancellationException의 상황이 아닌 경우에만 마지막의 childCancelled의 정보를 가지고 처리함을 알 수 있다.&lt;/p&gt;

&lt;p&gt;그렇기에 필자가 찾은 코드가 꼭 이 코드를 탄다는 전제는 없고, 상황에 따라서 조금씩 다를 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cancelParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// CancellationException is considered &quot;normal&quot; and parent is not cancelled when child produces it.
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// This allow parent to cancel its children (normally) without being cancelled itself, unless
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// child crashes and produce some other exception during its completion.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CancellationException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancelsParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parentHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;childCancelled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;결과를 다시 한번 살펴보자.&lt;/h2&gt;

&lt;p&gt;SupervisorJob으로 교체하면 어떻게 변경되는지 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UICoroutineScopeTest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SupervisorJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;coroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runBlocking&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Parent job&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;childJob&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;First child is failing&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;First child is exception&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;secondJob&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Second child is success&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Second child is delay 500ms&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;childJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;secondJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에서는 Second children의 동작을 하지 않고, 전체 CoroutineScope이 종료되었지만 SupervisorJob으로 교체만 했을 뿐인데 전혀 다른 결과가 나왔음을 확인할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Parent job
First child is failing
Second child is success
Exception in thread &quot;DefaultDispatcher-worker-1 @coroutine#2&quot; java.lang.Exception: First child is exception
	at tech.thdev.coroutines.scope.UICoroutineScopeTest$testException$1$1$childJob$1.invokeSuspend(UICoroutineScopeTest.kt:22)
	at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:32)
	at kotlinx.coroutines.DispatchedTask.run(Dispatched.kt:233)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:594)
	at kotlinx.coroutines.scheduling.CoroutineScheduler.access$runSafely(CoroutineScheduler.kt:60)
	at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:742)
Second child is delay 500ms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;마무리&lt;/h2&gt;

&lt;p&gt;Job보다는 SupervisorJob 활용을 많이 하는 게 좋다는 결론이다. 별 이야기는 없지만 살짝 분석을 해보려고 나열하다 보니 긴 글이 되었다.&lt;/p&gt;

&lt;p&gt;다음에는 또 다른 해결 방법에 대해서 살펴보려고 한다. SupervisorJob을 별도로 초기화하지 않아도 사실 동일한 결과를 얻는 몇 개의 Scope이 있다. 이들을 살펴보도록 하겠다.&lt;/p&gt;
</description>
                <pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate>
                <link>http://thdev.tech/coroutines/2019/04/30/Coroutines-Job-Exception/</link>
                <guid isPermaLink="true">http://thdev.tech/coroutines/2019/04/30/Coroutines-Job-Exception/</guid>
                
                <category>Android</category>
                
                <category>kotlin</category>
                
                <category>coroutines</category>
                
                
                <category>coroutines</category>
                
            </item>
        
            <item>
                <title>Kotlin Coroutines의 Job 동작을 알아보자</title>
                <description>&lt;p&gt;Kotlin Coroutines을 컨트롤하기 위한 Job을 제공해준다. 이 Job은 N 개의 coroutines의 동작을 제어할 수도 있으며, 하나의 coroutines 동작을 제어할 수도 있다.&lt;/p&gt;

&lt;p&gt;먼저 Job이 어떤 것인지 알아보고, exception 발생 케이스를 함께 알아보겠다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Job&lt;/h2&gt;

&lt;p&gt;Coroutines의 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/&quot;&gt;Job&lt;/a&gt;은 결국 coroutines의 상태를 가지고 있는데, 아래와 같은 6가지 상태를 포함하고 있으며, active/completed/canceled 상태에 따라 값이 아래의 표와 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;State&lt;/th&gt;
      &lt;th&gt;isActive&lt;/th&gt;
      &lt;th&gt;isCompleted&lt;/th&gt;
      &lt;th&gt;isCancelled&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;New (optional initial state)&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Active (default initial state)&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Completing (transient state)&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Cancelling (transient state)&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Cancelled (final state)&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Completed (final state)&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
      &lt;td&gt;false&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이러한 Job을 바탕으로 코루틴의 상태를 확인할 수 있고, 제어할 수 있다. job.cancel()을 호출하게 되면 즉시 취소 상태로 Job을 한다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/04/Init-Coroutines-Job/coroutine-job.png&quot; alt=&quot;coroutine-job&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;coroutine-job&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;job으로 할 수 있는 것들&lt;/h2&gt;

&lt;p&gt;job을 통해 할 수 있는 것은 아래와 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;start : 현재의 coroutine의 동작 상태를 체크하며, 동작 중인 경우 true, 준비 또는 완료 상태이면 false를 return 한다.&lt;/li&gt;
  &lt;li&gt;join : 현재의 coroutine 동작이 끝날 때까지 대기한다. 다시 말하면 async {} await처럼 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;cancel : 현재 coroutine을 즉시 종료하도록 유도만 하고 대기하지 않는다. 다만 타이트하게 동작하는 단순 루프에서는 delay가 없다면 종료하지 못한다.&lt;/li&gt;
  &lt;li&gt;cancelAndJoin : 현재 coroutine에 종료하라는 신호를 보내고, 정상 종료할 때까지 대기한다.&lt;/li&gt;
  &lt;li&gt;cancelChildren : CoroutineScope 내에 작성한 children coroutine들을 종료한다. cancel과 다르게 하위 아이템들만 종료하며, 부모는 취소하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Job이 다름을 확인해보려고 만든 잘못된 예제&lt;/h2&gt;

&lt;p&gt;이 샘플은 좀 억지로 만들어본 샘플이다. 필자도 이리저리 테스트하면서 만든 샘플이라서 명확하지는 않음을 미리 알려드린다.&lt;/p&gt;

&lt;p&gt;우선 아래의 그림과 같이 생각하고 만들었다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/04/Init-Coroutines-Job/coroutine-job-new-scope.png&quot; alt=&quot;coroutine-job-new-scope&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;coroutine-job-new-scope&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;메인 CoroutineScope이 존재하고, 이는 job을 별도로 만들어 즉시 cancel 한다.(30ms를 준 이유는 로그를 확인하기 위함이다.) 그리고 이 scope 안에 이번엔 Job을 합치지 않은 새로운 CoroutineScope을 만든다.&lt;/p&gt;

&lt;p&gt;결국 정리하면&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Main CoroutineScope을 생성한다.&lt;/li&gt;
  &lt;li&gt;Main 안에 추가로 CoroutineScope을 추가한다.(아래 코드에서는 0..20까지 출력하는 코드이다.)&lt;/li&gt;
  &lt;li&gt;Main CoroutineScope 안에 기본으로 동작하는 jobTwo를 추가한다.(아래 코드에서는 0..1까지 출력하는 코드이다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;보기 전에 이렇게 사용하시면 안 됩니다!!!!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;@Test&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runBlocking&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Job one scope start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isActive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Job one scope index $index&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Job one scope for end&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;jobTwo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Job two scope for start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isActive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Job two scope index $index&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Job two scope for end&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;jobTwo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 30ms test only.
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이를 사용하면 좀비를 만들 수 있다. 당연히 내부의 CoroutineScope은 좀비 가능성이 높아졌다. 제어할 수 없어졌기에&lt;/p&gt;

&lt;p&gt;그럼 위 코드의 결과를 보도록 하자.&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Job one scope start
Job one scope index 0
Job two scope for start
Job two scope index 0
Job one scope index 1
Job two scope for end // Job two는 0하나만 출력하고 즉시 종료되었다.
Job one scope index 2
Job one scope index 3
Job one scope index 4
Job one scope index 5
// 생략
Job one scope index 17
Job one scope index 18
Job one scope index 19
Job one scope index 20
Job one scope for end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;job one은 좀비가 되어 30ms 동안 계속 돌아갔다.&lt;/p&gt;

&lt;p&gt;이 코드는 테스트 환경에서 동작하였기 때문에 원래대로라면 메인 잡이 종료되면 서브 잡도 함께 종료한다. 그래서 Job two가 종료되었음을 확인하기 위해서 delay를 별도로 준 연습 코드이다.&lt;/p&gt;

&lt;p&gt;하지만 android runTime에서는 위와 동일한 결과를 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Job을 잘 활용하려면?&lt;/h2&gt;

&lt;p&gt;위와 같은 결과물을 만들었을 때 당연히 좋은 방향의 코드가 아님은 분명하다. 그럼 어떻게 job을 활용해야 할까?&lt;/p&gt;

&lt;p&gt;job은 단순히 launch의 return으로만 사용할 수 있는 것은 아니다. 먼저 일반적인 job은 1개의 CoroutineScope.launch에 대한 결과로 아래와 같이 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// return job으로 컨트롤하기
&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 생략...
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같은 job은 언제나 1개만 컨트롤할 수 있다. 하지만 activity에서 사용하는 job이 1개 만 있는 것이 아니며, 그렇다고 액티비티 내에서 사용할 모든 job을 n 개로 다 들고 있어야 하느냐? 그것도 아니다.&lt;/p&gt;

&lt;p&gt;다행히도 하나의 Job을 생성하고, N 개의 launch, actor 등에 영향을 주어 한 번에 종료할 수 있는데 Job을 별도로 초기화한다.(이미 &lt;a href=&quot;https://thdev.tech/android/2019/04/05/Init-Coroutines/&quot;&gt;앞글&lt;/a&gt;에서 activity에서 편하게 쓰는 부분에 코드가 있다.)&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그러고 나서 생성하는 CoroutineScope에 job을 함께 초기화하면, 이 CoroutineScope의 child까지 모두 영향을 받는 job으로 활용이 가능한데 아래와 같이 초기화에 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 위와 같이 하지 않고, 원하는 launch 만 적용할 수도 있다. 이 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;GlobalScope&lt;/code&gt;에서 활용 가능한 형태이다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그래서 이 코드를 반영하여 아래와 같이 모든 CoroutineScope 초기화할 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;+ job&lt;/code&gt;을 함으로써 깔끔하게 원하는 대로 하위 job까지 컨트롤이 가능하다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그렇다 하더라도 job 별로 별도 컨트롤이 필요한 경우가 있을 것이다. 그러면 val job = CoroutineScope() 형태로 사용하는 게 맞다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;@Test&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;testJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runBlocking&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 여기에 job을 함께 초기화 한다.
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Job one scope start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isActive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Job one scope index $index&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Job one scope for end&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;jobTwo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Job two scope for start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isActive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Job two scope index $index&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Job two scope for end&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;jobTwo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이번에도 원하는 대로 잘 동작하는지 확인하기 위해서 delay 1ms 정도 줬다.&lt;/p&gt;

&lt;p&gt;결과는 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Job one scope start
Job one scope index 0
Job two scope for start
Job two scope index 0
Job two scope index 1 // Job two는 1까지 출력하고 종료되었다.
Job one scope index 1
Job one scope index 2
Job one scope index 3 // Job one는 3까지 출력하고 종료되었다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;마무리&lt;/h2&gt;

&lt;p&gt;Job을 알아보았다. 다음 글에서 Job의 exception에 대해서 알아보도록 하겠다.&lt;/p&gt;
</description>
                <pubDate>Mon, 08 Apr 2019 00:00:00 +0000</pubDate>
                <link>http://thdev.tech/coroutines/2019/04/08/Init-Coroutines-Job/</link>
                <guid isPermaLink="true">http://thdev.tech/coroutines/2019/04/08/Init-Coroutines-Job/</guid>
                
                <category>Android</category>
                
                <category>kotlin</category>
                
                <category>coroutines</category>
                
                
                <category>coroutines</category>
                
            </item>
        
            <item>
                <title>Android에서 사용하는 CoroutineScope을 알아보자</title>
                <description>&lt;p&gt;Kotlin coroutines은 기존 Java Thread, 안드로이드에서 제공하는 AsyncTask, ReactiveX 패러다임을 일부 구현한 RxJava를 대신할 수 있는 Asynchronous/Non-blocking programming을 제공한다.&lt;/p&gt;

&lt;p&gt;참고로 기존에 작성하였던 글에서 &lt;a href=&quot;https://thdev.tech/kotlin/2018/10/04/Kotlin-Coroutines/&quot;&gt;Kotlin Coroutines을 알아보고, 안드로이드에 library 적용하기&lt;/a&gt; Java Thread/AsyncTask/RxJava 활용에 대한 내용이 포함되어 있다.&lt;/p&gt;

&lt;p&gt;coroutines은 사용하기 쉽고, 적용하기도 쉽다.&lt;/p&gt;

&lt;p&gt;우선 안드로이드 환경에서 코틀린을 적용하는 방법은 간단하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines&quot;&gt;Github kotlinx.coroutines&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Github의 kotlinx.coroutines에서 Apache License, Version 2.0으로 공개되어 있는 coroutines 소스를 확인할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;p&gt;build.gradle 파일에 아래 coroutines-android를 적용함으로써 코루틴의 사용 준비는 끝이 난다.&lt;/p&gt;

&lt;div class=&quot;language-gradle highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;implementation&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.1.1'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;사이트에 나와있지만 당연히 Kotlin 개발 환경에서 위 dependencies 적용이 가능하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;Coroutine 접근하는 방법&lt;/h2&gt;

&lt;p&gt;필자가 작성한 앞선 글에서도 확인할 수 있지만, 코루틴은 두 가지 접근 방법을 통해 사용이 가능하다.&lt;/p&gt;

&lt;p&gt;코루틴을 활용하는 데 있어 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/&quot;&gt;CoroutineScope&lt;/a&gt;이 interface로 정의되어 있다. 이 interface 정의를 통해 매번 원하는 형태의 CoroutineContext를 정의할 수 있고, Coroutines의 생명 주기를 관리할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CoroutineScope.kt&lt;/code&gt; 파일 안에는 이러한 interface 정의되어 있으며, CoroutineScope을 상속 받아 CoroutineScope과 GlobalScope 등에서 이를 활용하고 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/**
     * Context of this scope.
     */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;coroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineContext&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;어플리케이션이 동작하는 동안 별도의 생명 주기를 관리하지 않고 사용할 수 있는 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/&quot;&gt;GlobalScope&lt;/a&gt;이 있다. 이는 안드로이드 앱이 처음 시작부터 종료 할때까지 하나의 CoroutineContext 안에서 동작하도록 할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 CoroutineScope과 GlobalScope을 각각 알아보도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;필요할 때 선언하고, 종료하자&lt;/h3&gt;

&lt;p&gt;필요할 때 선언하고, 종료하는 게 필요하다. 예를 들면 아래와 같을 수 있겠다.&lt;/p&gt;

&lt;p&gt;현 재 화면을 벗어나면 더 이상 통신을 할 필요가 없다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;리스트를 갱신하기 위한 최신 데이터를 불러온다.&lt;/li&gt;
  &lt;li&gt;리스트를 불러오는 중 서버 응답이 느려 답답해진 사용자는 창을 닫아버린다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 경우는 백그라운드에서 계속 다운로드할 필요가 없어진다.(캐싱을 하는 앱이라면 이후 처리가 필요하므로 별도의 작업을 하겠지만) 이 경우 굳이 GlobalScope을 활용하여 이 작업을 살려둘 필요가 없어진다.&lt;/p&gt;

&lt;p&gt;이 경우에 매번 새롭게 생성하는 CoroutineScope을 활용함으로써 효율을 높일 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 CoroutineScope의 내부 초기화 코드는 아래와 같은데, 이는 fun으로 시작해서 함수이다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;@Suppress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;FunctionName&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ContextScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그래서 내부에 정의되어 있는 클래스는 ContextScope이라는 클래스를 초기화해서 사용하고 있음을 알 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ContextScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;coroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineContext&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;결국 CoroutineScope은 CoroutineContext(Main(안드로이드에서는 UI thread)/IO thread)를 통해 원하는 형태로 초기화하는 하나의 Block을 만들어 사용함을 알 수 있다.&lt;/p&gt;

&lt;p&gt;이를 사용할때는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;앱이 동작하는 동안 사용해보자.&lt;/h3&gt;

&lt;p&gt;이번엔 앱이 동작하는 동안 사용할 수 있는 GlobalScope을 알아보자.&lt;/p&gt;

&lt;p&gt;당연히 앱을 사용하면서 장시간 동작해야 할 thread가 필요하다면 매번 생성하는 CoroutineScope보다는 최초 접근 시 만들어지는 GlobalScope이 효율적이다.&lt;/p&gt;

&lt;p&gt;이러한 GlobalScope을 사용하더라도, 안드로이드 환경에서는 백그라운드 잡이 또 필요하여 WorkManager을 활용해야 한다.&lt;/p&gt;

&lt;p&gt;GlobalScope + WorkManager 활용 예)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@prithvibhola08/location-all-the-time-with-workmanager-8f8b58ae4bbc&quot;&gt;Location all the time with WorkManager!!&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.kmshack.kr/work_manager/?fbclid=IwAR31SuDW0GPC8TtSE7EC0j9T9aiiYEVNEVrlPWEm0SCiFXj8sq31yjtZmLw&quot;&gt;한글 블로그 - WorkManager로 정기적인 백그라운드 작업 수행하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;다만, GlobalScope은 Job을 컨트롤하기에 접합하지 않음에 주의해야 하는데, 하나하나의 launch/actor 등에 CoroutineContext와 Job을 함께 사용하지 않으면 제어가 쉽지 않다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이러한 GlobalScope은 interface CoroutineScope을 상속받아 구현되어있는데, 기본 CoroutineContext를 EmptyCoroutineContext을 활용하고 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GlobalScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/**
     * Returns [EmptyCoroutineContext].
     */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;coroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineContext&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EmptyCoroutineContext&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;GlobalScope을 안드로이드의 테스트 코드에서 동작하면 아래와 같은 ThreadType을 확인할 수 있는데, 별도로 지정하지 않은 상태에서는 IO가 기본으로 동작한다.&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 GlobalScope의 좋은 예는 API 상으로 아래와 같이 소개하고 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ReceiveChannel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReceiveChannel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GlobalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;produce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unconfined&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Android 환경에서의 CoroutineScope 활용하기&lt;/h2&gt;

&lt;p&gt;Android 환경에서는 CoroutineScope을 활용하기 위해서 CoroutineScope을 상속받아고, 이를 &lt;a href=&quot;https://developer.android.com/guide/components/activities/activity-lifecycle&quot;&gt;Android Lifecycle&lt;/a&gt;에 맞게 사용하는 걸 권장하고 있고 Activity가 완전히 내려가는 &lt;code class=&quot;highlighter-rouge&quot;&gt;onDestroy&lt;/code&gt;에서 Job을 종료하는 걸 추천하고있다.&lt;/p&gt;

&lt;p&gt;참고로 필자가 구현한 방법은 CoroutineScope을 Activity/Fragment/ViewModel/LifecycleObserver 등에서 활용할 수 있도록 하다 보니 &lt;a href=&quot;https://kotlinlang.org/docs/reference/delegation.html&quot;&gt;Kotlin delegation&lt;/a&gt;을 활용하여 구현하여 일부 코드를 여기에 붙였다.&lt;/p&gt;

&lt;p&gt;여기에 나오는 코드들은 아래 링크를 통해 확인이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/taehwandev/CoroutinesUIExtensions/tree/2.x-CoroutinesUIExtensions/coroutines-extensions/src/main/java/tech/thdev&quot;&gt;CoroutinesUIExtensions&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;CoroutineScope을 interface로 정의&lt;/h3&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BaseCoroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * Coroutine job cancel
     */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;releaseCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드에서 중요한 부분은 Job 부분이다. CoroutineScope을 상속받아 사용할 경우에는 CoroutineScope의 동작을 제어할 녀석이 필요하다. 이를 &lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/&quot;&gt;Job&lt;/a&gt;을 이용하여 할 수 있다.&lt;/p&gt;

&lt;p&gt;이러한 Job은 안드로이드 상에서는 Lifecycle을 활용할 수 있도록 도와주는데 아래와 같은 job의 동작 방법을 알 수 있다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2019/04/Init-Coroutines/coroutine-job.png&quot; alt=&quot;coroutine-job&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;coroutine-job&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;Job에 대해서는 다음 글에서 좀 더 자세히 다루어보겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;BaseCoroutineScope을 상속받아 CoroutineScope을 구현&lt;/h3&gt;

&lt;p&gt;필자는 Delegation 패턴을 활용하기 위해서 미리 UICoroutineScope을 구현해보았다.&lt;/p&gt;

&lt;p&gt;UICoroutineScope에서는 Job을 추하였고, CoroutineContext를 Main 스케줄러를 활용하도록 초기화하였다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UICoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineContext&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DispatchersProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BaseCoroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;coroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineContext&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dispatchers&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;releaseCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DEBUG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;UICoroutineScope&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;onRelease coroutine&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;UICoroutineScope을 delegation으로 적용하면 위 코드를 그대로 가져가 job과 CoroutineContext을 함께 활용하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3&gt;Activity에서 상속 구현&lt;/h3&gt;

&lt;p&gt;BaseCoroutineScope을 바로 변수 scope인 UICoroutineScope을 활용하도록 만들었다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CoroutineScopeActivity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;@JvmOverloads&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constructor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BaseCoroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UICoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BaseCoroutineScope&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onDestroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onDestroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;releaseCoroutine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;앞으로 CoroutineScopeActivity을 활용하는 경우에는 항상 Android Main thread를 동반하고, launch에 Job이 포함되어 하위 잡들까지 컨트롤이 가능한 형태를 만들었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;원래 형태는&lt;/h2&gt;

&lt;p&gt;위 코드는 필자가 필요로 인해서 간단하게 구현한 베이스에 해당한다. 그렇다면 위 코드를 모두 합쳐서 사용하면 어떻게 해야 할까?&lt;/p&gt;

&lt;p&gt;간단하게 아래와 같이 CoroutineScope을 상속받아, 직접 구현해주면 되겠다.&lt;/p&gt;

&lt;p&gt;좀 더 쉽게 사용하기 위해서 Delegation 패턴을 활용하였을 뿐 크게 다른 부분은 없다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyActivity&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// Job을 등록할 수 있도록 초기화
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;lateinit&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 기본 Main Thread 정의와 job을 함께 초기화
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;coroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineContext&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 작업 중이던 모든 job을 종 children을 종료 처리
&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onDestroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onDestroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Cancel job on activity destroy. After destroy all children jobs will be cancelled automatically
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;그럼 샘플은?&lt;/h2&gt;

&lt;p&gt;위와 같이 만들었다면 별도의 CoroutineScope을 초기화 할 필요 없이 아래와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;launch {}&lt;/code&gt;로 바로 사용이 가능하다. 필요하다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;launch()&lt;/code&gt;에 thread를 변경할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * Note how coroutine builders are scoped: if activity is destroyed or any of the launched coroutines
 * in this method throws an exception, then all nested coroutines are cancelled.
 */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loadDataFromUI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;- extension on current activity, launched in the main thread
&lt;/span&gt;   &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;ioData&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;- extension on launch scope, launched in IO dispatcher
&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// blocking I/O operation
&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;// do something else concurrently with I/O
&lt;/span&gt;   &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ioData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// wait for result of I/O
&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// can draw in the main thread
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;코루틴의 스레드 형태를 어떻게 가져갈지 정의(&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.Main, Dispatchers.Default&lt;/code&gt;)&lt;/h2&gt;

&lt;p&gt;앞에서도 이야기하지 않은 Dispatches라는 게 있다. 이는 코루틴의 스레드를 어떠한 형태로 가져갈지를 지정할 수 있다.&lt;/p&gt;

&lt;p&gt;일반적으로 IO 스레드와 Main 스레드가 있다. 안드로이드 환경에서는 IO는 백그라운드 잡을 말하고, Main은 UI thread를 뜻한다.&lt;/p&gt;

&lt;p&gt;사용방법은 간단한데 CoroutineScope을 정의할 때 아래와 같이 사용 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드에서는 CoroutineScope은 IO thread에서 동작하도록 지정해주었고, 이어서 launch에서 Main으로 변경해버렸다. 실제 동작은 IO가 아닌 Main에서 동작하게 된다.&lt;/p&gt;

&lt;p&gt;IO로 글로벌하게 잡아두고, 특정 영역에서만 Main으로 교체하고 싶다면 아래와 같이 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// UI Thread
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// IO Thread
&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// IO Thread
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3&gt;Dispatchers.Main&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html&quot;&gt;Dispatchers.Main&lt;/a&gt;은 안드로이드 용으로 제공하는 thread. Java Handler가 기본으로 초기화되어 사용된다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Dispatches execution onto Android main thread and provides native [delay] support.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;Dispatchers.Default&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-dispatchers/-default.html&quot;&gt;Dispatchers.Default&lt;/a&gt;은 모든 launch, async, etc에서 사용하는데, ContinuationInterceptor을 지정하지 않을 경우 기본으로 사용하는 CoroutineDispatcher이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;마무리&lt;/h2&gt;

&lt;p&gt;기존에 작성했던 코루틴 관련 글 중에 최신화 부분을 다시 정리하였다. 다음 글에서 Job 부분을 위해서 좀 더 심도 있게 정리해보았다.&lt;/p&gt;
</description>
                <pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate>
                <link>http://thdev.tech/coroutines/2019/04/05/Init-Coroutines/</link>
                <guid isPermaLink="true">http://thdev.tech/coroutines/2019/04/05/Init-Coroutines/</guid>
                
                <category>Android</category>
                
                <category>kotlin</category>
                
                <category>coroutines</category>
                
                
                <category>coroutines</category>
                
            </item>
        
            <item>
                <title>RxJava 2.x 사용 시 발생하는 UndeliverableException 해결 방법은?</title>
                <description>&lt;p&gt;RxJava 2.x 사용 시 발생 가능한 버그를 소개하고, 해결 방법을 소개한다.&lt;/p&gt;

&lt;p&gt;RxJava 2.x 버전으로 올리고 나서 &lt;code class=&quot;highlighter-rouge&quot;&gt;UndeliverableException&lt;/code&gt;이 발생하는 경우가 생겼다.&lt;/p&gt;

&lt;p&gt;이해를 돕기 위해 오류 코드를 그대로 추가하고, 이 오류가 왜 발생하는지와 어떻게 해결할지를 정리한다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;io.reactivex.exceptions.UndeliverableException: The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | java.lang.UnknownError: UnknownError
	at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)
	at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:69)
	at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.UnknownError: Error message
	at tech.thdev.coroutinesuiextensions.RxJavaTest$test$1$2.apply(RxJavaTest.kt:33)
	at tech.thdev.coroutinesuiextensions.RxJavaTest$test$1$2.apply(RxJavaTest.kt:10)
	at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onSuccess(SingleMap.java:57)
	at io.reactivex.internal.operators.single.SingleObserveOn$ObserveOnSingleObserver.run(SingleObserveOn.java:81)
	at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578)
	at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)
	... 7 more
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다행히 위 오류는 발생함과 동시에 로그상에 해결 방법을 잘 제시해주고 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;라이브러리&lt;/h2&gt;

&lt;p&gt;이 코드를 확인하기 위한 라이브러리 버전을 명시한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;RxJava 2.2.7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxAndroid&quot;&gt;RxAndroid 2.1.1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling&quot;&gt;RxJava 2 - Error handling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;이 오류가 발생하는 가능성은?&lt;/h2&gt;

&lt;p&gt;위 오류를 해석해보면 진행 중 발생한 오류를 보내야 할 대상이 사라졌다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;consumer가 canceled/disposed&lt;/code&gt; 되어 보낼 곳이 없다는 것이다.&lt;/p&gt;

&lt;p&gt;실제 런타임에서 발생한 사례는 아래와 같이 추측할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;상황 1 Timeout이 발생할 정도로 서버의 응답이 늦었다.&lt;/li&gt;
  &lt;li&gt;상황 2 데이터의 전달 오류로 UnknownError가 발생하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같은 상황 1에서 사용자는 아래와 같이 행동할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자는 대기가 길어 이미 back 키를 마구 눌러 화면을 떠나버렸다.&lt;/li&gt;
  &lt;li&gt;라이프 사이클 상 &lt;code class=&quot;highlighter-rouge&quot;&gt;onDestroy&lt;/code&gt; 동작하였고, RxJava의 disposable을 동작하는 코드가 동작하였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같은 상황을 실제 검증할 수 있었지만, 오류 로그 상 구문에서 이를 명확하게 이해할 수 있었다.&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The exception could not be delivered to the consumer because it has already canceled/disposed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;코드로 다시 재현해보기&lt;/h2&gt;

&lt;p&gt;위와 같은 코드를 재현하기란 쉽지 않았다. 그래서 발생한 UndeliverableException을 그냥 내보내는 코드로 이를 대신하려고 한다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;RetrofitFactory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;githubApi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contributors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;taehwandev&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;CoroutinesUIExtensions&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observeOn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Schedulers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UnknownError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;UnknownError&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onErrorReturn&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// throw UnknownError 동작 후에 여기에서 잡히지 않는다
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onErrorReturn&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mutableListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onErrorResumeNext&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// throw UnknownError 동작 후에 여기에서 잡히지 않는다
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;onErrorResumeNext&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Single&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;just&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutableListOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doOnError&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// throw UnknownError 동작 후에 여기에서 잡히지 않는다
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;doOnError&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;subject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;success&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// throw UnknownError 동작 후에 여기에서 잡히지 않는다
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;subject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fail&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;map에서 UnknownError를 발생시키면 doOnError/onErrorReturn/onErrorResumeNext로 이동할 것 같았지만 실제론 UndeliverableException 발생 후 앱이 종료되어버렸다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;해결 방법은&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;해결 방법은 오류 로그 중 Further reading: https://github.com/ReactiveX/RxJava/wiki/What’s-different-in-2.0#error-handling&lt;/td&gt;
      &lt;td&gt;java.lang.UnknownError: UnknownError을 통해 쉬게 확인이 가능하다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling&quot;&gt;error-handling&lt;/a&gt;에서 확인한 Java 코드를 필자가 Kotlin 코드로 변환하여 추가하였다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RxJava 2.2.7에서 일부 코드가 변경되어 그에 맞게 수정하였다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;RxJavaPlugins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setErrorHandler&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UndeliverableException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cause&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SocketException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// fine, irrelevant network problem or API that throws on cancellation
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;@setErrorHandler&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// fine, some blocking code was interrupted by a dispose call
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;@setErrorHandler&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NullPointerException&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// that's likely a bug in the application
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uncaughtExceptionHandler&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uncaughtException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;@setErrorHandler&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IllegalStateException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// that's a bug in RxJava or in a custom operator
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uncaughtExceptionHandler&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uncaughtException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;@setErrorHandler&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Undeliverable exception received, not sure what to do&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 전역에서 한 번만 설정해주면 되는 부분으로 Application 상속 구조에 적용하면 잘 동작하게 될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;결과&lt;/h2&gt;

&lt;p&gt;RxJavaPlugins.setErrorHandler를 통해 간단하게 제어가 가능하게 되었고, RxJava 사용 중 발생한 오류는 아래와 같이 Log가 남고 넘어가게 되었다.&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Undeliverable exception received, not sure what to do java.lang.UnknownError: UnknownError
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 이에 따른 예외 처리가 필요하다면 setErrorHandler를 통해 이를 서버로 로그를 전송할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;마무리&lt;/h2&gt;

&lt;p&gt;위 코드는 RxJava에서 RxJava2로 마이그레이션 하는 문서에 잘 설명하고 있다.&lt;/p&gt;

&lt;p&gt;잘 보고 넘어가면 문제없고, RxJavaPlugins의 setErrorHandler를 잘 적용하였다면 문제없을 것이다.&lt;/p&gt;

&lt;p&gt;그리고 보통은 잘 안 나타나는데 필자의 경우 위에서 나열하였던 경우에서 발생함을 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;나중을 위해서 한 번 정리해두었다.&lt;/p&gt;
</description>
                <pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate>
                <link>http://thdev.tech/android/2019/03/04/RxJava2-Error-handling/</link>
                <guid isPermaLink="true">http://thdev.tech/android/2019/03/04/RxJava2-Error-handling/</guid>
                
                <category>Android</category>
                
                <category>kotlin</category>
                
                <category>RxJava2</category>
                
                
                <category>Android</category>
                
            </item>
        
            <item>
                <title>RxJava와 Kotlin Coroutines 비교해보기</title>
                <description>&lt;p&gt;RxJava는 안드로이드 개발에 없어서는 안 될 존재가 되었다. 많은 개발자들이 사용하고 있으며, 구글도 RxJava 관련한 API를 제공한다. 하지만 RxJava를 이해하기까지 상당한 시간이 걸린다.&lt;/p&gt;

&lt;p&gt;다음 코드를 이해하려면 과연 몇 개의 정보를 이해하고 있어야 할까?&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Flowable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observeOn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Schedulers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribeOn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Schedulers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observeOn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AndroidSchedulers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mainThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// UI 에서 처리
&lt;/span&gt;                &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// 오류 처리
&lt;/span&gt;                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;RxJava에서 사전에 알아야 할 구문&lt;/h2&gt;

&lt;p&gt;위 코드를 이해하기 위한 최소한 아래의 정보를 이해할 수 있어야 코드를 이해할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html&quot;&gt;Flowable&lt;/a&gt; : Reactive-Stream을 구현하기 위한 패턴의 시작&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/documentation/operators/subscribeon.html&quot;&gt;subscribeOn&lt;/a&gt; : Reactive-Stream에서 사용할 기본 스케줄러이며, observeOn으로 스케줄러 교체하기 전까지 기본으로 사용한다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/documentation/operators/observeon.html&quot;&gt;observeOn&lt;/a&gt; : 스케줄러의 변경이 필요하면 observeOn을 이용 스케줄러 교체가 가능하다. 다음 observeOn이 오기전까지 유효하다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/documentation/operators/map.html&quot;&gt;map&lt;/a&gt; : Stream에서 넘어온 데이터를 처리할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/documentation/operators/filter.html&quot;&gt;filter&lt;/a&gt; : Stream에서 넘어온 데이터에 filter를 걸 수 있다. 단, 조건의 결과값이 true가 아닌 경우 다음 구문을 실행하지 않는다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/documentation/operators/subscribe.html&quot;&gt;subscribe&lt;/a&gt; : 모든 Reactive-Stream은 subscribe 정의가 없으면 동작하지 않는다. subscribe 정의에서는 onNext, onError, onCompleted을 제공한다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/schedulers/Schedulers.html&quot;&gt;Schedulers.io()&lt;/a&gt; : Rx에서 사용하는 Schedulers이며 AndroidSchedulers.mainThread()를 별도로 제공한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RxJava 하나를 이해하기 위해서 위와 같은 구문을 알아야 한다. 여기에는 당연하게도 Observer pattern을 이해하고 있어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;RxJava 대신 Coroutine으로 작성하면?&lt;/h2&gt;

&lt;p&gt;이번엔 RxJava로 작성한 코드를 Coroutine으로 변경해보자. 이 코드에는 kotlin에서 제공하는 stream을 함께 사용하여 더 짧은 코드로 작성하였다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 0부터 9까지의 배열을 가진다.
&lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 0~9까지의 값에 + 1을 한다.
&lt;/span&gt;            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forEach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 4보다 큰 값에 대해서 true를 리턴한다.
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// UI 처리
&lt;/span&gt;                    &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// UI에서 출력한다.
&lt;/span&gt;                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Coroutine에서 알아야 할 것은?&lt;/h2&gt;

&lt;p&gt;이번엔 위 Coroutine 코드를 이해하기 위한 구문을 나눠보자.&lt;/p&gt;

&lt;p&gt;기본 형태는 함수와 동일하여 이해하기 쉬운데 크게 나누면 CoroutineScope, launch와 RxJava에서와 같은 스케줄러인 Dispatches를 이해하면 간단하게 읽을 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/&quot;&gt;CoroutineScope&lt;/a&gt; : Coroutine을 동작하기 위해서 CoroutineScope을 정의할 수 있다. CoroutineScope은 기본 스케줄를 함께 지정해야 하며, RxJava의 subscribeOn과 같다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;launch&lt;/a&gt; : 코루틴으로 동작해야 할 코드 스쿱을 지정한다. 이때 이 스쿱에서 사용할 스케줄러를 함께 지정할 수 있으며, 지정하지 않을 경우 CoroutineScope에서 지정한 스케줄러를 사용한다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/&quot;&gt;Dispatchers&lt;/a&gt; : 코루틴에서 사용할 스케줄러를 정의하며, Default(Work Thread), Main(UI Thread) 등을 지정할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RxJava보다 알아야 할 구문이 적어 이해하기 쉽다. 처음에는 RxJava보다 이해하기 쉽지만 시간이 지날수록 RxJava 만큼의 학습 비용은 들어간다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;RxJava vs Coroutine&lt;/h2&gt;

&lt;p&gt;그러면 RxJava와 Coroutine의 서로 비슷한 점을 먼저 정리하는데, 이는 RxJava를 활용한 사용자가 Coroutine을 쉽게 활용할 수 있도록 정리해보았다.&lt;/p&gt;

&lt;h3&gt;코드의 시작 부분 - 명시&lt;/h3&gt;

&lt;h4&gt;RxJava&lt;/h4&gt;

&lt;p&gt;RxJava는 용도별로 Reactive-Stream 형태를 제공한다. 다음과 같이 5 가지를 제공하는데 Reactive-Stream을 시작할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html&quot;&gt;io.reactivex.Flowable&lt;/a&gt; : 0..N flows, supporting Reactive-Streams and backpressure&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html&quot;&gt;io.reactivex.Observable&lt;/a&gt; : 0..N flows, no backpressure,&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Single.html&quot;&gt;io.reactivex.Single&lt;/a&gt; : a flow of exactly 1 item or an error,&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Completable.html&quot;&gt;io.reactivex.Completable&lt;/a&gt; : a flow without items but only a completion or error signal,&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Maybe.html&quot;&gt;io.reactivex.Maybe&lt;/a&gt; : a flow with no items, exactly one item or an error.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Coroutine&lt;/h4&gt;

&lt;p&gt;Coroutine은 interface로 정의되어있으며, 모든 Scope은 CoroutineScope을 최상위로 두고 있다. 이를 활용한 GlobalScope을 함께 제공한다. RxJava처럼 subscribe 호출 시 동작하도록 하려면 suspend로 함수 정의를 해둘 수 있는데, 단순 CoroutineScope은 즉시 실행 및 event 대기를 한다.&lt;/p&gt;

&lt;p&gt;launch의 return 결과인 Job을 통해 일시 정지, 종료, 취소, 시작 등을 제어할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html&quot;&gt;CoroutineScope&lt;/a&gt; : 새로운 CoroutineScope을 생성할 수 있으며, 스케줄러를 함께 초기화해야 한다. CoroutineScope은 Activity 라이프사이클에 따라 동작하도록 베이스 코드를 함께 사용하는 것을 추천하고 있다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/&quot;&gt;GlobalScope&lt;/a&gt; : CoroutineScope을 상속받아 구현되어있으며, GlobalScope은 object인 싱글톤으로 만들어져있다. GlobalScope은 Application의 라이프 사이클을 따라 동작해야 하며, 서비스와 같은 형태에서 사용하는 것을 추천한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CoroutineScope, GlobalScope으로 객체를 생성하였다면, 코드 동작을 위한 액션을 지정해주어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html&quot;&gt;launch&lt;/a&gt; : 일반적인 코루틴을 사용할 때 사용하며, launch에서 스케줄러를 지정하지 않으면, CoroutineScope의 스케줄러를 따르며, 지정할 경우 블록 안에서만 스케줄러에 따라 동작한다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html&quot;&gt;async&lt;/a&gt; : async/await이 필요할 경우 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html&quot;&gt;actor&lt;/a&gt; : actor를 사용할 경우 이벤트 전달이 가능하며, suspend에서 데이터 전달과 send와 기본 Thread에서 이벤트 전달이 가능한 offer 두 가지를 제공한다. 이를 Android에서는 OnClick에 함께 사용할 수 있다. &lt;a href=&quot;https://thdev.tech/kotlin/2018/10/11/Kotlin-Coroutines-Android/&quot;&gt;이전 글 참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이것 외에도 다양하게 있으니 &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines/coroutines-guide.html&quot;&gt;코루틴 가이드 문서&lt;/a&gt;를 참고하길 바란다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;스케줄러 교체&lt;/h3&gt;

&lt;p&gt;이번엔 스케줄러 교체 방법을 알아보자.&lt;/p&gt;

&lt;h4&gt;RxJava&lt;/h4&gt;

&lt;p&gt;RxJava는 기본적으로 전체 스트림에서 사용할 기본 subscribeOn과 매번 교체할 수 있는 observeOn을 제공한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/documentation/operators/subscribeon.html&quot;&gt;subscribeOn&lt;/a&gt; : Reactive-Stream에서 기본으로 사용할 스케줄러를 지정한다. observeOn으로 새로운 스케줄러 지정하기 전까지 유지된다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactivex.io/documentation/operators/observeon.html&quot;&gt;observeOn&lt;/a&gt; : Reactive-Stream의 진행 중 UI/Background Thread를 언제나 교체할 수 있다. observeOn으로 스케줄러를 지정하면 스케줄러가 변경되며, 이후 stream에서 이를 따른다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;Coroutine&lt;/h4&gt;

&lt;p&gt;코루틴은 CoroutineScope에서는 생성 시 Dispatches을 지정하며, GlobalScope은 기본으로 EmptyCoroutineContext으로 지정되어있다. 이 Dispatches 정의는 RxJava의 subscribeOn과 동일하게 동작한다.&lt;/p&gt;

&lt;p&gt;이후 RxJava의 observeOn과 동일한 행동을 원할 경우 launch()에 새로운 Dispatches을 지정해주면 아래와 같이 지정할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;launch(Dispatches.Default) : Work 스레드를 사용하여 동작한다.&lt;/li&gt;
  &lt;li&gt;launch(Dispatches.Main) : Main 스레드를 사용하여 동작한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 두 정의의 Dispatches 선택에 따라 UI/Background Thread의 형태를 지정할 수 있다. launch에서 Dispatches 지정하지 않으면, 상위(CoroutineScope, GlobalScope)의 기본 Dispatches에 따라 동작한다.&lt;/p&gt;

&lt;p&gt;이 동작은 observeOn과 동일한 결과를 가지지만, RxJava처럼 이후 스트림까지 영향을 받지는 않는다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3&gt;Release 하기&lt;/h3&gt;

&lt;h4&gt;RxJava&lt;/h4&gt;

&lt;p&gt;RxJava에서는 subscribe가 호출되면 &lt;a href=&quot;http://reactivex.io/RxJava/javadoc/io/reactivex/disposables/Disposable.html&quot;&gt;disposable&lt;/a&gt;을 리턴한다. Disposable을 묶어서 Android Lifecycle의 onDestroy에서 disposable.clear을 호출하여 기존 Reactive-Stream을 종료할 수 있다.&lt;/p&gt;

&lt;h4&gt;Coroutine&lt;/h4&gt;

&lt;p&gt;Coroutine에서는 Job이 return 되거나, coroutineContext에 Job을 함께 지정할 수 있는데 아래와 같이 할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;coroutineContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CoroutineContext&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DispatchersProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 job은 onDestroy에서 cancel 처리할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onDestroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onDestroy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;RxJava to Coroutine&lt;/h2&gt;

&lt;p&gt;표로 한 번 더 정리하면 아래와 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;내용&lt;/th&gt;
      &lt;th&gt;RxJava&lt;/th&gt;
      &lt;th&gt;Coroutine&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;시작&lt;/td&gt;
      &lt;td&gt;Flowable&lt;/td&gt;
      &lt;td&gt;CoroutineScope(dispatchers)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0..10&lt;/td&gt;
      &lt;td&gt;range(0, 10)(RxJava에서 제공)&lt;/td&gt;
      &lt;td&gt;(0..9)(코틀린 문법)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;시작 스케줄러&lt;/td&gt;
      &lt;td&gt;subscribeOn(Schedulers.io())&lt;/td&gt;
      &lt;td&gt;Dispatchers.Default&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;중간 스케줄러 변경&lt;/td&gt;
      &lt;td&gt;observeOn(Schedulers.io())&lt;/td&gt;
      &lt;td&gt;launch(Dispatchers.Main)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;index + 1&lt;/td&gt;
      &lt;td&gt;map {}&lt;/td&gt;
      &lt;td&gt;map {} (코틀린 stream 문법)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;index &amp;gt; 4&lt;/td&gt;
      &lt;td&gt;filter {}&lt;/td&gt;
      &lt;td&gt;filter {} (코틀린 stream 문법)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;출력&lt;/td&gt;
      &lt;td&gt;subscribe의 onNext에서 출력 (구독을 통한 실행)&lt;/td&gt;
      &lt;td&gt;launch를 통한 MainThread로 변경 후 출력&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;마무리&lt;/h2&gt;

&lt;p&gt;RxJava 개발자가 Coroutine을 이해하는 방법을 나름대로 정리해보았다. 정리하면 코루틴은 RxJava에 비해서 읽기 편한 코드를 제공하며, 초기 러닝 커브가 낮아 이해하는 게 쉽다. RxJava는 처음에 알아야 할 게 많은 대신 활용성이 높다.&lt;/p&gt;

&lt;p&gt;다양한 라이브러리를 제공하고 있으며, 네트워크부터 대부분의 코드를 RxJava를 활용하여 작성이 가능하다. Coroutine은 아직까지 다양한 라이브러리의 부족으로 직접 개발하거나, Kotlin extension + Higher-Order function 등을 활용하여 직접 개발을 하면서 사용해야 편하게 쓸 수 있다.&lt;/p&gt;

&lt;p&gt;결국 아직은 RxJava가 더 편하다는 결론이다.&lt;/p&gt;

&lt;p&gt;다행히 Coroutine의 샘플 중에는 RxJava와 함께 사용할 수 있는 샘플을 제공하는데, 아직 라이브러리로 배포를 하지는 않았다. 다음에 작성하는 글에서 이를 확인해보려고 한다.&lt;/p&gt;
</description>
                <pubDate>Wed, 07 Nov 2018 00:00:00 +0000</pubDate>
                <link>http://thdev.tech/kotlin/2018/11/07/RxJava-To-Kotlin-Coroutine/</link>
                <guid isPermaLink="true">http://thdev.tech/kotlin/2018/11/07/RxJava-To-Kotlin-Coroutine/</guid>
                
                <category>Android</category>
                
                <category>kotlin</category>
                
                <category>Coroutines</category>
                
                
                <category>kotlin</category>
                
            </item>
        
            <item>
                <title>Kotlin Coroutines 안드로이드 OnClick에 활용하기</title>
                <description>&lt;p&gt;이전 글에서 Coroutines과 안드로이드에 적용하기 위한 플러그인 적용 방법을 알아보았다.&lt;/p&gt;

&lt;p&gt;이번 글에서는 적용한 코드를 좀 더 자세하게 알아보고, Android에서 onClick과 함께 사용할 경우 유용한 Coroutine 사용 방법을 알아본다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2&gt;Countdown 코드 살펴보기&lt;/h2&gt;

&lt;p&gt;이전 글에 사용한 샘플 코드를 그대로 가져와보았다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GlobalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// launch coroutine in the main thread
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;downTo&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// countdown from 10 to 1
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;tv_message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Countdown $i ...&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// update text
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// wait half a second
&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tv_message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Done!&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fab&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setOnClickListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// cancel coroutine on click
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드를 통해 이번 글에서 알아볼 부분을 분리해보았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;코루틴의 스레드 형태를 어떻게 가져갈지 정의(&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatchers.Main, Dispatchers.Default&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같은 코드를 확인할 수 있다. 각각을 구분하여 글을 정리하고, onClick에서 사용할 부분을 좀 더 정리해본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Android OnClick에 따른 적절한 coroutine 처리 - 일단 알아보자&lt;/h2&gt;

&lt;p&gt;onClick을 아래와 같이 생성해보았다. 아래 코드로는 무슨 일이 사실 일어나는지 알 수 없다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;btn_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setOnClickListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;downTo&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// countdown from 10 to 1
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;tv_message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Now Click $count Countdown $i ...&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// update text
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// wait half a second
&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;tv_message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Done!&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 앱을 실행하고, start 버튼을 N 번 눌러본다. 아래 그림처럼 계속적인 버튼을 눌렀다면 무슨 일이 일어날까?&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2018/10/Kotlin-Coroutines-Android/click.png&quot; alt=&quot;click&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;click&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;결과는 아래와 같다. 결과의 이해를 돕기 위해 그림과 텍스트를 추가해보았다. 결과는 병렬로 계속 움직인다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Now Click 1 Countdown 5 ...
Now Click 2 Countdown 5 ...
Now Click 1 Countdown 4 ...
Now Click 3 Countdown 5 ...
...
Now Click 1 Countdown 1 ...
Done!
Now Click 5 Countdown 5 ...
Now Click 4 Countdown 4 ...
Now Click 3 Countdown 1 ...
Done!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;첫 번째 클릭의 결과로 Now Click 1 Countdown 5 … 이 먼저 보이고, 이어서 버튼을 누르면 Now Click 2 Countdown 5 …이 잠깐 보였다가 다시 1번이 노출된다. 이런식으로 반복적으로 클릭을 발생하면 버튼 누른 만큼 N 번의 결과물이 노출되는걸 확인할 수 있다. 좀 더 자세하게 그림을 참고하길 바란다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2018/10/Kotlin-Coroutines-Android/coroutines-example-01.gif&quot; alt=&quot;coroutines-example-01&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;coroutines-example-01&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;사용자 액션에 따라 무작위로 동작해야 하는 경우도 있지만, 보통 그렇지 않다. 이전 동작이 모두 끝나고 나면 다음 동작을 해야 하는 경우도 있고, 중간중간 사용자의 액션을 처리해야 하는 경우도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;actor을 이용해보자&lt;/h2&gt;

&lt;p&gt;먼저 예를 들어보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;네트워크를 통해 데이터를 받아오고, 이를 노출한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이때 위와 같이 N 번 클릭을 무작위로 받는 코드를 작성한다면? 결과는 당연히 네트워크도 N 번 동작하게 된다. 기존 이벤트를 취소하는 것도 적절한 방법은 아니다.&lt;/p&gt;

&lt;p&gt;그래서 &lt;a href=&quot;https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/shared-mutable-state-and-concurrency.md#actors&quot;&gt;actor&lt;/a&gt;을 이용할 수 있는데, 아래와 같이 코드를 수정해보았다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;setContentView&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity_main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;btn_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onClick&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;downTo&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// countdown from 10 to 1
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;tv_message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Now Click $count Countdown $i ...&quot;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// update text
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// wait half a second
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tv_message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Done!&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;View&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suspend&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;View&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// launch one actor
&lt;/span&gt;  &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GlobalScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;View&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;setOnClickListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드는 여러 번 누르더라도 기존 action을 모두 처리하기 전에는 다음으로 넘어가지 않는다.&lt;/p&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2018/10/Kotlin-Coroutines-Android/coroutines-example-02.gif&quot; alt=&quot;coroutines-example-02&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;coroutines-example-02&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;마무리&lt;/h2&gt;

&lt;p&gt;간단하게 Android에서 Coroutine을 어떤 식으로 활용할 수 있을지 살펴보았다. RxJava를 활용한다면 throttleFirst의 형태를 만들어야 하겠지만 kotlin coroutine에서는 간단하게 Actor을 활용할 수 있다. 다만 GlobalScope가 아닌 매번 생성하는 CoroutineScope을 활용한다면 또 다른 이야기이긴 하다.&lt;/p&gt;
</description>
                <pubDate>Thu, 11 Oct 2018 00:00:00 +0000</pubDate>
                <link>http://thdev.tech/kotlin/2018/10/11/Kotlin-Coroutines-Android/</link>
                <guid isPermaLink="true">http://thdev.tech/kotlin/2018/10/11/Kotlin-Coroutines-Android/</guid>
                
                <category>Android</category>
                
                <category>kotlin</category>
                
                <category>Coroutines</category>
                
                
                <category>kotlin</category>
                
            </item>
        
            <item>
                <title>Kotlin Coroutines을 알아보고, 안드로이드에 library 적용하기</title>
                <description>&lt;p&gt;async/await 이야기가 가장 흔한 coroutine. 안드로이드 개발자도 이제 coroutine을 적용할 수 있다. kotlin에 Coroutine을 제공하고 있는데, Kotlin 1.1부터 제공하고 있다. 다만 아직은 별도 라이브러리를 통해 Coroutine을 제공하고 있다.&lt;/p&gt;

&lt;p&gt;추후 Coroutine은 1.3부터 공식적으로 Kotlin에 포함되어있어 별도의 라이브러리 추가 없이 사용이 가능해지게 된다.&lt;/p&gt;

&lt;p&gt;이번 글에서는 Kotlin을 간략하게 알아보고, 안드로이드에서 사용 가능하도록 Coroutine 라이브러리 적용하는 방법을 소개한다.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Coroutines&lt;/h2&gt;

&lt;p&gt;Coroutine에 대해서 이야기할 때 async/await에 대해서 이야기를 가장 많이 했었다. 그래서 코드 가독성과 구현 방법을 우선해서 기존 Java Thread와 AsyncTask, Rxjava 2.0을 통해 살펴보며 Coroutines에 대하여 좀 더 상세하게 살펴보고 넘어가자.&lt;/p&gt;

&lt;p&gt;다음 샘플은 아래와 같은 가정하에 작성하였다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;버튼을 누른다.(여기서는 제외한다)&lt;/li&gt;
  &lt;li&gt;네트워크 처리를 위해서 Progress를 실행&lt;/li&gt;
  &lt;li&gt;loadNetworkSomething()으로 네트워크를 처리&lt;/li&gt;
  &lt;li&gt;progress 숨김&lt;/li&gt;
  &lt;li&gt;UI 갱신&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Java Thread&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html&quot;&gt;Java Thread&lt;/a&gt;는 Java에서 기본으로 제공하는 라이브러리이다. 이를 이용하여 다운로드를 구현해보면 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Looper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMainLooper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;post&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// show Progress on UI Thread&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loadNetworkSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Looper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMainLooper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;post&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// UI data update from UI thread&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Hide Progress from UI thread&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다만 kotlin에서 람다 표현식을 사용하여 코드가 짧지만 Java 7의로 작성한다면 이보다 많이 길어지며, 지저분하다.&lt;/p&gt;

&lt;h3&gt;Android AsyncTask&lt;/h3&gt;

&lt;p&gt;안드로이드에서는 이러한 Thread를 구조화 시켜 &lt;a href=&quot;https://developer.android.com/reference/android/os/AsyncTask&quot;&gt;AsyncTask&lt;/a&gt;를 제공하고 있는데 아래와 같이 구현이 가능하다. Background, UI Thread을 구분해준 메소드를 통해 이를 활용할 수 있다. Java Thread보다는 높은 가독성을 가지고 있다.&lt;/p&gt;

&lt;p&gt;다만 추가가 쉽지 않고, 취소에 대한 처리를 별도로 해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;loadData&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AsyncTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doInBackground&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;vararg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loadSomethingData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onPreExecute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onPreExecute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Show progress from UI thread
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onPostExecute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onPostExecute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// UI data update from UI thread
&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// Hide Progress from UI thread
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;@Test&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;loadData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3&gt;RxJava 2.0&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://reactivex.io/&quot;&gt;ReactiveX&lt;/a&gt; 라이브러리인 &lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;RxJava 2&lt;/a&gt;를 이용하여 구현해보았다. Observable Pattern과 Stream으로 사용이 간단하다. observeOn 메소드를 통해 Thread 형태를 자유롭게 변경이 가능하여 AsyncTask보다 자유롭게 사용이 가능하다.&lt;/p&gt;

&lt;p&gt;위에서부터 아래로 가독성이 높아진다. 다만 Observable Pattern이라 콜백이 많이 생길 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;loadSomethingData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribeOn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Schedulers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observeOn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Schedulers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;observeOn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AndroidSchedulers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mainThread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doOnSubscribe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// Show progress from UI thread
&lt;/span&gt;      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doOnDispose&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// Hide Progress from UI thread
&lt;/span&gt;      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subscribe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// UI data update from UI thread
&lt;/span&gt;      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3&gt;Coroutine&lt;/h3&gt;

&lt;p&gt;이제 Coroutine으로 이들을 정리해보자. UI 스레드로 블록을 지정하고, async/await을 이용해 loadSomethingData를 불러온다. 위에서 보았던 코드들 보다 더 높은 가독성을 가지고 있다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;launch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Show progress from UI thread
&lt;/span&gt;    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CoroutineScope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dispatchers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// background thread
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loadNetworkSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// UI data update from UI thread
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Hide Progress from UI thread
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;루틴(Routine)&lt;/h2&gt;

&lt;p&gt;백그라운드와 UI를 구분해서 처리해보았다. 이제 Coroutine을 좀 더 자세하게 알아보자. 이러한 루틴은 서브루틴(&lt;a href=&quot;https://en.wikipedia.org/wiki/Subroutine&quot;&gt;Subroutine&lt;/a&gt;)과 코루틴(&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine&lt;/a&gt;)으로 나누어 설명하겠다.&lt;/p&gt;

&lt;h3&gt;서브루틴(Subroutine)&lt;/h3&gt;

&lt;p&gt;개발을 하다 보면 중복 코드를 자연스럽게 함수로 만들어 호출해서 사용한다. 굳이 동일한 코드를 여러 장소에 두어 사용할 필요가 없고, 수정 시 수정 범위를 최소화하기 위해서이기도 하다. 예를 들면 다음과 같은 Fragment replace 하는 함수를 만들어두고, replace가 필요한 여러 곳에서 활용이 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;AppCompatActivity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;@IdRes&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;frameId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;support&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;supportFragmentManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beginTransaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;frameId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fragment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 형태를 Subroutine이라 부른다. Wiki에 따르면 언어별로 부르는 용어가 다양한데 Java에서는 function이라 부른다. 결과적으로 서브루틴은 함수를 호출하고, 서브루틴의 모든 처리가 완료되어야 다음 줄의 코드를 실행할 수 있다.&lt;/p&gt;

&lt;h3&gt;코루틴(Coroutines)&lt;/h3&gt;

&lt;p&gt;서브루틴의 확장 개념인 Coroutines은 아래와 같은 장점을 가지고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 다른 지점에서 입력과 종료가 일어난다.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
    &lt;img src=&quot;/images/posts/2018/10/Kotlin-Coroutines/coroutines-example.png&quot; alt=&quot;coroutines-example&quot; /&gt;
    
    &lt;figcaption class=&quot;caption-text&quot;&gt;coroutines-example&lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;실행을 일시 중지하고 호출자 또는 다른 Coroutine으로 이동할 수 있다. 호출자는 언제든 다시 Coroutine을 실행시킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;단순하게는 Thread처럼 보일 수 있지만 Thread 보다 훨씬 저렴한 비용으로 동작하게 된다. Subroutine처럼 함수 형태로 코드를 작성하여 가독성이 높다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Coroutine과 Thread&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html&quot;&gt;Java Thread&lt;/a&gt;는 하나의 프로세스에 여러 개의 작업을 실행할 수 있지만 OS의 Native Thread에 직접 링크되어 동작하여 많은 시스템 자원을 사용한다. Thread 간 전환 시에도 CPU의 상태 체크가 필요하므로 그만큼의 비용이 발생한다.&lt;/p&gt;

&lt;p&gt;반면 Coroutine은 즉시 실행하는 게 아니며, Thread와 다르게 OS의 영향을 받지 않아 그만큼 비용이 들어가지 않는다. 그리고 개발자가 직접 루틴을 언제 실행할지, 언제 종료할지 모두 지정이 가능하다. 이렇게 생성한 루틴은 작업 전환 시에 시스템의 영향을 받지 않아 그에 따른 비용은 발생하지 않는다. 또한 suspension 포인트를 개발자가 지정하기 때문에 무작위로 종료할 순 없다.&lt;/p&gt;

&lt;p&gt;자세한 내용은 : &lt;a href=&quot;https://stackoverflow.com/questions/43021816/difference-between-thread-and-coroutine-in-kotlin&quot;&gt;stackoverflow에 설명되어있는 Coroutine과 Thread&lt;/a&gt;를 참고할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Coroutine 언제 사용하면 좋을까?&lt;/h2&gt;

&lt;p&gt;Coroutine은 결국 대용량 처리, 복잡한 계산, 게임 등에서 유용하게 사용할 수 있다. 보통 유니티에서 많이 사용하고 있다. 코틀린에서도 이를 제공하여 Android 개발에서도 Coroutine 사용이 가능하다.&lt;/p&gt;

&lt;p&gt;다만 &lt;a href=&quot;http://reactivex.io/&quot;&gt;ReactiveX&lt;/a&gt;처럼 강력한 라이브러리 형태를 제공하지는 못한다. Github을 통해 그래도 괜찮은 라이브러리를 몇 개 찾을 수 있긴 하지만 ReactiveX 만큼의 편의성은 아직이다. 필요시 만들어 쓰는 방법과 그냥 RxJava 활용을 하는 편이 좋다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;Kotlin Coroutine&lt;/h2&gt;

&lt;p&gt;1.2 버전에서는 별도의 라이브러리를 통해 이를 제공하고 있는데, 1.3 버전부터는 코틀린에 포함되어 제공할 예정이다. 현재 RC를 통해 Kotlin &lt;a href=&quot;https://blog.jetbrains.com/kotlin/2018/09/kotlin-1-3-rc-is-here-migrate-your-coroutines/&quot;&gt;1.3 RC&lt;/a&gt;을 미리 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;kotlin coroutine의 경우 다른 언어에서 제공하는 비동기 처리에 대해서도 추가로 제공하고 있다. C#과 ECMAScript에서 제공하는 async/await. Go에서 제공하는 channels, select. C#과 Python에서 제공하는 generators/yield도 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;더 많은 내용은 &lt;a href=&quot;https://kotlinlang.org/docs/reference/coroutines.html&quot;&gt;Coroutine&lt;/a&gt; 문서를 확인하기 바란다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2&gt;안드로이드에 코루틴(Coroutine) 적용하기&lt;/h2&gt;

&lt;p&gt;안드로이드에서 코틀린 적용하는 