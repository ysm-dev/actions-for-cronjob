<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0" xml:lang="ko"><title type="text">Firejune</title><link rel="alternate" type="text/html" href="https://firejune.com/" /><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/atom+xml" href="http://feeds.feedburner.com/firejune" /><subtitle type="html">이 사이트는 자바스크립트 프로그래밍을 중심으로 웹 애플리케이션 개발에 대한 내용을 주로 다룹니다.</subtitle><logo>https://firejune.com/attach/image/272778.jpeg</logo><rights type="text">(C)2017 firejune.com</rights><updated>1970-01-01T00:00:00+00:00</updated><generator></generator><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/rss+xml" href="http://feeds.feedburner.com/firejune" /><feedburner:info uri="firejune" /><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="hub" href="http://pubsubhubbub.appspot.com/" /><id>https://firejune.com/</id><entry><title type="text">2016 Play.Node 발표자료 공유</title><link rel="alternate" type="text/html" href="http://feedproxy.google.com/~r/firejune/~3/KA97OdeFgcw/1812" /><category term="자료-웹개발" /><category term="OctoberSky.js" /><category term="Play.Node" /><category term="발표자료" /><category term="Electron" /><category term="테스트 자동화" /><category term="모바일" /><category term="자바스크립트" /><category term="Node.js" /><category term="프로젝트" /><category term="2017 MWC" /><category term="Remote TestKit" /><category term="OpenCV" /><category term="HighCharts" /><category term="PTY.js" /><category term="NPM" /><category term="Test Cloud" /><category term="같은 주제로 발표할 기회를 다시 얻는다면 좀 나아지겠지?" /><author><name>파이어준</name></author><updated>2016-11-24T23:10:08-08:00</updated><id>https://firejune.com/1812</id><content type="html">&lt;iframe src="//html5.firejune.com/electron.html" width="640" height="500" &gt;&#xD;
&lt;/iframe&gt;&lt;p class="cap1"&gt;슬라이드를 클릭한 후 방향키를 이용하여 다음으로 넘길수 있습니다.&lt;/p&gt;&#xD;

&lt;p&gt;&lt;a href="https://www.facebook.com/octoberskyjs/"&gt;OctoberSky.js&lt;/a&gt;가 주최하는 2016 &lt;a href="http://playnode.io/"&gt;Play.Node&lt;/a&gt; 개발자 콘퍼런스에서 "Electron 기반의 모바일 앱 테스트 자동화 S/W 개발"이라는 주제로 발표한 슬라이드를 공유합니다. "테스트 자동화"에 대한 개념을 인지해야 소프트웨어 구현의 전반적인 흐름에 대한 이해도를 높일 수 있을 것 같아서 잡설들을 늘어놓다 보니 제 수준에서는 40분 만에 소화하기 어려운 발표자료였습니다. 매번 느끼는 것이지만, 발표하면 할수록 더 못하는 것 같습니다. 그런데도 관심 있게 경청해 주신 여러분께 진심으로 감사드립니다.&lt;/p&gt;
&#xD;
&lt;h3&gt;발표연습 부족으로 전달 못 한 메시지:&lt;/h3&gt;&#xD;
&lt;ul class="squire"&gt;&#xD;
  &lt;li&gt;Node의 &lt;a href="http://v8project.blogspot.kr/"&gt;v8 엔진&lt;/a&gt;은 대부분의 최신 자바스크립트 문법을 지원하므로 굳이 ES5로 Transpiling할 필요가 없고 최소한의 Babel 플러그인 사용 노하우를 소개하고 싶었어요.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="https://www.npmjs.com/"&gt;NPM&lt;/a&gt; 생태계를 적절히 사용하면 꿀리지 않는 데스크탑 애플리케이션을 개발할 수 있어요.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="https://github.com/chjj/pty.js/"&gt;PTY.js&lt;/a&gt;로 구현한 터미널 모듈에서 테스트 대상이 되는 모바일 앱의 실시간 로그가 출력되는 데모를 보여드리고 싶었어요.&lt;/li&gt;&#xD;
  &lt;li&gt;이 로그는 개발자가 만들어낸 것이어서 디버그하는 힌트가 되고, 크래시가 발생한 경우 스택-추적까지에 대한 리포팅 기능을 소개하고 싶었어요.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="http://www.highcharts.com/"&gt;HighCharts&lt;/a&gt;를 이용한 실시간 모바일 시스템 리소스 모니터링 데모를 보여드리고 싶었어요.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="http://opencv.org/"&gt;OpenCV&lt;/a&gt;를 활용한 컴퓨터-비전 기술에 대한 가능성은 어마어마해요.('크래시 로얄'에서 교관을 이기는 AI를 개발 중이에요)&lt;/li&gt;&#xD;
  &lt;li&gt;동적 게임 테스트 POC를 성공시키지 못한 것이 너무 억울해요.(회사에서 할 때는 졸라 잘 돌아가는데...)&lt;/li&gt;&#xD;
  &lt;li&gt;로드맵에서는 모바일 기기의 파편화를 해결하는 방안을 'Test Cloud'를 통해서 만족할 수 있다는 사실과, '&lt;a href="https://www.xamarin.com/test-cloud"&gt;Test Cloud&lt;/a&gt;'는 Xamarin을 시작으로 거대한 조직들이 속속 뛰어드는 트랜드를 전달하고 싶었어요.&lt;/li&gt;&#xD;
  &lt;li&gt;테스트 클라우드 중 비교적 최근에 출시한 NTT사의 '&lt;a href="https://www.nttr.co.jp/english/"&gt;Remote TestKit&lt;/a&gt;' 제품과 연동되는 데모를 보여드리고 싶었어요.&lt;/li&gt;&#xD;
  &lt;li&gt;끝으로, 이 Studio 프로젝트는 무료로 풀 것이고, &lt;a href="https://www.mobileworldcongress.com/register-plan/register/?gclid=CjwKEAiAjvrBBRDxm_nRusW3q1QSJAAzRI1tN_zGiH1nwnF-nAcVKtm1vBldiYaFFwn2KaZyImbd2RoCXD7w_wcB"&gt;2017 MWC&lt;/a&gt;에서 화려한 &lt;a href="https://www.mobileworldcongress.com/exhibitors/?exhibitor_keyword=rsupport"&gt;데뷔&lt;/a&gt;를 목표로 하고 있다는 사실을 알리고 싶었습니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;

			&lt;br&gt;&lt;br&gt;
			&lt;a href="https://firejune.com/1812#p1812"&gt;Comments&lt;/a&gt; |
			&lt;a href="https://firejune.com/1812"&gt;Hits(291,788)&lt;/a&gt;&lt;img src="http://feeds.feedburner.com/~r/firejune/~4/KA97OdeFgcw" height="1" width="1" alt=""/&gt;</content><feedburner:origLink>https://firejune.com/1812</feedburner:origLink></entry><entry><title type="text">60여개 언어를 지원하는 OCR 엔진 Tesseract.js</title><link rel="alternate" type="text/html" href="http://feedproxy.google.com/~r/firejune/~3/PjZtdGT4xbI/1811" /><category term="자료-웹개발" /><category term="OCR" /><category term="Emscripten" /><category term="Tesseract" /><category term="자바스크립트" /><category term="C++" /><category term="문자 인식" /><category term="한글 인식" /><author><name>파이어준</name></author><updated>2016-10-25T23:00:31-07:00</updated><id>https://firejune.com/1811</id><content type="html">&lt;p&gt;Tesseract.js는 C++로 작성된 &lt;a href="https://github.com/tesseract-ocr/tesseract"&gt;Tesseract OCR&lt;/a&gt; 라이브러리를 자바스크립트로 포팅한 것으로 텍스트의 방향을 자동으로 탐지하며, 단락을 구분해 내거나  단어 및 문자의 경계를 탐지하는 등의 인터페이스를 제공합니다. &lt;a href="https://github.com/kripken/emscripten"&gt;Emscripten&lt;/a&gt;을 이용하여 &lt;a href="https://github.com/naptha/tesseract.js-core"&gt;tesseract.js-core&lt;/a&gt;라는 이름으로 포트 되었으며, 이 자바스크립트 파일의 용량이 무려 2.7MB에 달합니다. 브라우저의 리소스를 많이 잡아먹어서인지 WebWorker에서 동작하게 되어있고 Node에서는 &lt;code&gt;child_process&lt;/code&gt; API를 이용하는군요. 코어와 언어별 트레인드(Trained) 데이터는 최초 인식 때 한 번만 가져오고 이후부터는 캐시에서 불러옵니다.&lt;/p&gt;
&lt;p&gt;&lt;iframe src="https://jsbin.firejune.com/tesseract/" width="640" height="240" class="hasborder"  data-layout="fixed-height"&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;p&gt;한글의 인식률이 어떤지 궁금해서 원래 있던 데모에 한글모드를 추가해 보았습니다. 고딕 계열 폰트로 작성된 한글 이미지의 인식률이 가장 높았으며, 불분명하다고 판단하는 경우가 아주 많았습니다. 상단 탭을 한글로 맞추고 한글이 들어간 이미지 파일을 드롭하면 다른 파일의 인식 테스트도 가능합니다.&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;Tesseract.recognize(myImage)&#xD;
         .progress(function  (p) { console.log('progress', p)    })&#xD;
         .then(function (result) { console.log('result', result) })&lt;/code&gt;&lt;/pre&gt;

			&lt;br&gt;&lt;br&gt;
			&lt;a href="https://firejune.com/1811#p1811"&gt;Comments&lt;/a&gt; |
			&lt;a href="https://firejune.com/1811"&gt;Hits(331,823)&lt;/a&gt;&lt;img src="http://feeds.feedburner.com/~r/firejune/~4/PjZtdGT4xbI" height="1" width="1" alt=""/&gt;</content><feedburner:origLink>https://firejune.com/1811</feedburner:origLink></entry><entry><title type="text">웹기반 MT-32 시퀸스드 뮤직 플레이어</title><link rel="alternate" type="text/html" href="http://feedproxy.google.com/~r/firejune/~3/PfmZzGFxc4k/1807" /><category term="자료-웹개발" /><category term="MT-32" /><category term="Emscripten" /><category term="Munt" /><category term="ASM" /><category term="MIDI" /><category term="General MIDI" /><category term="libTiMidity" /><category term="자바스크립트" /><category term="C/C++" /><category term="포팅" /><category term="게임" /><category term="음악" /><category term="옥소리" /><category term="DOD" /><category term="OPL" /><author><name>파이어준</name></author><updated>2016-09-11T14:05:14-07:00</updated><id>https://firejune.com/1807</id><content type="html">&lt;p&gt;&lt;iframe src="https://jsbin.firejune.com/MT32Emu/" width="640" height="300" class="hasborder" data-layout="fixed-height"&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트로 간단하게 만들어 본 MIDI 시퀸스 플레이어입니다. 미디 모듈은 Roland사의 MT-32이며 이것은 &lt;a href="https://github.com/munt/munt"&gt;MUNT&lt;/a&gt;라는 C/C++ 에뮬레이션 라이브러리를 &lt;a href="https://kripken.github.io/emscripten-site/"&gt;Emscripten&lt;/a&gt;을 이용하여 ASM으로 포팅한 것입니다. SIERRA사의 Silpheed라는 슈팅게임 외 몇몇개의 사운드트랙을 데모용으로 올려두었습니다. (걍 플레이 버튼을 누르면 되요) MT-32용 MIDI 파일을 직접 구해서 플레이어로 끌어다 놓거나 버튼을 눌러 MIDI 파일을 선택하면 자동으로 재생합니다. 복수로 선택하는 경우 재생목록이 만들어 집니다. 더 많은 사운드트랙을 구하려면 구글링해서 &lt;a href="http://www.midimusicadventures.com/queststudios/midi-soundtracks/complete-soundtracks/"&gt;어렵지 않게 얻을 수&lt;/a&gt; 있고, 특히, Loom, Monky Island, Ultima, Zeliard, YS의 사운드트랙을 추천합니다. 아쉽게도 GM 용으로 만들어진 MIDI 파일은 오류가 나거나 제대로 재생되지 않으며, iOS 브라우저는 &lt;code&gt;ctx.createScriptProcessor&lt;/code&gt;의 &lt;code&gt;onaudioprocess&lt;/code&gt; 콜백이 정상적으로 호출되지 못하는 이슈가 있어 &lt;del&gt;작동하지 않습니다.&lt;/del&gt; &lt;a href="http://stackoverflow.com/questions/17087119/use-scriptprocessornode-in-iphone-safari"&gt;iOS Unmute Hack&lt;/a&gt;을 이용하여 재생할 수 있습니다.&lt;/p&gt;
&lt;p&gt;GM 기반 MIDI 파일은 &lt;a href="http://libtimidity.sourceforge.net/"&gt;libTiMidity&lt;/a&gt; 라이브러리를 ASM으로 포팅하여 재생이 되는 것을 확인하였습니다. 확실히 파워풀한 사운드를 들려주는군요. libTiMidity는 사운드폰트기반이어서 별도로 내려받아 실행해야 하고 쓸만한 폰트 파일의 크기가 100MB를 훌쩍 넘기 때문에 &lt;del&gt;온라인 플레이어로 만들기는 다소 힘들어 보입&lt;/del&gt;니다.(폰트를 악기단위로 분리하고 MIDI 파일을 분석하여 필요한 악기만을 비동기로 로드하고 재생하는 개념의 &lt;a href="http://www.midijs.net/"&gt;midijs&lt;/a&gt;라는 프로젝트가 있네요!)&lt;/p&gt;
&lt;figure class="image-align"&gt;&lt;img src="https://firejune.com/attach/0825/160825144620406993/962276.PNG" width="640" height="160" alt="IMG_1020.PNG" class=""&gt;&lt;/figure&gt;
&lt;blockquote&gt;&lt;p&gt;유년시절에 즐겼던 대부분의 DOS 게임들이 시퀸스 모듈을 이용하여 제작되었습니다. 시퀸스드 뮤직 파일은 여러 종류가 있는데 퀄리티 순으로 나열하면 General MIDI 호환 &amp;gt; MT-32 호환 &amp;gt; OPL 시리즈(AdLib Sound) &amp;gt; PC 스피커 순이 됩니다. 이 중에서도 중저가형인 MT-32호환 모듈인 CM-32를 사려고 용돈을 모으다가 저가형 하이-엔드 사운드 카드인 OPL-4기반의 "옥소리"가 출시되어 지르는 바람에 물 건너 가버렸던 그런 추억이 있는 시퀸스 모듈입니다. OPL-4는 YAMAHA사에서 만든 칩셋으로 낮은 가격대비 고수준의 PCM 음원을 내장한 시퀸스 모듈입니다만, 하필이면 이즈음 하드웨어에 의존 없이 소프트웨어 믹서만으로 CD 오디오 수준의 사운드를 재생하는 분위기로 개발 동향이 바뀌면서 시퀸스 사운드는 게임계에서 자취를 감추게 되었죠.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;MT-32 음향을 꼭 한번 들어보고 싶었는데, 20년이 훌쩍 지난 지금 자바스크립트로 재생해 보게 되었네요. 추억 돋게 하는군요.&lt;/p&gt;

			&lt;br&gt;&lt;br&gt;
			&lt;a href="https://firejune.com/1807#p1807"&gt;Comments&lt;/a&gt; |
			&lt;a href="https://firejune.com/1807"&gt;Hits(386,755)&lt;/a&gt;&lt;img src="http://feeds.feedburner.com/~r/firejune/~4/PfmZzGFxc4k" height="1" width="1" alt=""/&gt;</content><feedburner:origLink>https://firejune.com/1807</feedburner:origLink></entry><entry><title type="text">구글 액셀러레이티드 모바일 페이지(AMP) 적용하기</title><link rel="alternate" type="text/html" href="http://feedproxy.google.com/~r/firejune/~3/NWhfrpSjado/1800" /><category term="자료-웹개발" /><category term="AMP" /><category term="구글" /><category term="검색엔진" /><category term="액셀러레이티드 모바일 페이지" /><category term="PHP" /><category term="유효성 검사" /><category term="프로젝트" /><category term="화이팅!" /><category term="정규식 게이" /><category term="SEO" /><category term="뭣모르고 저질렀다가 뺑이침" /><category term="모바일" /><category term="HTML" /><author><name>파이어준</name></author><updated>2016-08-08T11:12:14-07:00</updated><id>https://firejune.com/1800</id><content type="html">&lt;p&gt;&lt;a href="https://www.google.com/webmasters/tools/home"&gt;구글 검색 콘솔&lt;/a&gt;에 &lt;a href="https://www.ampproject.org/"&gt;액셀러레이티드 모바일 페이지(AMP)&lt;/a&gt;라는 신기한 녀석이 출현했습니다. AMP는 모바일 환경에서 빠르게 로드되도록 설계된 페이지입니다. 자신의 웹사이트에 이를 적용하면 구글에서 제공하는 캐시에 저장되어 구글을 비롯한 여러 메타사이트가 웹페이지 프리뷰 등의 목적으로 활용할 수 있게 됩니다. 이전 글에 &lt;a href="https://firejune.com/1799/2016+%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84+%EC%B5%9C%EC%A0%81%ED%99%94+%ED%94%84%EB%A1%A4%EB%A1%9C%EA%B7%B8"&gt;간단한 소개&lt;/a&gt;가 있으니 참고하세요. &lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.ampproject.org/docs/reference/spec.html"&gt;AMP HTML 사양&lt;/a&gt;에 대한 기본적인 내용을 번역하기보다는 제가 이 작업을 수행하면서 경험한 삽질이나 알아낸 것, 유용하다고 생각되는 방법을 중심으로 설명하겠습니다. AMP 페이지를 작업하기에 앞서 선행되어야 할 사항으로 &lt;a href="https://developers.google.com/speed/pagespeed/insights/"&gt;구글 페이지 인사이트&lt;/a&gt;에서 모바일 사용환경 테스트 점수를 80점 이상으로 통과한 상태여야 하며, 추가로 &lt;a href="https://schema.org/"&gt;데이터 구조화&lt;/a&gt; 유형 중 아티클을 만족해야 합니다. 아티클 유형으로는 &lt;a href="http://schema.org/Article"&gt;Article&lt;/a&gt;, &lt;a href="http://schema.org/NewsArticle"&gt;NewsArticle&lt;/a&gt;, &lt;a href="http://schema.org/BlogPosting"&gt;BlogPosting&lt;/a&gt; 또는 &lt;a href="http://schema.org/VideoObject"&gt;VideoObject&lt;/a&gt;입니다. 이 네 가지 유형에 속하지 않는 웹사이트는 AMP를 적용하는 것이 현재 무의미합니다. 그러면, 일반 게시판이나 위키, 쇼핑몰은 어디에 속할까요? 대부분 Article 유형에 속합니다. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Note: 선택적으로는 SSL을 지원하는 것이 좋습니다. &lt;code&gt;&amp;lt;amp-form&amp;gt;&lt;/code&gt; 이나 &lt;code&gt;&amp;lt;amp-video&amp;gt;&lt;/code&gt; 등 &lt;code&gt;&amp;lt;amp-img&amp;gt;&lt;/code&gt;를 제외한 URL 속성을 필요로 하는 대부분의 AMP 컴포넌트가 SSL 주소를 요구하기 때문입니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;여기부터 작성되는 내용은 위 두 조건을 모두 만족한 것을 전제로 합니다. 이제 &lt;a href="https://www.ampproject.org/docs/reference/spec.html"&gt;AMP HTML을 작성&lt;/a&gt;해 봅시다. 기존 HTML에 AMP 모드를 추가할 것인지 아니면 AMP 페이지를 별도로 제공할 것인지를 우선 결정해야 합니다. 여기에는 장점과 단점이 존재합니다. 전자는 작업효율이 높습니다. 이미 잘 돌아가고 있는 HTML을 건드릴 필요가 없으니까요. 스펙 문서를 보고 마구잡이로 때려 고쳐 내려가면서 검사기를 통과시키면 됩니다. 단점은 관리 포인트가 늘어나는 것이죠. 후자는 고스란히 그 반대입니다. 굉장히 하드코어한 코딩을 구사하게 될 거에요. 저는 이 두 가지 방법을 모두 시도하는 것을 추천합니다. 최초 페이지를 별도로 작업하다 보면 두 문서 간의 차이점을 쉽게 찾아낼 수 있고요. 결국에는 하나의 작업물에서 두 가지 아웃풋을 내는 형태로 병합할 수 있습니다.&lt;/p&gt;
&lt;p&gt;자, 이제 AMP HTML 스펙 문서를 열고 코딩하세요. 코딩하면서 아래의 유의해야 할 항목을 살펴보세요. 이것은 제가 범한 실수이고 오류가 보고될 때마다 기록한 것입니다. 작게 여겨질 수도 있겠지만, 오류 하나가 보고되면 이 오류 항목이 사라지기까지는 보통 1달 정도 혹은 그 이상의 시간이 소요된다는 점 꼭 유념하시기 바랍니다.&lt;/p&gt;
&lt;ul class="square"&gt;&#xD;
&lt;li&gt;AMP 구분자와 언어코드를 HTML에 삽입해 주세요. &lt;code&gt;&amp;lt;html amp lang="ko"&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;UTF-8이 기본입니다. &lt;code&gt;&amp;lt;meta charset="utf-8"&amp;gt;&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;link rel="canonical"&amp;gt;&lt;/code&gt; 태그의 값에는 원래 문서의 고유 주소를 사용하세요.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;link rel="canonical"&amp;gt;&lt;/code&gt; 주소에는 필터와 같은 파라미터가 기입되지 않도록 하여 하나의 문서가 여러 링크를 만들어 내는 일이 없도록 해야합니다.&lt;/li&gt;&#xD;
&lt;li&gt;m.firejune.com과 같이 모바일용 페이지를 별도로 제공하는 경우 &lt;code&gt;&amp;lt;link rel="alternate"&amp;gt;&lt;/code&gt;를 이용하세요.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;meta name="viewport" content="width=device-width ..."&amp;gt;&lt;/code&gt; 필수 요소 입니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;script async src="https://cdn.ampproject.org/v0.js"&amp;gt;&lt;/code&gt; 역시 필수 요소입니다.&lt;/li&gt;&#xD;
&lt;li&gt;위 스크립트가 삽입되면 주소창의 마지막에 &lt;code&gt;#development=1&lt;/code&gt;를 붙여 콘솔 로그를 통해 실시간으로 오류를 확인할 수 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;페이지에서 필요로 하는 스타일시트를 모두 &lt;code&gt;&amp;lt;style amp-custom&amp;gt;&lt;/code&gt; 요소에 인라인으로 삽입하세요. 단, 50k를 넘겨선 안 됩니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;style amp-custom&amp;gt;&lt;/code&gt;에서 이미 정의된 &lt;code&gt;&amp;lt;amp-*&amp;gt;&lt;/code&gt; 요소의 스타일을 재정의 해선 안 됩니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;style amp-custom&amp;gt;&lt;/code&gt;에서 CSS의 값에 &lt;code&gt;!important&lt;/code&gt;를 사용할 수 없습니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;에 선언된 &lt;code&gt;&amp;lt;style amp-custom&amp;gt;&lt;/code&gt; 외 그 어떤 곳에도 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 태그는 허용되지 않습니다.&lt;/li&gt;&#xD;
&lt;li&gt;일반 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그도 마찬가지로 절대 허용하지 않습니다.&lt;/li&gt;&#xD;
&lt;li&gt;서드파티 라이브러리 포함하여 페이지에 삽입된 모든 자바스크립트를 삭제하세요.&lt;/li&gt;&#xD;
&lt;li&gt;요소에 인라인으로 작성된 &lt;code&gt;on*=&lt;/code&gt; 이벤트와 &lt;code&gt;style=&lt;/code&gt; 속성을 모두 삭제하세요.&lt;/li&gt;&#xD;
&lt;li&gt;별도의 확장 컴포넌트 없이 사용할 수 있는 &lt;code&gt;&amp;lt;amp-img&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;amp-video&amp;gt&lt;/code&gt;, &lt;code&gt;&amp;lt;amp-audio&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;amp-pixel&amp;gt&lt;/code&gt;, &lt;code&gt;&amp;lt;amp-ad&amp;gt;&lt;/code&gt; AMP 태그를 치환하는 작업을 먼저 수행 하세요.&lt;/li&gt;&#xD;
&lt;li&gt;모든 &lt;code&gt;&amp;lt;amp-*&amp;gt;&lt;/code&gt; 요소에는 &lt;code&gt;style=&lt;/code&gt;과 &lt;code&gt;on*=&lt;/code&gt; 속성을 사용할 수 없습니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;amp-video&amp;gt;&lt;/code&gt; 요소의 src 속성은 절대 경로여야 하며 &lt;code&gt;https&lt;/code&gt; 프로토콜을 이용해야 합니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;a href="https://www.ampproject.org/docs/reference/extended.html"&gt;확장 컴포넌트&lt;/a&gt;(추가적인 로딩이 필요한)에 상응하는 AMP 요소로 치환하고 동적으로 컴포넌트를 로딩하는 루틴을 구현하세요.&lt;/li&gt;&#xD;
&lt;li&gt;기존 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;으로 삽입된 youtube나 vimeo 동영상은 각 상응하는 컴포넌트를 이용하여 삽입해야 합니다. &lt;code&gt;&amp;lt;amp-iframe&amp;gt;&lt;/code&gt;으로만 치환하면 서비스 종류에 따라서 오류가 발생하기도 합니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;의 자식 요소로 사용되는 모든 요소(예: &lt;code&gt;input&lt;/code&gt;)는 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;안에서만 사용할 수 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;대부분의 AMP 디스플레이 요소에 사용할 수 있는 &lt;code&gt;layout&lt;/code&gt; 속성의 값으로 "responsive"를 이용하면 크기를 자동으로 계산해 줍니다.&lt;/li&gt;&#xD;
&lt;li&gt;AMP 디스플레이 요소의 필수 값인 &lt;code&gt;height&lt;/code&gt;와 &lt;code&gt;width&lt;/code&gt;속성의 단위는 픽셀이어야 합니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;amp-sidebar&amp;gt;&lt;/code&gt; 요소는 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 바로 하위에 위치해야 합니다.&lt;/li&gt;&#xD;
&lt;li&gt;확장 컴포넌트는 다양한 방법으로 응용할 수 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;어느 정도 마무리되면 &lt;a href="https://validator.ampproject.org/"&gt;웹 기반 유효성 검사기&lt;/a&gt;를 돌려봅니다.&lt;/li&gt;&#xD;
&lt;li&gt;끝으로 &lt;code&gt;&amp;lt;link rel="amphtml"&amp;gt;&lt;/code&gt; 태그를 고유 문서의 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;에 삽입하고 크롤링 당합니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;link rel="amphtml"&amp;gt;&lt;/code&gt; 태그의 값에는 원래 문서 주소의 규칙을 유지하는 것이 좋습니다.&lt;/li&gt;&#xD;
&lt;li&gt;서로 다른 고유주소를 가진 문서가 하나의 &lt;code&gt;&amp;lt;link rel="amphtml"&amp;gt;&lt;/code&gt; 주소를 가르키지 않도록 해야합니다. 오류가 두 달 이상 사라지지 않고 있네요.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;amp-pixel&amp;gt;&lt;/code&gt;을 이용하여 캐시에 저장된 페이지로 사용자가 접근하는 것을 모니터링 하거나 할 수 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;amp-iframe&amp;gt;&lt;/code&gt;에 삽입된 컨텐츠가 스크롤을 가지는 경우 나타나지 않을 수 있으며, 나타나지 않을 경우를 대비한 대체(placeholder) 이미지를 필요로 합니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;&amp;lt;amp-form&amp;gt;&lt;/code&gt;을 이용하여 검색이나 댓글 작성기능을 추가할 수 있습니다. 단, SSL이여야 하며, CORS 이슈까지 처리해야 정상적으로 작동합니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;
&lt;figure class="image-align"&gt;&lt;img src="https://firejune.com/attach/0807/160807204221483276/585757.png" width="640" height="167"  alt="Accelerated Mobile Pages.png" class="hasborder"&gt;&lt;br&gt;
&lt;figcaption class="cap1" &gt;Google Search Console(firejune.com) &gt; Search Appearance &gt; Accelerated Mobile Pages&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;모든 유효성 검사를 통과하고 크롤러가 문서를 긁어가면 &lt;a href="https://developers.google.com/amp/cache/overview"&gt;구글 AMP 캐시&lt;/a&gt;에 저장되고 그 결과를 위 그림처럼 서치 콘솔에서 확인할 수 있습니다. 그리고 일정 시간이 지나면 이후 부터 &lt;a href="https://www.google.co.kr/search?newwindow=1&amp;esrch=AcceleratedMobilePages%3A%3APreview%2CAcceleratedMobilePagesDesktop%3A%3APromo&amp;site=webhp&amp;source=hp&amp;ei=oZ6pV9vJOYyw0gT-gJ_YCg&amp;q=firejune.com+amp&amp;oq=&amp;gs_l=mobile-gws-hp.1.0.35i39l3.0.0.0.2958.2.1.1.0.0.0.0.0..0.0....0...1..64.mobile-gws-hp..2.1.11.3.qJq395APLwU"&gt;검색 결과에 노출&lt;/a&gt;되기 시작합니다. AMP 캐시 서버에 저장되는 대상은 HTML 문서와 포함된 이미지 파일이며 그외 정적인 파일은 SSL기반의 핫링크가 걸리게 되죠. 캐시된 문서는 다음과 같이 REST API를 이용하여 접근 하거나, 갱신됨을 알리(핑)거나, 캐시된 URL 목록을 호출하거나, 삭제요청을 직접적으로 수행할 수도 있습니다.&lt;/p&gt;
&lt;pre class="command"&gt;&lt;code&gt;# Request for an AMP HTML document&#xD;
GET https://cdn.ampproject.org/c/s/example.com/amp_document.html&#xD;
# Request for an image&#xD;
GET https://cdn.amproject.org/i/example.com/logo.png&#xD;
# Request an AMP URL&#xD;
POST https://acceleratedmobilepageurl.googleapis.com/v1/ampUrls:batchGet&#xD;
# Update ping&#xD;
GET https://cdn.ampproject.org/update-ping/c/s/ampbyexample.com&#xD;
# Remove AMP content&#xD;
GET https://cdn.ampproject.org/update-ping/i/s/example.com/favicon.ico&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;p&gt;Note: 캐시 상태를 신속하게 동기화 할 수 있는 수단이며, 일반적으로 크롤러가 알아서 하기 때문에 선택사양입니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;우와…. 이걸 다 언제 작업하나요…. 아…. 이 짓을 다시 한다는 것은 군대를 다시 들어가는 그런 느낌이군요. 그래서 조금이나마 도움을 드리고자 PHP로 작성한 Ampify 클래스를 공유합니다. 이 정적인 클래스는 &lt;a href="https://github.com/GeSHi/geshi-1.0"&gt;GeSHi&lt;/a&gt;라는 라이브러리를 이용하여 코드의 문법 강조 기능을 포함하고 있습니다. 응답이 많이 느려지지만 클라이언트에서 할 수 없으니 백-엔드에서 할 수밖에요. 나중에 확장 컴포넌트로 나오려나요? 어차피 기계가 방문할 페이지인데 좀 느려도 괜찮겠죠. 그리고 빠른 이미지 크기 추출을 위해 &lt;a href="https://github.com/tommoor/fastimage"&gt;fastimage.php&lt;/a&gt;를 필요로 합니다. 간단한 사용법은 &lt;code&gt;Ampify::content($html)&lt;/code&gt; 메서드를 호출하여 일반 HTML을 AMP로 변환합니다. 더 자세한 내용은 코드에 있습니다. ;)&lt;/p&gt;
&lt;pre class="php"&gt;&lt;code&gt;/**&#xD;
 * Ampify class&#xD;
 *&#xD;
 * @license MIT&#xD;
 * @author Firejune&#xD;
 * @version 0.4.19&#xD;
 */&#xD;
class Ampify {&#xD;
	// An var of list for source code syntax highlighting&#xD;
	private static $highlights = array();&#xD;
	// An var of list for extnend component loading&#xD;
	private static $components = array();&#xD;
	// Source code syntax highlight using GeSHi&#xD;
	private static function codeHelper($matches) {&#xD;
		require_once('lib/geshi/geshi.php');&#xD;
		$lang = str_replace('language-', '', $matches[1]);&#xD;
		$code = rtrim($matches[2]);&#xD;
		if ($lang == 'json' || $lang == 'jsx') $lang = 'javascript';&#xD;
		if ($lang == 'html' || $lang == 'markup') $lang = 'html5';&#xD;
		if ($lang == 'command') $lang = 'bash';&#xD;
		if (!in_array($lang, self::$highlights)) {&#xD;
			self::$highlights[] = $lang;&#xD;
		}&#xD;
		$geshi = new GeSHi(str_tag_on(strip_tags($code)), $lang);&#xD;
		$geshi-&amp;gt;enable_classes();&#xD;
		$code = $geshi-&amp;gt;parse_code();&#xD;
		$code = preg_replace('/&amp;lt;[ ]*pre( [^&amp;gt;]*)?&amp;gt;/i', '&amp;lt;pre$1&amp;gt;&amp;lt;code&amp;gt;', $code);&#xD;
		$code = preg_replace('/&amp;lt;\/pre&amp;gt;/i', '&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;', $code);&#xD;
		return self::fixClassName($code);&#xD;
	}&#xD;
	// Return defined styles of syntax highlight&#xD;
	private static function getCodeStyle() {&#xD;
		$geshi = new GeSHi;&#xD;
		$languages = self::$highlights;&#xD;
		foreach ($languages as $language) {&#xD;
			$file = $geshi-&amp;gt;language_path.$language.'.php';&#xD;
			if (!file_exists($file)) {&#xD;
				continue;&#xD;
			}&#xD;
			$geshi-&amp;gt;set_language($language);&#xD;
			$css .= preg_replace('/^\/\*\*.*?\*\//s', '', $geshi-&amp;gt;get_stylesheet(false));&#xD;
		}&#xD;
		return $css;&#xD;
	}&#xD;
	// Fix class names of syntax type&#xD;
	private static function fixClassName($code) {&#xD;
		$entities =     array('class="command"', 'class="html"',  'class="json"',       'class="jsx"');&#xD;
		$replacements = array('class="bash"',    'class="html5"', 'class="javascript"', 'class="javascript"');&#xD;
		return str_replace($entities, $replacements, $code);&#xD;
	}&#xD;
	// Retrun Accepted HTML5 tags and AMP components&#xD;
	private static function getAllowTags() {&#xD;
		$html = '&amp;lt;h1&amp;gt;&amp;lt;h2&amp;gt;&amp;lt;h3&amp;gt;&amp;lt;h4&amp;gt;&amp;lt;h5&amp;gt;&amp;lt;h6&amp;gt;&amp;lt;a&amp;gt;&amp;lt;p&amp;gt;&amp;lt;ul&amp;gt;&amp;lt;ol&amp;gt;&amp;lt;li&amp;gt;&amp;lt;blockquote&amp;gt;&amp;lt;q&amp;gt;&amp;lt;cite&amp;gt;&amp;lt;ins&amp;gt;&amp;lt;del&amp;gt;&amp;lt;strong&amp;gt;'&#xD;
			.'&amp;lt;em&amp;gt;&amp;lt;code&amp;gt;&amp;lt;pre&amp;gt;&amp;lt;svg&amp;gt;&amp;lt;table&amp;gt;&amp;lt;thead&amp;gt;&amp;lt;tbody&amp;gt;&amp;lt;tfoot&amp;gt;&amp;lt;th&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;dl&amp;gt;&amp;lt;dt&amp;gt;&amp;lt;dd&amp;gt;&amp;lt;article&amp;gt;'&#xD;
			.'&amp;lt;section&amp;gt;&amp;lt;header&amp;gt;&amp;lt;footer&amp;gt;&amp;lt;aside&amp;gt;&amp;lt;figure&amp;gt;&amp;lt;figcaption&amp;gt;&amp;lt;time&amp;gt;&amp;lt;abbr&amp;gt;&amp;lt;div&amp;gt;&amp;lt;span&amp;gt;&amp;lt;hr&amp;gt;&amp;lt;br&amp;gt;'&#xD;
			.'&amp;lt;kbd&amp;gt;&amp;lt;u&amp;gt;&amp;lt;b&amp;gt;&amp;lt;i&amp;gt;&amp;lt;s&amp;gt;&amp;lt;small&amp;gt;&amp;lt;caption&amp;gt;&amp;lt;address&amp;gt;&amp;lt;button&amp;gt;&amp;lt;source&amp;gt;';&#xD;
		$amp = '&amp;lt;amp-embed&amp;gt;&amp;lt;amp-img&amp;gt;&amp;lt;amp-pixel&amp;gt;&amp;lt;amp-video&amp;gt;&amp;lt;amp-audio&amp;gt;&amp;lt;amp-anim&amp;gt;&amp;lt;amp-iframe&amp;gt;&amp;lt;amp-fit-text&amp;gt;'&#xD;
			.'&amp;lt;amp-access&amp;gt;&amp;lt;amp-font&amp;gt;&amp;lt;amp-slides&amp;gt;&amp;lt;amp-ad&amp;gt;&amp;lt;amp-list&amp;gt;&amp;lt;amp-live-list&amp;gt;&amp;lt;amp-social-share&amp;gt;'&#xD;
			.'&amp;lt;amp-lightbox&amp;gt;&amp;lt;amp-carousel&amp;gt;&amp;lt;amp-accordion&amp;gt;&amp;lt;amp-youtube&amp;gt;&amp;lt;amp-vimeo&amp;gt;';&#xD;
		return $html.$amp;&#xD;
	}&#xD;
	// Ignoring not allowed attribute of AMP for all tags.&#xD;
	private static function ignoreHelper($m) {&#xD;
		$tag = $m[0];&#xD;
		$attributes = $m[2];&#xD;
		preg_match_all('/([\w-]+)\s*(?:=\s*(?:"([^"]*)"|\'([^\']*)\'|(\w*[^\s&amp;gt;]*)))?/usix', $attributes, $matches);&#xD;
		foreach ($matches[1] as $key =&amp;gt; $val) {&#xD;
			$attr = $matches[2][$key];&#xD;
			if (!$attr) $attr = $matches[3][$key];&#xD;
			if (!$attr) $attr = $matches[4][$key];&#xD;
			if ($val == 'href' &amp;amp;&amp;amp; strpos($attr, 'javascript:') !== false) {&#xD;
				$tag = str_replace($attr, '#', $tag);&#xD;
			}&#xD;
			if (preg_match('/^(on(click|mousedown|mouseup|mousemove|mouseout|mouseover|load)|style|summary)/i', $val)) {&#xD;
				$tag = str_replace($matches[0][$key], '', $tag);&#xD;
			}&#xD;
		}&#xD;
		return $tag;&#xD;
	}&#xD;
	// An helper for image tag&#xD;
	private static function imageHelper($m) {&#xD;
		$attr = $m[1];&#xD;
		$args = array();&#xD;
		preg_match_all('/([\w-]+)\s*(?:=\s*(?:"([^"]*)"|\'([^\']*)\'|(\w*[^\s&amp;gt;]*)))?/usix', $attr, $matches);&#xD;
		# Allowed attr of &amp;lt;amp-img&amp;gt;&#xD;
		foreach ($matches[1] as $key =&amp;gt; $val) {&#xD;
			if (preg_match('/(src|srcset|layout|heights?|alt|role|on|tabindex|placeholder|widths?|data-*|type|class)/i', $val)) {&#xD;
				$attr = $matches[2][$key];&#xD;
				if (!$attr) $attr = $matches[3][$key];&#xD;
				if (!$attr) $attr = $matches[4][$key];&#xD;
				$args[$val] = $attr;&#xD;
			}&#xD;
		}&#xD;
		if (!$args['layout']) {&#xD;
			$args['layout'] = 'responsive';&#xD;
		}&#xD;
		if (strpos($args['width'], '%') !== false) {&#xD;
			$args['width'] = 0;&#xD;
		}&#xD;
		if (strpos($args['height'], '%') !== false) {&#xD;
			$args['height'] = 0;&#xD;
		}&#xD;
		if (!$args['width'] || !$args['height']) {&#xD;
			require_once('lib/fastimage.php');&#xD;
			$src = $args['src'];&#xD;
			if (preg_match('/\/\/(m\.)?firejune(\.cafe24)?.com/i', $src)) {&#xD;
				$src = preg_replace('/https?:\/\/(m\.)?firejune(\.cafe24)?.com/i', '', $src);&#xD;
			}&#xD;
			$src = preg_replace('/^\.\.?\//', '/', $src);&#xD;
			if (!preg_match('/(https?:)?\/\/[^\/]+\//i', $src) &amp;amp;&amp;amp; preg_match('/^\/images\//i', $src)) {&#xD;
				$src = '/public'.$src;&#xD;
			}&#xD;
			if (strpos($src, '/public/images/') === 0) {&#xD;
				$args['layout'] = 'fixed';&#xD;
			}&#xD;
			$img = new FastImage('./'.$src);&#xD;
			$size = $img-&amp;gt;getSize();&#xD;
			if ($args['width']) {&#xD;
				$args['height'] = intval($size[1] / $size[0] * $args['width'], 10);&#xD;
			} elseif($args['height']) {&#xD;
				$args['width'] = intval($size[0] / $size[1] * $args['height'], 10);&#xD;
			} else {&#xD;
				$args['width'] = $size[0];&#xD;
				$args['height'] = $size[1];&#xD;
			}&#xD;
		}&#xD;
		if ($args['width'] &amp;lt; 240 &amp;amp;&amp;amp; $args['height'] &amp;lt; 240) {&#xD;
			$args['layout'] = 'fixed';&#xD;
		}&#xD;
		if (!$args['src'] || !$args['width'] || !$args['height']) {&#xD;
			return '';&#xD;
		}&#xD;
		$attr = '';&#xD;
		foreach ($args as $key =&amp;gt; $val) {&#xD;
			$attr .= ' '.$key.'="'.$val.'"';&#xD;
		}&#xD;
		return '&amp;lt;amp-img'.$attr.'&amp;gt;&amp;lt;/amp-img&amp;gt;';&#xD;
	}&#xD;
	// An helper for video tag&#xD;
	private static function videoHelper($m) {&#xD;
		$tag = $m[0];&#xD;
		$src = $m[1];&#xD;
		$tag = preg_replace('/&amp;lt;amp-video(.*?)&amp;gt;/', '&amp;lt;amp-video$1 layout="responsive"&amp;gt;', $tag);&#xD;
		return str_replace($src, strip_tags($src, '&amp;lt;source&amp;gt;'), $tag);&#xD;
	}&#xD;
	// An helper for iframe tag&#xD;
	private static function iframeHelper($m) {&#xD;
		$tag = $m[0];&#xD;
		$src = $m[1];&#xD;
		preg_match('/&amp;lt;iframe.*width="([^"]\d+)".*height="([^"]\d+)".*&amp;gt;/', $tag, $m);&#xD;
		$width = $m[1];&#xD;
		$height = $m[2];&#xD;
		# amp-youtube&#xD;
		if (preg_match("/^(?:http(?:s)?:)?\/\/(?:www\.)?(?:m\.)?(?:youtu\.be\/|youtube\.com\/(?:(?:watch)?\?(?:.*&amp;amp;)?v(?:i)?=|(?:embed|v|vi|user)\/))([^\?&amp;amp;\"'&amp;gt;]+)/", $src, $id)) {&#xD;
			return '&amp;lt;amp-youtube data-videoid="'.$id[1].'" layout="responsive" width="'.$width.'" height="'.$height.'"&amp;gt;&amp;lt;/amp-youtube&amp;gt;';&#xD;
		}&#xD;
		# amp-vimeo&#xD;
		if (preg_match('/(https?:\/\/)?(www\.)?(player\.)?vimeo\.com\/([a-z]*\/)*([‌​0-9]{6,11})[?]?.*/', $src, $id)) {&#xD;
			return '&amp;lt;amp-vimeo data-videoid="'.$id[5].'" layout="responsive" width="'.$width.'" height="'.$height.'"&amp;gt;&amp;lt;/amp-vimeo&amp;gt;';&#xD;
		}&#xD;
		# amp-iframe&#xD;
		return '&amp;lt;amp-iframe src="'.$src.'" width="'.$width.'" height="'.$height.'" sandbox="allow-scripts" layout="responsive" class="bdr1" frameborder="0"&amp;gt;&amp;lt;/amp-iframe&amp;gt;';&#xD;
	}&#xD;
	// Add using AMP extend compoenent to list&#xD;
	public static function add($component) {&#xD;
		if (is_array($component)) {&#xD;
			$component = 'amp-'.$component[1];&#xD;
		}&#xD;
		if (!in_array($component, self::$components)) {&#xD;
			self::$components[] = $component;&#xD;
		}&#xD;
	}&#xD;
	// Convert contents to AMP compoents&#xD;
	public static function content($html) {&#xD;
  	$html = self::html($html);&#xD;
		$html = self::html($html);&#xD;
		# Remove unnecessary tags&#xD;
		$html = preg_replace('/&amp;lt;(script|style).*?&amp;lt;\/\1&amp;gt;/s', '', $html);&#xD;
		# Replace iframe tag to AMP component&#xD;
		$html = preg_replace_callback('#&amp;lt;iframe.*?src="([^"]*)".*?[^&amp;gt;]*&amp;gt;.*?&amp;lt;/iframe&amp;gt;#si', 'ampify::iframeHelper', $html);&#xD;
		# Reduce ignore attributes&#xD;
		$html = preg_replace_callback('/&amp;lt;([\w-]+) ([^&amp;gt;]*)?&amp;gt;/si', 'ampify::ignoreHelper', $html);&#xD;
		# Code syntax hightlight&#xD;
		$html = preg_replace_callback('#&amp;lt;pre.*?class="([^"]*)".*?[^&amp;gt;]*&amp;gt;&amp;lt;code&amp;gt;(.*?)?&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;#is', 'ampify::codeHelper', $html);&#xD;
		# Whitelist of HTML tags allowed by AMP&#xD;
		$html = strip_tags($html, self::getAllowTags());&#xD;
		# Dynamic load amp components&#xD;
		preg_replace_callback('/&amp;lt;\/amp-(youtube|vimeo|iframe|accordion|carousel)&amp;gt;/', 'ampify::add', $html);&#xD;
		return $html;&#xD;
	}&#xD;
	// Convert generic HTML to AMP&#xD;
	public static function html($html) {&#xD;
		# Replace img, audio, and video elements with amp custom elements&#xD;
		$html = str_ireplace(&#xD;
			array('&amp;lt;img', '&amp;lt;video', '/video&amp;gt;', '&amp;lt;audio', '/audio&amp;gt;'),&#xD;
			array('&amp;lt;amp-img', '&amp;lt;amp-video', '/amp-video&amp;gt;', '&amp;lt;amp-audio', '/amp-audio&amp;gt;'),&#xD;
			$html&#xD;
		);&#xD;
		# Add amp attribute to html tag&#xD;
		$html = preg_replace("/&amp;lt;[ ]*html( [^&amp;gt;]*)?&amp;gt;/i", '&amp;lt;html amp$1&amp;gt; ', $html);&#xD;
		# Fix display amp custom elements&#xD;
		$html = preg_replace_callback('/&amp;lt;amp-img(.*?)\/?&amp;gt;/', 'ampify::imageHelper', $html);&#xD;
		$html = preg_replace_callback('#&amp;lt;amp-video.*?[^&amp;gt;]*&amp;gt;(.*?)?&amp;lt;/amp-video&amp;gt;#is', 'ampify::videoHelper', $html);&#xD;
		return $html;&#xD;
	}&#xD;
	// Return stylesheets string from files&#xD;
	public static function css($path, $name) {&#xD;
		$css = file_get_contents($path.$name.'/css/master.css');&#xD;
		$css .= file_get_contents($path.$name.'/css/article.css');&#xD;
		$css .= file_get_contents($path.$name.'/css/responsive.css');&#xD;
		if (!empty(self::$highlights)) {&#xD;
			$css .= self::getCodeStyle();&#xD;
		}&#xD;
		return $css;&#xD;
	}&#xD;
	// Return extended components when it using&#xD;
	public static function js() {&#xD;
		foreach (self::$components as $component) {&#xD;
			$js .= '&amp;lt;script async custom-element="'.$component.'" src="https://cdn.ampproject.org/v0/'.$component.'-0.1.js"&amp;gt;&amp;lt;/script&amp;gt;';&#xD;
		}&#xD;
		return $js;&#xD;
	}&#xD;
}&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;p&gt;Note: 이곳의 사정에 맞게 코딩된 것으로, 모든 곳에서 작동한다는 보장은 못합니다. 참고용으로만 이용해 주세요.. :(&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;끝으로, 반가운 소식입니다. &lt;a href="https://www.ampproject.org/ko/docs/get_started/about-amp.html"&gt;AMP 프로젝트 페이지의 한글화&lt;/a&gt; 작업이 진행 중이군요! 필독을 권장합니다. 그럼, 화이팅!&lt;/p&gt;

			&lt;br&gt;&lt;br&gt;
			&lt;a href="https://firejune.com/1800#p1800"&gt;Comments&lt;/a&gt; |
			&lt;a href="https://firejune.com/1800"&gt;Hits(150,674)&lt;/a&gt;&lt;img src="http://feeds.feedburner.com/~r/firejune/~4/NWhfrpSjado" height="1" width="1" alt=""/&gt;</content><feedburner:origLink>https://firejune.com/1800</feedburner:origLink></entry><entry><title type="text">2016 검색엔진 최적화 프롤로그</title><link rel="alternate" type="text/html" href="http://feedproxy.google.com/~r/firejune/~3/VSHJcAEiwEU/1799" /><category term="자료-웹개발" /><category term="AMP" /><category term="프로젝트" /><category term="구글" /><category term="SEO" /><category term="모바일" /><category term="검색엔진" /><category term="서치 콘솔" /><category term="구글봇" /><category term="크롤러" /><category term="모바일 친화적" /><category term="테스트" /><category term="Cafe24 병크" /><category term="호스팅 바꿔야지" /><category term="페이지가 모바일에 적합하지 않습니다." /><category term="최적화" /><category term="PageRank" /><author><name>파이어준</name></author><updated>2016-08-06T14:10:20-07:00</updated><id>https://firejune.com/1799</id><content type="html">&lt;p&gt;스마트폰에서 구글 검색을 하던 중 수년간을 버리다시피 하던 이곳의 컨텐츠가 검색 결과에 노출되었습니다. 그런데, “페이지가 모바일에 적합하지 않습니다.”라는 메시지가 뜨더군요? 이 문구는 모바일 사용환경에서 구글 웹 검색을 이용하는 경우 사용자에게 경고성으로 알리는 내용 같았습니다. 뭔가, 기분이 썩 좋지는 않습니다만, 신기하기도 하죠. 지가 뭔데 그런 심판(?)을 내리는지 말예요. 그동안 구글 검색이 무슨 짓거리를 했는지에 대하여 대략 살펴보았습니다. &lt;/p&gt;
&lt;p&gt;2014년부터 구글 검색 크롤러가 &lt;a href="https://webmasters.googleblog.com/2014/10/updating-our-technical-webmaster.html"&gt;더욱 똑똑해져&lt;/a&gt;서 페이지에 포함된 스타일시트와 자바스크립트가 컨텐츠에 영향을 끼치는 여부를 인지합니다. 다시 말해, 자바스크립트에 의해 생성된 내용도 검색 결과에 노출될 수 있으며, CSS에 의해 숨겨놓은 컨텐츠는 검색 대상에서 제외하는 등의 장치를 마련한 것입니다. &lt;a href="https://www.google.com/webmasters/tools/home?hl=ko"&gt;구글 서치 콘솔(구글 웹마스터 도구)&lt;/a&gt;에서 Fetch As Google에 “가져오기 및 렌더링”을 요청하면  “Googlebot에게 페이지가 다음과 같이 보입니다.” 라면서 마치 눈이라도 달라준 것 마냥 렌더링된 페이지를 보여줍니다. 이와 동시에 2009년에 추가된 &lt;a href="https://webmasters.googleblog.com/2015/10/deprecating-our-ajax-crawling-scheme.html"&gt;AJAX crawling scheme는 Deprecated&lt;/a&gt; 되었고요.&lt;/p&gt;
&lt;p&gt;2015년에는 모바일 환경에서 웹사이트를 이용하는 것이 &lt;a href="https://webmasters.googleblog.com/2015/04/mobilemadness-campaign-to-help-you-go.html"&gt;병맛이라며 캠페인&lt;/a&gt;을 하더니, 모바일 전용 봇(크롤러)을 별도로 운영하면서 구림과 구리지 않음을 스스로 판단하기에 이릅니다. 그리고는 "&lt;a href="https://developers.google.com/webmasters/mobile-sites/?hl=ko"&gt;모바일에 친화적&lt;/a&gt;이지 않으면 모바일 검색 결과에 안 좋은 영향을 미치게 될 것"이라면서 &lt;a href="https://webmasters.googleblog.com/2016/05/a-new-mobile-friendly-testing-tool.html"&gt;테스트 도구&lt;/a&gt;를 달랑 하나 던져주고 시험에 통과할 것을 강제합니다.&lt;/p&gt;
&lt;figure class="image-align"&gt;&lt;img src="https://firejune.com/attach/0807/160807022700198043/447569.png" width="640" height="163"  alt="mobile-usability.png" class="hasborder"&gt;&lt;br&gt;
&lt;figcaption class="cap1" &gt;Google Search Console(firejune.com) &gt; Search Traffic &gt; Mobile Usability&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;노트:&lt;/strong&gt; 모바일 친화성 테스트에 통과하려면 &lt;a href="https://developers.google.com/speed/pagespeed/insights/"&gt;구글페이지 스피드 인사이트&lt;/a&gt; 모바일 섹션에서 제공하는 가이드라인에 맞게 사이트를 수정하고, 사용자 환경 점수를 80점 이상 받아야 통과되며, 디바이스 기준은 &lt;a href="https://support.google.com/webmasters/answer/1061943"&gt;안드로이드 6.0.1 넥서스5X(Build/MMB29P)&lt;/a&gt;입니다. 수정 후 반영까지 규모에 따라 다르겠지만, 최소 한 주 정도 소요되는 것으로 보입니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;그리고 2016년에는 PageRank 점수를 더이상 공개하지 않기로 합니다. 이 점수는 내부적으로만 사용될 것이라고 했습니다. 여러가지 이유가 있지만 이 점수 체계를 이용한 악용 사례를 원천적으로 차단하기 위한 것으로 판단됩니다. 또한 &lt;a href="https://www.ampproject.org/"&gt;구글 AMP(Accelerated Mobile Pages)&lt;/a&gt;라는 프로젝트를 &lt;a href="https://webmasters.googleblog.com/2016/01/amp-error-report-preview-in-search.html"&gt;서치 콘솔에 집어넣고&lt;/a&gt; 자기들 검색 결과에 &lt;a href="https://webmasters.googleblog.com/2016/08/amp-your-content-preview-of-amped.html"&gt;색다른 출력 방법&lt;/a&gt;을 꾀하려고 합니다. 이 프로젝트는 이름에서 알 수 있듯이 모바일에서 웹 컨텐츠를 더욱 빠르고 쉽게 접근할 수 있도록 하자는 목표를 가진 구글의 프로젝트입니다. 자세한 내용을 &lt;a href="http://www.usefulparadigm.com/2016/02/24/adding-the-google-amp-to-mobile-website/"&gt;유스풀패러다임&lt;/a&gt;에서 잘 정리해 주셨네요.&lt;/p&gt;
&lt;p&gt;제가 이해한 바로는, "당신들이 만든 사이트는 하나같이 전부 거지 같으니, 우리가 제시하는 &lt;a href="https://www.ampproject.org/docs/reference/spec.html"&gt;지침&lt;/a&gt;대로 다시 만들어서 제출하면 사용자들은 엄청나게 빠르고 편리한 모바일 사용경험을 누리게 될 거고, 당신은 트래픽 비용을 절감할 수 있을 거예요."라는 것인데, 여기서 빠르고 편리하다는 의미는 사용자가 검색 결과를 클릭했을 때 사용자의 사이트로 직접 연결하지 않고 AMP 캐시로부터 컨텐츠를 불러와 검색 사이트 내에서 보여주는 것을 말하는 것입니다. 아웃바운드 링크를 인바운드 링크로 둔갑시켜 사용자가 구글 사이트를 떠나지 못하게 잡아두겠다는 의미로도 해석되지요. 또한, &lt;a href="https://developers.google.com/amp/cache/"&gt;AMP 캐시에 저장된 데이터&lt;/a&gt;는 아무런 조건 없이 누구나 사용할 수 있게 될 것이랍니다. 즉 페이스북이나 트위터와 같은 곳에서도 같은 목적으로 사용할 수 있게 된다는 뜻이고요. &lt;/p&gt;
&lt;p&gt;AMP 지침을 살짝 들여다보면 모바일 친화적인 건 기본이고 AMP에서 제시하는 태그를 사용할 것, 허용하지 않는 속성은 사용하지 말 것, 사용자가 작성한 자바스크립트 쓰지 말 것, 스타일시트는 적정량의 인라인으로 넣을 것 등 &lt;a href="https://www.ampproject.org/docs/reference/validation_errors.html"&gt;수십 가지 유효성 규칙&lt;/a&gt;이 존재하며 &lt;a href="https://validator.ampproject.org/"&gt;검사를 통과&lt;/a&gt;해야 합니다. &lt;/p&gt;
&lt;figure class="image-align"&gt;&lt;img src="https://firejune.com/attach/0807/160807022700198043/968142.png" width="640" height="160"  alt="accelerated-mobile-pages.png" class="hasborder"&gt;&lt;br&gt;
&lt;figcaption class="cap1" &gt;Google Search Console(firejune.com) &gt; Search Appearance &gt; Accelerated Mobile Pages&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;도대체 얼마나 빨라진다는 건지 궁금하기도 하고, 대략 이 정도면 서로 도움되는 그림인 것 같아 그냥 적용해 보기로 한 것입니다. 그래프에서 알 수 있듯이 작업을 시작한 시점이 약 두 달 전입니다. 당시 아래와 같은 백로그를 작성하고 짬짬이 수행했고요. 지금은 모두 완료된 상태입니다. 원래  AMP를 적용하는 과정에 대한 기술적 내용을 다루려고 했으나 뻘소리만 늘어놓는 바람에 프롤로그만 작성했습니다. 다음번에 별도로 AMP 적용기를 작성하도록 하겠습니다.&lt;/p&gt;
&lt;blockquote&gt;&lt;ul class="square"&gt;&#xD;
&lt;li&gt;오류가 발생하는 구조화된 데이터 모두 수정&lt;/li&gt;&#xD;
&lt;li&gt;구조화된 데이터에 Breadcrumbs, Searchbox 추가&lt;/li&gt;&#xD;
&lt;li&gt;구글 서치 콘솔의 모바일 사용 편의성에 보고된 오류 모두 수정&lt;/li&gt;&#xD;
&lt;li&gt;액셀러레이티드 모바일 페이지 지원&lt;/li&gt;&#xD;
&lt;li&gt;모바일 사이트 별도 제공(Cafe24에서 제공하는 기능은 Path를 잘라 먹음)&lt;/li&gt;&#xD;
&lt;li&gt;Cafe24에서 UDP소켓 막아버림, Node서버를 이용한 Twitter 연동&lt;/li&gt;&#xD;
&lt;li&gt;로그인 페이지 개구림&lt;/li&gt;&#xD;
&lt;li&gt;PDF 모바일에서 깨짐&lt;/li&gt;&#xD;
&lt;li&gt;서버-사이드 문법강조기 추가&lt;/li&gt;&#xD;
&lt;li&gt;SSL 적용(미친 Cafe24 SSL 포트를 48408 이렇게 주면 어떻게 쓰라는 거야?)&lt;/li&gt;&#xD;
&lt;li&gt;HTTP/2 + SPDY 적용&lt;/li&gt;&#xD;
&lt;li&gt;당분간 Non SSL을 위한 CORS 구현&lt;/li&gt;&#xD;
&lt;li&gt;PQP 프로파일러 붙여서 SQL 및 코드 성능개선&lt;/li&gt;&#xD;
&lt;/ul&gt;&lt;/blockquote&gt;

			&lt;br&gt;&lt;br&gt;
			&lt;a href="https://firejune.com/1799#p1799"&gt;Comments&lt;/a&gt; |
			&lt;a href="https://firejune.com/1799"&gt;Hits(110,949)&lt;/a&gt;&lt;img src="http://feeds.feedburner.com/~r/firejune/~4/VSHJcAEiwEU" height="1" width="1" alt=""/&gt;</content><feedburner:origLink>https://firejune.com/1799</feedburner:origLink></entry><entry><title type="text">초보자용 Webpack 튜토리얼 파트1 - Webpack 입문</title><link rel="alternate" type="text/html" href="http://feedproxy.google.com/~r/firejune/~3/84_rgyWDtks/1798" /><category term="자료-웹개발" /><category term="Webpack" /><category term="자바스크립트" /><category term="프로젝트" /><category term="HMR" /><category term="LESS" /><category term="SCSS" /><category term="CSS" /><category term="HTML" /><category term="ES6" /><category term="ES7" /><category term="React" /><category term="번역" /><category term="튜토리얼" /><author><name>파이어준</name></author><updated>2016-02-16T00:21:25-08:00</updated><id>https://firejune.com/1798</id><content type="html">&lt;p&gt;&lt;a href="https://github.com/AriaFallah"&gt;Aria Fallah&lt;/a&gt;씨는 &lt;a href="https://webpack.github.io/"&gt;Webpack&lt;/a&gt;을 시작하기가 쉽지만은 않았다고 합니다. 그래서 친절하고 개괄적인 초보자용 &lt;a href="https://github.com/AriaFallah/WebpackTutorial/tree/master/part1"&gt;Webpack 입문서&lt;/a&gt;를 만들었습니다. 그는 이 튜토리얼을 통해 Webpack의 사용법을 쉽게 배울 수 있기를 바란다고 했습니다.&lt;/p&gt;
&lt;h2&gt;&lt;a href="#webpack을-왜-사용하나요"&gt;1-1&lt;/a&gt;. Webpack을 왜 사용하나요?&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;여기에 Webpack을 사용해야 할 몇 가지 현실적인 이유가 있습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;하나의 파일로 js 파일을 번들할 수 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;프론트엔드 코드에 npm 패키지를 사용할 수 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;ES6/ES7 자바스크립트 코드를 작성할 수 있습니다. (Babel을 이용하여)&lt;/li&gt;&#xD;
&lt;li&gt;코드를 압축 또는 최적화할 수 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;LESS/SCSS를 CSS로 돌릴 수 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;HMR(Hot Module Replacement)을 사용할 수 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;자바스크립트로 모든 유형의 파일을 포함할 수 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;이 글에서 다루지 못한 아주 많은 고급기능이 있습니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&#xD;
&lt;h3&gt;왜 이러한 기능이 필요한가요?&lt;/h3&gt;&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;js 파일 번들 - 자바스크립트를 모듈로 작성할 수 있습니다, 그래서 각각의 파일에 대해서 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&#xD;
태그를 별도로 작성할 필요가 없습니다. (상황에 따라서 둘 이상의 js 파일이 필요한 경우 구성 가능함)&lt;/li&gt;&#xD;
&lt;li&gt;npm 패키지 사용 - npm은 인터넷상에서 오픈소스 코드의 커다란 생태계입니다.&#xD;
npm 코드를 저장할 기회가 주어지며, 원하는 프론트엔드 패키지를 가져다 쓸 수 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;ES6/ES7 - 많은 기능을 추가되어 더 강력하고 더 쉽게 자바스크립트를 작성할 수 있습니다.&#xD;
&lt;a href="https://github.com/DrkSephy/es6-cheatsheet"&gt;여기에 소개하는 글&lt;/a&gt;이 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;코드 압축/최적화 - 배포되는 파일의 크기를 줄입니다. 페이지 로딩이 빨라지는 등의 장점을 포함합니다.&lt;/li&gt;&#xD;
&lt;li&gt;LESS/SCSS를 CSS로 돌리기 - CSS를 작성하는 더 좋은 방법입니다.&#xD;
&lt;a href="http://alistapart.com/article/why-sass"&gt;여기에 소개하는 글&lt;/a&gt;이 있습니다.&lt;/li&gt;&#xD;
&lt;li&gt;HMR 사용 - 생산성이 향상됩니다. 코드를 저장할 때 마다 페이지의 리프레시가 자동으로 이루어집니다.&#xD;
코드를 작성하는 동안 페이지의 상태를 최신으로 유지해야 하는 경우 정말 편리합니다.&lt;/li&gt;&#xD;
&lt;li&gt;자바스크립트로 모든 유형의 파일을 포함 - 추가적인 빌드 도구의 수를 줄일 수 있고,&#xD;
프로그램적으로 파일을 사용 및 수정할 수 있습니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&#xD;
&lt;h2&gt;&lt;a href="#기본-익히기"&gt;1-2&lt;/a&gt;. 기본 익히기&lt;/h2&gt;&#xD;
&#xD;
&lt;h3&gt;&lt;a href="#설치하기"&gt;1-2-1&lt;/a&gt;. 설치하기&lt;/h3&gt;&#xD;
&#xD;
&lt;p&gt;Webpack의 모든 기능을 사용하려면 전역으로 설치해야 합니다:&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;npm install -g webpack&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;그러나 Webpack의 일부 기능이나 최적화 플러그인 정도만 필요한 경우라면 로컬에 설치합니다:&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;npm install --save-dev webpack&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;h3&gt;실행 명령&lt;/h3&gt;&#xD;
&#xD;
&lt;p&gt;Webpack을 실행하려면:&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;webpack&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;Webpack에서 파일의 상태가 변경되면 자동으로 빌드하려는 경우:&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;webpack --watch&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;특정한 이름의 사용자가 정의한 Webpack 설정 파일을 사용하려면:&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;webpack --config myconfig.js&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;h3&gt;&lt;a href="#번들하기"&gt;1-2-2&lt;/a&gt;. 번들하기&lt;/h3&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a href="https://github.com/firejune/WebpackTutorial/tree/master/example1"&gt;예제 1&lt;/a&gt;&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;&lt;img src="https://firejune.com/attach/0216/160216145047818365/385977.png" width="640" height="320" alt="Official Dependency Tree" &gt;&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;Webpack은 공식적으로 모듈 번들러라고 합니다.&#xD;
다음의 두 가지 훌륭한 글은 모듈 액세스에 대한 깊이 있는 설명과 명확한 모듈 번들링에 대하여 다루고 있습니다:&#xD;
&lt;a href="https://medium.freecodecamp.com/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#.jw1txw6uh"&gt;이것&lt;/a&gt;&#xD;
과 &lt;a href="https://medium.com/@preethikasireddy/javascript-modules-part-2-module-bundling-5020383cf306#.lfnspler2"&gt;이것&lt;/a&gt;.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;간단하게 봅시다. 작동시키는 방법은 하나의 파일을 진입점으로 지정하는 것입니다.&#xD;
이 파일은 트리의 루트가 될 것입니다. 그러면 &lt;code&gt;require&lt;/code&gt;에 의해 다른 파일이 트리에 추가됩니다.&#xD;
&lt;code&gt;webpack&lt;/code&gt; 명령을 실행하면, 모든 파일과 모듈은 하나의 파일에 번들로 제공됩니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;다음은 간단한 예제입니다:&lt;/p&gt;&#xD;
&#xD;
&lt;p class="box1"&gt;&lt;img src="https://firejune.com/attach/0216/160216145047818365/991919.png" width="603" height="273" alt="Dependency Tree" &gt;&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;이 그림은 다음과 같은 디렉터리 구조를 가진다고 가정합니다:&lt;/p&gt;&#xD;
&#xD;
&lt;pre&gt;&lt;code&gt;MyDirectory&#xD;
|- index.js&#xD;
|- UIStuff.js&#xD;
|- APIStuff.js&#xD;
|- styles.css&#xD;
|- extraFile.js&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;이것은 파일의 내용입니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// index.js&#xD;
require('./styles.css')&#xD;
require('./UIStuff.js')&#xD;
require('./APIStuff.js')&#xD;
&#xD;
// UIStuff.js&#xD;
var React = require('React')&#xD;
React.createClass({&#xD;
  // stuff&#xD;
})&#xD;
&#xD;
// APIStuff.js&#xD;
var fetch = require('fetch') // fetch polyfill&#xD;
fetch('https://google.com')&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;pre class="css"&gt;&lt;code&gt;/* styles.css */&#xD;
body {&#xD;
  background-color: rgb(200, 56, 97);&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt; 명령을 실행하면, 이 트리의 내용을 번들로 얻을 수 있겠지만,&#xD;
같은 디렉터리에 있는 &lt;code&gt;extraFile.js&lt;/code&gt;는 &lt;code&gt;require&lt;/code&gt;에 참조되지 않았기 때문에&#xD;
결코 번들의 일부가 되지 않습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;bundle.js&lt;/code&gt;는 다음과 같이 표시됩니다:&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// contents of styles.css&#xD;
// contents of UIStuff.js + React&#xD;
// contents of APIStuff.js + fetch&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;즉, 번들로 제공되는 것들은 파일의 참조를 통한 경우의 것들입니다.&lt;/p&gt;&#xD;
&#xD;
&lt;h3&gt;&lt;a href="#로더란"&gt;1-2-3&lt;/a&gt;. 로더란?&lt;/h3&gt;&#xD;
&#xD;
&lt;p&gt;이미 눈치챘겠지만, 위의 예제에서 이상한 일을 저질렀습니다.&#xD;
바로 CSS 파일을 자바스크립트 파일에 &lt;code&gt;require&lt;/code&gt;를 사용한 것입니다. 이것은 정말 멋집니다, Webpack의 흥미로운 점은&#xD;
&lt;code&gt;require&lt;/code&gt;에 자바스크립트 파일 말고도 다른 것을 더 할 수 있다는 것입니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;Webpack에는 로더라는 것이 있습니다.&#xD;
이 로더를 사용하면, &lt;code&gt;require&lt;/code&gt;를 이용하여 &lt;code&gt;.css&lt;/code&gt;와 &lt;code&gt;.html&lt;/code&gt;, &lt;code&gt;.png&lt;/code&gt; 등을 불러올 수 있습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;위 그림의 예를 들어 보겠습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// index.js&#xD;
require('./styles.css')&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;Webpack의 구성에 &lt;a href="https://github.com/webpack/style-loader"&gt;스타일-로더&lt;/a&gt;와&#xD;
&lt;a href="https://github.com/webpack/css-loader"&gt;CSS-로더&lt;/a&gt;를 포함하는 경우,&#xD;
이것은 단지 완전히 유효하지만 않을 뿐, 실제로는 페이지에 CSS를 적용하게 됩니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;이것은 Webpack과 함께 사용할 수 있는 수많은 로더들 중 하나의 사용 예제일 뿐입니다.&lt;/p&gt;&#xD;
&#xD;
&lt;h3&gt;&lt;a href="#플러그인"&gt;1-2-4&lt;/a&gt;. 플러그인&lt;/h3&gt;&#xD;
&#xD;
&lt;p&gt;플러그인은 이름에서 알 수 있듯이, Webpack에 사용할 수 있는 추가 기능입니다.&#xD;
자주 사용하는 플러그인 중 하나는 &lt;code&gt;UglifyJsPlugin&lt;/code&gt;입니다.&#xD;
이는 자바스크립트 코드를 압축(minify)해 줍니다. 이 사용법에 대해서는&#xD;
나중에 다룰 것입니다.&lt;/p&gt;&#xD;
&#xD;
&lt;h2&gt;&lt;a href="#설정-파일-구성"&gt;1-3&lt;/a&gt;. 설정 파일 구성&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;Webpack은 박스(?) 밖에서 작동하지 않기 때문에 필요에 맞게 작성해야 합니다.&#xD;
이를 위해 다음과 같은 파일을 생성할 수 있습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre&gt;&lt;code&gt;webpack.config.js&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;이것은 Webpack이 기본적으로 인식하는 파일명입니다.&#xD;
다른 이름을 사용하려면 해당 파일의 이름을 지정할 수 있는 &lt;code&gt;--config&lt;/code&gt; 플래그를 사용해야 합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;h3&gt;&lt;a href="#최소한의-예제"&gt;1-3-1&lt;/a&gt;. 최소한의 예제&lt;/h3&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a href="https://github.com/firejune/WebpackTutorial/tree/master/example2"&gt;예제 2&lt;/a&gt;&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;디렉터리 구조는 다음과 같습니다:&lt;/p&gt;&#xD;
&#xD;
&lt;pre&gt;&lt;code&gt;MyDirectory&#xD;
|- dist&#xD;
|- src&#xD;
   |- index.js&#xD;
|- webpack.config.js&#xD;
&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;다음으로 최소한의 Webpack 설정이 있습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// webpack.config.js&#xD;
var path = require('path')&#xD;
&#xD;
module.exports = {&#xD;
  entry: ['./src/index'], // file extension after index is optional for .js files&#xD;
  output: {&#xD;
    path: path.join(__dirname, 'dist'),&#xD;
    filename: 'bundle.js'&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;새롭게 보이는 속성을 각각 살펴봅시다:&lt;/p&gt;&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;&lt;a href="https://webpack.github.io/docs/configuration.html#entry"&gt;entry&lt;/a&gt; - 번들의 엔트리 포인트로써 &lt;a href="#%EB%B2%88%EB%93%A4%ED%95%98%EA%B8%B0"&gt;번들하기&lt;/a&gt;&#xD;
색션에서 이미 논의했습니다. Webpack은 여러 번들을 생성하는 진입점을 허용하기 때문에 배열입니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;a href="https://webpack.github.io/docs/configuration.html#output"&gt;output&lt;/a&gt; - Webpack의 최종 결과물이 되는 형태를 명시합니다.&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;&lt;a href="https://webpack.github.io/docs/configuration.html#output-path"&gt;path&lt;/a&gt; - 어디에 번들 파일을 위치시킬 것인지를 지정합니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;a href="https://webpack.github.io/docs/configuration.html#output-filename"&gt;filename&lt;/a&gt; - 번들 파일의 이름을 지정합니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&#xD;
&lt;p&gt;이제 &lt;code&gt;webpack&lt;/code&gt; 명령을 실행하면, dist라는 폴더에 &lt;code&gt;bundle.js&lt;/code&gt; 파일을 생성합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;h3&gt;&lt;a href="#플러그인-이해"&gt;1-3-2&lt;/a&gt;. 플러그인 이해&lt;/h3&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a href="https://github.com/firejune/WebpackTutorial/tree/master/example3"&gt;예제 3&lt;/a&gt;&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;모든 파일의 번들에 Webpack을 사용했고 모두 합쳐서 900KB 짜리 파일을 얻었다고 가정해 봅시다.&#xD;
덩치가 큰 문제는 번들 파일의 압축으로 개선될 수 있습니다. 이 작업을 수행하려면 앞서 언급했던&#xD;
&lt;a href="https://webpack.github.io/docs/list-of-plugins.html#uglifyjsplugin"&gt;UglifyJsPlugin&lt;/a&gt;라는&#xD;
플러그인을 사용합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;또한 실제로 플러그인을 사용할 수 있도록 Webpack을 로컬에 설치해야 합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;npm install --save-dev webpack&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;이제 Webpack에서 필요로 하는 코드를 압축할 수 있습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// webpack.config.js&#xD;
var path = require('path')&#xD;
var webpack = require('webpack')&#xD;
&#xD;
module.exports = {&#xD;
  entry: ['./src/index'],&#xD;
  output: {&#xD;
    path: path.join(__dirname, 'dist'),&#xD;
    filename: 'bundle.js'&#xD;
  },&#xD;
&#xD;
  plugins: [&#xD;
    new webpack.optimize.UglifyJsPlugin({&#xD;
      compressor: {&#xD;
        warnings: false,&#xD;
      },&#xD;
    })&#xD;
  ]&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;새롭게 보이는 속성을 각각 살펴봅시다:&lt;/p&gt;&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;plugins - 보유 중인 플러그인의 배열입니다.&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;&lt;a href="https://webpack.github.io/docs/list-of-plugins.html#uglifyjsplugin"&gt;webpack.optimize.UglifyJsPlugin&lt;/a&gt; - 코드를 축소하고 경고 메시지는 표시하지 않습니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&#xD;
&lt;p&gt;이제, &lt;code&gt;webpack&lt;/code&gt; 명령을 실행하면, &lt;code&gt;UglifyJsPlugin&lt;/code&gt;에 의해 모든 공백을 제거하는 등의 과정을 거쳐&#xD;
900KB 짜리 파일을 200KB로 줄일 수 있습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;또한 &lt;a href="https://webpack.github.io/docs/list-of-plugins.html#occurrenceorderplugin"&gt;OccurrenceOrderPlugin&lt;/a&gt;을 추가할 수도 있습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;blockquote&gt;이 플러그인은 발생 횟수에 따라서 모듈 및 청크 id를 할당합니다. 자주 사용되는 id가 낮은(짧은) id를 얻습니다.&#xD;
이 id는 예측(predictable)이 가능하며, &lt;del&gt;전체 파일 크기를 줄이는데&lt;/del&gt;(역자주: 파일 용량을 줄이는 것과는 무관함) 추천됩니다.&lt;/blockquote&gt;&#xD;
&#xD;
&lt;p&gt;솔직히 말해서 기반 메커니즘이 어떻게 작동하는지 잘 모르지만,&#xD;
&lt;a href="https://gist.github.com/sokra/27b24881210b56bbaff7"&gt;Webpack2 베타 버전에는 기본으로 포함&lt;/a&gt; 되어 있다고 합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// webpack.config.js&#xD;
var path = require('path')&#xD;
var webpack = require('webpack')&#xD;
&#xD;
module.exports = {&#xD;
  entry: ['./src/index'],&#xD;
  output: {&#xD;
    path: path.join(__dirname, 'dist'),&#xD;
    filename: 'bundle.js'&#xD;
  },&#xD;
  plugins: [&#xD;
    new webpack.optimize.UglifyJsPlugin({&#xD;
      compressor: {&#xD;
        warnings: false,&#xD;
      },&#xD;
    }),&#xD;
    new webpack.optimize.OccurenceOrderPlugin()&#xD;
  ]&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;여기까지 자바스크립트의 번들을 압축하는 설정을 작성했습니다.&#xD;
이 번들을 다른 프로젝트의 디렉터리에 붙여넣고 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그에 대입할 수 있습니다.&#xD;
여기에서 &lt;a href="#%EA%B2%B0%EB%A1%A0"&gt;결론&lt;/a&gt;으로 바로 넘어가도 좋습니다. &lt;em&gt;오직 자바스크립트&lt;/em&gt; 에 대한&#xD;
기본적인 Webpack 사용법만 필요하다면 말이죠.&lt;/p&gt;&#xD;
&#xD;
&lt;h2&gt;&lt;a href="#조금-더-복잡한-예제"&gt;1-4&lt;/a&gt;. 조금 더 복잡한 예제&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;추가적으로, Webpack은 자바스크립트에 관련한 단순 작업보다 더 많은 일을 할 수 있으므로, 수동으로 복사-붙여넣기 하는 일을 없애고 Webpack으로 전체 프로젝트를 관리할 수 있습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;다음 섹션에서는, Webpack을 사용하여 아주 간단한 웹사이트를 만들 것입니다.&#xD;
예제를 수행하고자 하는 경우, 다음과 같은 구조의 디렉터리를 생성하세요.&lt;/p&gt;&#xD;
&#xD;
&lt;pre&gt;&lt;code&gt;MyDirectory&#xD;
|- dist&#xD;
|- src&#xD;
   |- index.js&#xD;
   |- index.html&#xD;
   |- styles.css&#xD;
|- package.json&#xD;
|- webpack.config.js&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;h3&gt;학습 내용&lt;/h3&gt;&#xD;
&#xD;
&lt;ol&gt;&#xD;
&lt;li&gt;&lt;a href="#%EB%A1%9C%EB%8D%94-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0"&gt;로더 이해하기&lt;/a&gt; - 번들에 CSS를 추가할 수 있도록 로더를 추가해 볼 것입니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;a href="#%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0"&gt;플러그인 추가하기&lt;/a&gt; - HTML 파일을 생성하고 사용할 수 있도록 도와주는 플러그인을 추가해 볼 것입니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;a href="#%EA%B0%9C%EB%B0%9C%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0"&gt;개발서버 구성하기&lt;/a&gt; - &lt;code&gt;development&lt;/code&gt;와 &lt;code&gt;production&lt;/code&gt;을 구분한 Webpack의 구성 파일을 분할하고&#xD;
&lt;code&gt;webpack-dev-server&lt;/code&gt;를 이용하여 HMR을 활성화해 볼 것입니다.&lt;/li&gt;&#xD;
&lt;li&gt;&lt;a href="#%EC%BD%94%EB%94%A9-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0"&gt;코딩 시작하기&lt;/a&gt; - 실제로 자바스크립트의 일부를 작성해 볼 것입니다.&lt;/li&gt;&#xD;
&lt;/ol&gt;&#xD;
&#xD;
&lt;h3&gt;&lt;a href="#로더-이해하기"&gt;1-4-1&lt;/a&gt;. 로더 이해하기&lt;/h3&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a href="https://github.com/firejune/WebpackTutorial/tree/master/example4"&gt;예제 4&lt;/a&gt;&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;이전 튜토리얼에서 &lt;a href="#%EB%A1%9C%EB%8D%94"&gt;로더&lt;/a&gt;에 대해 언급했습니다.&#xD;
이제 자바스크립트가 아닌 파일을 다루어 보기로 하겠습니다.&#xD;
스타일 로더와 CSS 로더가 필요하게 되었습니다. 먼저 로더를 설치해 봅시다:&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;npm install --save-dev style-loader css-loader&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;설치된 CSS 로더를 포함하도록 설정 파일을 조정해 봅시다:&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// webpack.config.js&#xD;
var path = require('path')&#xD;
var webpack = require('webpack')&#xD;
&#xD;
module.exports = {&#xD;
  entry: ['./src/index'],&#xD;
  output: {&#xD;
    path: path.join(__dirname, 'dist'),&#xD;
    filename: 'bundle.js'&#xD;
  },&#xD;
  plugins: [&#xD;
    new webpack.optimize.UglifyJsPlugin({&#xD;
      compressor: {&#xD;
        warnings: false,&#xD;
      },&#xD;
    }),&#xD;
    new webpack.optimize.OccurenceOrderPlugin()&#xD;
  ],&#xD;
  module: {&#xD;
    loaders: [{&#xD;
      test: /\.css$/,&#xD;
      loaders: ['style', 'css']&#xD;
    }]&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;새롭게 보이는 속성을 각각 살펴봅시다:&lt;/p&gt;&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;&lt;a href="http://webpack.github.io/docs/configuration.html#module"&gt;module&lt;/a&gt; - 이 옵션은 파일에 영향을 줍니다.&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;&lt;a href="http://webpack.github.io/docs/configuration.html#module-loaders"&gt;loaders&lt;/a&gt; - 애플리케이션에서 사용할 로더를 배열로 지정합니다.&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;test - 정규식을 이용해서 로더에 사용될 파일을 검출합니다.&lt;/li&gt;&#xD;
&lt;li&gt;loaders - 일치하는 파일에 사용되는 로더를 호출합니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;&lt;/li&gt;&#xD;
&lt;/ul&gt;&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;webpack&lt;/code&gt; 명령을 실행하면, &lt;code&gt;.css&lt;/code&gt;로 확장자를 가진 파일을 &lt;code&gt;require&lt;/code&gt;하는 경우,&#xD;
이 파일은 &lt;code&gt;style&lt;/code&gt;과 &lt;code&gt;css&lt;/code&gt; 로더에 적용되고, 번들에 CSS가 추가됩니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;로더를 가지고 있지 않은 경우, 다음과 같은 오류를 보게 될 것입니다:&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;ERROR in ./test.css&#xD;
Module parse failed: /Users/Developer/workspace/tutorials/webpack/part1/example1/test.css&#xD;
Line 1: Unexpected token {&#xD;
You may need an appropriate loader to handle this file type.&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;strong&gt;선택사항&lt;/strong&gt;&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;만약 CSS 대신 SCSS를 사용하는 경우 다음과 같이 실행해야 합니다:&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;npm install --save-dev sass-loader node-sass webpack&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;그리고 로더는 다음과 같이 작성되어야 합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;{&#xD;
  test: /\.scss$/,&#xD;
  loaders: ["style", "css", "sass"]&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;이 과정은 LESS도 비슷합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;중요한 것은 지정할 &lt;em&gt;순서&lt;/em&gt;가 존재한다는 것입니다. 위의 예제에서 &lt;code&gt;sass&lt;/code&gt; 로더에 가장 먼저 &lt;code&gt;.scss&lt;/code&gt; 파일을 적용하고,&#xD;
그다음으로 &lt;code&gt;css&lt;/code&gt; 로더, 마지막에 &lt;code&gt;style&lt;/code&gt; 로더에 적용합니다. 즉, 순서 패턴은 오른쪽에서 왼쪽으로 로더에 적용되는 것입니다.&lt;/p&gt;&#xD;
&#xD;
&lt;h3&gt;&lt;a href="#플러그인-추가하기"&gt;1-4-2&lt;/a&gt;. 플러그인 추가하기&lt;/h3&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a href="https://github.com/firejune/WebpackTutorial/tree/master/example5"&gt;예제 5&lt;/a&gt;&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;이제 웹사이트의 스타일링을 위한 인프라를 구축했으니, 스타일을 적용할 실제 페이지가 필요하게 되었습니다.&#xD;
HTML 페이지를 생성하거나 기존의 것을 그대로 사용할 수 있는 &lt;a href="https://github.com/ampedandwired/html-webpack-plugin"&gt;html-webpack-plugin&lt;/a&gt;을&#xD;
이용하여 이 작업을 수행할 수 있습니다. 여기서는 기존의 &lt;code&gt;index.html&lt;/code&gt;를 사용할 것입니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;먼저 플러그인을 설치합니다:&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;npm install --save-dev html-webpack-plugin@2&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;다음으로 설정을 추가 합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// webpack.config.js&#xD;
var path = require('path')&#xD;
var webpack = require('webpack')&#xD;
var HtmlWebpackPlugin = require('html-webpack-plugin')&#xD;
&#xD;
module.exports = {&#xD;
  entry: ['./src/index'],&#xD;
  output: {&#xD;
    path: path.join(__dirname, 'dist'),&#xD;
    filename: 'bundle.js'&#xD;
  },&#xD;
  plugins: [&#xD;
    new webpack.optimize.UglifyJsPlugin({&#xD;
      compressor: {&#xD;
        warnings: false,&#xD;
      },&#xD;
    }),&#xD;
    new webpack.optimize.OccurenceOrderPlugin(),&#xD;
    new HtmlWebpackPlugin({&#xD;
      template: './src/index.html'&#xD;
    })&#xD;
  ],&#xD;
  module: {&#xD;
    loaders: [{&#xD;
      test: /\.css$/,&#xD;
      loaders: ['style', 'css']&#xD;
    }]&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;이번에 &lt;code&gt;webpack&lt;/code&gt; 명령을 실행하면, &lt;code&gt;HtmlWebpackPlugin&lt;/code&gt;이 &lt;code&gt;./src/index.html&lt;/code&gt; 지정하기 때문에&#xD;
&lt;code&gt;./src/index.html&lt;/code&gt; 파일의 내용을 &lt;code&gt;dist&lt;/code&gt; 폴더에 &lt;code&gt;index.html&lt;/code&gt;파일로 생성할 것입니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;index.html&lt;/code&gt;의 내용이 비어 있다면 기본 템플릿을 사용하기 때문에 아무런 문제가 없습니다. 하지만 그 내용을 채워 보도록 하겠습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;html&amp;gt;&#xD;
&amp;lt;head&amp;gt;&#xD;
  &amp;lt;title&amp;gt;Webpack Tutorial&amp;lt;/title&amp;gt;&#xD;
&amp;lt;/head&amp;gt;&#xD;
&amp;lt;body&amp;gt;&#xD;
  &amp;lt;h1&amp;gt;Very Website&amp;lt;/h1&amp;gt;&#xD;
  &amp;lt;section id="color"&amp;gt;&amp;lt;/section&amp;gt;&#xD;
  &amp;lt;button id="button"&amp;gt;Such Button&amp;lt;/button&amp;gt;&#xD;
&amp;lt;/body&amp;gt;&#xD;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;이제 &lt;code&gt;bundle.js&lt;/code&gt;의 내용을 HTML의 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그에 직접 넣지 않아도 됩니다.&#xD;
이 플러그인이 자동으로 넣어주기 때문입니다. 만약 스크립트 태그에 직접 넣은 경우라면, 같은 코드를 두 번 로드하게 될 것입니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;이 시점에서 &lt;code&gt;styles.css&lt;/code&gt;에 몇 가지 기본 스타일을 추가해 봅시다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="css"&gt;&lt;code&gt;h1 {&#xD;
  color: rgb(114, 191, 190);&#xD;
  text-align: center;&#xD;
}&#xD;
&#xD;
#color {&#xD;
  width: 300px;&#xD;
  height: 300px;&#xD;
  margin: 0 auto;&#xD;
}&#xD;
&#xD;
button {&#xD;
  cursor: pointer;&#xD;
  display: block;&#xD;
  width: 100px;&#xD;
  outline: 0;&#xD;
  border: 0;&#xD;
  margin: 20px auto;&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;h3&gt;&lt;a href="#개발서버-구성하기"&gt;1-4-3&lt;/a&gt;. 개발서버 구성하기&lt;/h3&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a href="https://github.com/firejune/WebpackTutorial/tree/master/example6"&gt;예제 6&lt;/a&gt;&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;이제 실제로 브라우저에서 웹사이트를 볼 수 있도록, 지금까지 만들어진 코드를 제공하는 웹서버가 필요하게 되었습니다.&#xD;
편리하게도, Webpack은 &lt;code&gt;webpack-dev-server&lt;/code&gt;를 제공합니다. 로컬과 글로벌에 모두 설치합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;npm install -g webpack-dev-server&#xD;
npm install --save-dev webpack-dev-server&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;개발 서버는 작업 된 웹사이트를 브라우저에서 바로 확인할 수 있어 매우 유용하며, 더 빠른 개발을 할 수 있습니다.&#xD;
기본적으로 &lt;code&gt;http://localhost:8080&lt;/code&gt;를 방문할 수 있습니다.&#xD;
아쉽지만, 핫-리로드 기능은 박스(?) 밖에서는 작동하지 않아서 약간의 추가 구성이 필요합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;이 시점에서 개발용(development)과 제품용(production)을 구분해 보겠습니다.&#xD;
이 튜토리얼은 간단함을 유지하고 있으므로 큰 차이는 없지만, Webpack의 단적인 기능 설정에 관한 예입니다.&#xD;
&lt;code&gt;webpack.config.dev.js&lt;/code&gt;와 &lt;code&gt;webpack.config.prod.js&lt;/code&gt;를 호출할 수 있도록 합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// webpack.config.dev.js&#xD;
var path = require('path')&#xD;
var webpack = require('webpack')&#xD;
var HtmlWebpackPlugin = require('html-webpack-plugin')&#xD;
&#xD;
module.exports = {&#xD;
  devtool: 'cheap-eval-source-map',&#xD;
  entry: [&#xD;
    'webpack-dev-server/client?http://localhost:8080',&#xD;
    'webpack/hot/dev-server',&#xD;
    './src/index'&#xD;
  ],&#xD;
  output: {&#xD;
    path: path.join(__dirname, 'dist'),&#xD;
    filename: 'bundle.js'&#xD;
  },&#xD;
  plugins: [&#xD;
    new webpack.HotModuleReplacementPlugin(),&#xD;
    new HtmlWebpackPlugin({&#xD;
      template: './src/index.html'&#xD;
    })&#xD;
  ],&#xD;
  module: {&#xD;
    loaders: [{&#xD;
      test: /\.css$/,&#xD;
      loaders: ['style', 'css']&#xD;
    }]&#xD;
  },&#xD;
  devServer: {&#xD;
    contentBase: './dist',&#xD;
    hot: true&#xD;
  }&#xD;
}&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;strong&gt;바뀐점&lt;/strong&gt;&lt;/p&gt;&#xD;
&#xD;
&lt;ol&gt;&#xD;
&lt;li&gt;개발 설정에서 지속해서 다시 구축하거나 최적화하는 일은 불필요한 오버헤드가 발생하기 때문에 생략합니다.&#xD;
그래서 &lt;code&gt;webpack.optimize&lt;/code&gt; 플러그인이 없습니다.&lt;/li&gt;&#xD;
&lt;li&gt;개발 설정은 개발 서버에 필요한 것만 작성합니다. 더 자세한 내용을&#xD;
&lt;a href="https://webpack.github.io/docs/webpack-dev-server.html"&gt;여기&lt;/a&gt;에서 볼 수 있습니다.&lt;/li&gt;&#xD;
&lt;/ol&gt;&#xD;
&#xD;
&lt;p&gt;요약:&lt;/p&gt;&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;entry: 두 개의 새로운 엔트리 포인트는 HMR이 가능하도록 브라우저에 서버를 연결합니다.&lt;/li&gt;&#xD;
&lt;li&gt;devServer&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;contentBase: 브라우저에서 접근하는 파일의 위치입니다.&lt;/li&gt;&#xD;
&lt;li&gt;hot: HMR 사용 여부입니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&#xD;
&lt;p&gt;제품용 설정의 구성은 별로 변경되지 않습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// webpack.config.prod.js&#xD;
var path = require('path')&#xD;
var webpack = require('webpack')&#xD;
var HtmlWebpackPlugin = require('html-webpack-plugin')&#xD;
&#xD;
module.exports = {&#xD;
  devtool: 'source-map',&#xD;
  entry: ['./src/index'],&#xD;
  output: {&#xD;
    path: path.join(__dirname, 'dist'),&#xD;
    filename: 'bundle.js'&#xD;
  },&#xD;
  plugins: [&#xD;
    new webpack.optimize.UglifyJsPlugin({&#xD;
      compressor: {&#xD;
        warnings: false,&#xD;
      },&#xD;
    }),&#xD;
    new webpack.optimize.OccurenceOrderPlugin(),&#xD;
    new HtmlWebpackPlugin({&#xD;
      template: './src/index.html'&#xD;
    })&#xD;
  ],&#xD;
  module: {&#xD;
    loaders: [{&#xD;
      test: /\.css$/,&#xD;
      loaders: ['style', 'css']&#xD;
    }]&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;또한, 개발용 구성과 제품용 구성 모두 새로운 속성을 추가했습니다:&lt;/p&gt;&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;&lt;a href="https://webpack.github.io/docs/configuration.html#devtool"&gt;devtool&lt;/a&gt; - 디버깅을 지원합니다.&#xD;
오류가 발생하는 경우, 크롬 개발자 콘솔과 같은 도구를 이용하여 실수한 위치를 확인하는 데 도움됩니다.&#xD;
&lt;code&gt;source-map&lt;/code&gt;과 &lt;code&gt;cheap-eval-source-map&lt;/code&gt;의 차이에 대해서는 문서를 읽고도 이해하기가 조금 어려웠지만,&#xD;
확실히 알 수 있었던 것은 &lt;code&gt;source-map&lt;/code&gt;이 제품용 모드에서 오버헤드가 많다는 점과,&#xD;
&lt;code&gt;cheap-eval-source-map&lt;/code&gt;이 더 작은 오버헤드를 가지며, 이것은 단지 개발을 위한 것이라는 점입니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&#xD;
&lt;p&gt;개발 서버는 다음과 같이 실행합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;webpack-dev-server --config webpack.config.dev.js&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;제품용 코드를 구축하기 위해서는 다음과 같이 실행합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;webpack --config webpack.config.prod.js&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;이와 같은 명령을 매번 입력하지 않아도 되도록 &lt;code&gt;package.json&lt;/code&gt;에 약간의 기능을 작성하는 것으로&#xD;
더 간단하게 명령을 수행할 수 있습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;설정에 &lt;code&gt;scripts&lt;/code&gt; 속성을 추가합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="json"&gt;&lt;code&gt;// package.json&#xD;
{&#xD;
  //...&#xD;
  "scripts": {&#xD;
    "build": "webpack --config webpack.config.prod.js",&#xD;
    "dev"  : "webpack-dev-server --config webpack.config.dev.js"&#xD;
  }&#xD;
  //...&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;이제 더욱 간단하게 명령을 실행할 수 있습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;npm run build&#xD;
npm run dev&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;npm run dev&lt;/code&gt; 명령을 실행하고 &lt;code&gt;http://localhost:8080&lt;/code&gt;으로 이동하여 작업 된 웹사이트를 볼 수 있습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;blockquote&gt;&lt;strong&gt;노트:&lt;/strong&gt; 이 부분을 테스트하는 동안 &lt;code&gt;index.html&lt;/code&gt; 파일을 수정할 때 서버가 핫-리로드 되지 않는 것을 깨달았습니다.&#xD;
이 문제에 대한 해결책은 &lt;a href="https://github.com/firejune/WebpackTutorial/tree/master/html-reload"&gt;html-reload&lt;/a&gt;에&#xD;
있습니다. 이것은 Webpack 옵션에 대하여 조금 더 유용한 정보를 얻을 수 있어서 읽어보길 추천합니다. 너무 사소한 내용이고&#xD;
튜토리얼을 너무 길게 쓰는 느낌이 들었기 때문에 별도로 구분했습니다.&lt;/blockquote&gt;&#xD;
&#xD;
&lt;h3&gt;&lt;a href="#코딩-시작하기"&gt;1-4-4&lt;/a&gt;. 코딩 시작하기&lt;/h3&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a href="https://github.com/firejune/WebpackTutorial/tree/master/example7"&gt;예제 7&lt;/a&gt;&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;많은 사람이 Webpack에 당황해할 것 같습니다. 이유는 실제 작업용 자바스크립트 코드를 작성하기까지&#xD;
여태것 공부했던 여러 과정을 모두 숙지해야 하기 때문입니다; 다행히도 이 튜토리얼의 클라이막스에 도달했습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;npm run dev&lt;/code&gt; 명령 실행 및 &lt;code&gt;http://localhost:8080&lt;/code&gt;를 하지 않았으면 수행합니다.&#xD;
개발 서버에 핫-리로드를 설정하는 것은 단순히 보기만을 위한 것이 아닙니다.&#xD;
프로젝트 일부를 편집하고 저장하는 매시간 변경사항을 표시하도록 브라우저는 다시 로드합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;이제 이것을 프론트엔드에서 사용할 수 있는 방법을 보여주기 위해 몇몇 npm 패키지가 필요합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="command"&gt;&lt;code&gt;npm install --save pleasejs&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;PleaseJS는 임의 색상 발생기입니다. 특정 버튼을 이용해 div의 색상을 변경해 보겠습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// index.js&#xD;
&#xD;
// Accept hot module reloading&#xD;
if (module.hot) {&#xD;
  module.hot.accept()&#xD;
}&#xD;
&#xD;
require('./styles.css') // The page is now styled&#xD;
var Please = require('pleasejs')&#xD;
var div = document.getElementById('color')&#xD;
var button = document.getElementById('button')&#xD;
&#xD;
function changeColor() {&#xD;
  div.style.backgroundColor = Please.make_color()&#xD;
}&#xD;
&#xD;
button.addEventListener('click', changeColor)&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;흥미롭게도, &lt;a href="https://webpack.github.io/docs/hot-module-replacement-with-webpack.html#what-is-needed-to-use-it"&gt;HMR이 작동하려면&lt;/a&gt;&#xD;
다음과 같은 코드를 포함해야 합니다:&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;if (module.hot) {&#xD;
  module.hot.accept()&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;모듈 또는 상위 모듈에서요.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;이제 마지막입니다!&lt;/p&gt;&#xD;
&#xD;
&lt;blockquote&gt;&lt;strong&gt;노트:&lt;/strong&gt; 예제를 통해 CSS를 적용하면서 꺼림칙한 부분은,&#xD;
CSS가 자바스크립트 파일에 있다는 사실입니다.&#xD;
다른 파일에 CSS를 넣는 방법에 대한 자세한 설명을 별도로 작성했습니다.&#xD;
&lt;a href="https://github.com/firejune/WebpackTutorial/tree/master/css-extract"&gt;css-extract&lt;/a&gt;를 확인하세요.&lt;/blockquote&gt;&#xD;
&#xD;
&lt;h2&gt;&lt;a href="#결론"&gt;1-5&lt;/a&gt;. 결론&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;축하합니다! div의 색상을 변경하는 버튼을 만들기까지 모두 학습했습니다! Webpack, 참 훌륭하죠?&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;Webpack은 처음 접한 모듈 번들러입니다. 그리고 매우 유용한 도구였습니다.&#xD;
파트 1에서는 가장 일반적인 사용 사례를 다루었지만, 아직 ES6과 React를 연결하여&#xD;
사용하는 방법에 대해서는 다루지 않았습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;나중에&lt;/p&gt;&#xD;
&#xD;
&lt;ul&gt;&#xD;
&lt;li&gt;파트 2에서는 Webpack과 Babel을 함께 사용하여 ES6을 ES5로 transpile 하는 방법을 살펴보겠습니다.&lt;/li&gt;&#xD;
&lt;li&gt;파트 3에서는 Webpack과 React + Babel을 함께 사용하는 방법을 살펴보겠습니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&#xD;
&lt;p&gt;도움이 되었기를 바랍니다.&lt;/p&gt;&#xD;


			&lt;br&gt;&lt;br&gt;
			&lt;a href="https://firejune.com/1798#p1798"&gt;Comments(7)&lt;/a&gt; |
			&lt;a href="https://firejune.com/1798"&gt;Hits(323,129)&lt;/a&gt;&lt;img src="http://feeds.feedburner.com/~r/firejune/~4/84_rgyWDtks" height="1" width="1" alt=""/&gt;</content><feedburner:origLink>https://firejune.com/1798</feedburner:origLink></entry><entry><title type="text">실시간 트랜스파일과 모듈화된 프론트앤드 개발환경</title><link rel="alternate" type="text/html" href="http://feedproxy.google.com/~r/firejune/~3/sQ26uwtEA4M/1797" /><category term="자료-웹개발" /><category term="자바스크립트" /><category term="프로젝트" /><category term="Node.js" /><category term="React" /><category term="ES6" /><category term="Webpack" /><category term="Nightwatch.js" /><category term="테스트 자동화" /><category term="Hello  world!" /><category term="Electron" /><category term="프로젝트" /><category term="Jest" /><category term="ESLint" /><category term="쓰다가 급 귀찮아짐" /><author><name>파이어준</name></author><updated>2016-01-28T05:19:44-08:00</updated><id>https://firejune.com/1797</id><content type="html">&lt;p&gt;최근 들어 더욱 가속화되어 발전하는 자바스크립트 트렌드는 이제 지켜보는 것조차 버겁네요. 최근 신규 프로젝트의 개발환경을 구축하면서 최종적으로 반영된 구성에 관해서 얘기해 보겠습니다. 브라우저에서 Node.js의 모듈 인프라를 이용할 수 있게 하고 실시간으로 트랜스파일(Transpile)이 되도록 개발환경을 구성해 보았습니다. 이 개발환경에 적응하면서 느끼는 것은 "이제 브라우저에서도 자바스크립트로 개발하기가 정말 좋은 세상이 되었구나!" 입니다. 그래서 다른 프로젝트에도 이를 적용할 수 있도록 사내에 전파를 시도하면서 정리했던 내용 일부를 공유합니다.&lt;/p&gt;
&lt;p&gt;우리는 Node.js를 기반으로 한 개발환경에 &lt;a href="http://browserify.org/"&gt;Browserify&lt;/a&gt;나 &lt;a href="https://webpack.github.io/"&gt;Webpack&lt;/a&gt;과 같은 모듈 번들러를 이용하여 자바스크립트로 작성된 기능의 모듈화를 효율적이고 안정적으로 구현한 바 있습니다. 그리고 개발환경에서는 와쳐(Watcher)를 이용하여 파일이 변동되면 번들링한 후 브라우저에서 새로 고침까지 자동으로 되도록 했습니다. &lt;/p&gt;
&lt;p&gt;그러나 답답합니다. 코드량이 많아질수록 눈에 띄게 느려지는 번들링 시간과 마이너 픽스에도 꼭 거쳐야만 하는 이 과정은 이제 지긋지긋합니다. 그냥 예전처럼 브라우저에서 새로 고치면 즉시 그 결과를 확인하고 싶습니다. 그래서 이처럼 불편하고 느려터진 번들링 과정을 개발하는 동안에는 하지 않아도 되도록 하는 것이 컨셉이라 하겠습니다. 즉, 실시간 트랜스파일이 되도록 한다는 것은, &lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;require&lt;/code&gt; 문을 브라우저에서 직접 사용할 수 있도록 하는 것입니다. &lt;/p&gt;
&lt;h2&gt;Requirements&lt;/h2&gt;
&lt;p&gt;개발환경을 구성하는 주요한 설치 요구사항입니다. 테스트 라이브러리나 태스크 매니저는 취향에 맞게 사용하면 됩니다.&lt;/p&gt;
&lt;ul class="square"&gt;&#xD;
  &lt;li&gt;&lt;a href="https://nodejs.org/"&gt;Node.js&lt;/a&gt; - 실시간으로 트랜스파일이 가능한 개발환경의 기반이 됩니다.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="http://electron.atom.io/"&gt;Electron&lt;/a&gt; - 구글 크롬 브라우저에서 import(require)문을 직접 이용하는 데 필요합니다.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="https://babeljs.io/"&gt;Babel&lt;/a&gt; - ES6, ES7, JSX등 차세대 자바스크립트 코드를 구사하기 위해 사용합니다.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="http://eslint.org/"&gt;ESLint&lt;/a&gt; -  코드 스타일을 안내해주고, 빈번히 발생하는 개발 실수를 줄여줍니다.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="https://webpack.github.io/"&gt;Webpack&lt;/a&gt; - 프로덕션 빌드 과정에서 모듈 패키징에 사용됩니다.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="https://facebook.github.io/jest/"&gt;Jest&lt;/a&gt; - 자바스크립트 유닛 테스트의 고통을 덜 수 있습니다.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="http://nightwatchjs.org/"&gt;Nightwatch.js&lt;/a&gt; - 구글 크롬 외 다른 브라우저에서의 작동 여부를 테스트하고 자동화를 위해 사용합니다.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="http://gruntjs.com/"&gt;Grunt&lt;/a&gt; - 이 모든 과정을 수월하게 관리할 수 있도록 도와주는 태스크 매니저입니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;
&lt;blockquote&gt;&lt;p&gt;노트: Electron을 개발환경에 적합하다고 판단한 이유가 하나 더 있습니다. Node.js에 내장된 V8 버전(가장 최근에 나온 Node.js 5.1.1의 V8 버전은 4.6) 보다 Electron에 내장된 V8 버전이 4.8로 한참 앞서있기 때문입니다. 또한, &lt;a href="http://v8project.blogspot.kr/"&gt;V8의 블로그&lt;/a&gt;를 보면 ECMAScript 2015(ES6) 스펙을 구현하는 작업이 한창인 것을 알 수 있는데, 안정적인 버전의 크롬이 나오면 1, 2주 내로 Electron에 반영되는 장점은 덤입니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;Configuration&lt;/h2&gt;
&lt;p&gt;이제 설정 파일을 작성해 봅시다. React와 jQuery를 사용하는 웹앱을 만든다고 가정합니다. 임의의 프로젝트 폴더에 &lt;code&gt;package.json&lt;/code&gt;을 비롯한 프로젝트를 구성하는 파일과 폴더를 생성합니다.&lt;/p&gt;
&lt;pre class="bash"&gt;&lt;code&gt;$ mkdir my-project&#xD;
$ cd my-project&#xD;
$ touch .babelrc&#xD;
$ touch .eslintrc&#xD;
$ touch .gitignore&#xD;
$ touch package.json&#xD;
$ touch main.js&#xD;
$ touch index.html&#xD;
$ touch LICENSE.md&#xD;
$ touch README.md&#xD;
$ mkdir scripts&#xD;
$ mkdir src&#xD;
$ cd src&#xD;
$ touch index.js&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt; Babel 트랜스파일러에서 사용할 플러그인을 지정합니다. 일반적으로 프리셋(&lt;code&gt;babel-preset-*&lt;/code&gt;)을 사용하지만, 프리셋은 아주 많은 Babel 플러그인들을 포함하고 있어서 실시간으로 트랜스파일 하는 데에는 적합하지 않습니다. 오래 걸리기 때문입니다. 아래의 구성은 Electron 현재 버전 0.36.x(Node.js 5.1.1, 구글 크롬 47)에 내장된 V8 버전 4.7에서 ES2015 스펙이 미구현 되거나 일부만 구현되어 필요하게 된 플러그인을 개별적으로 로드하는 내용입니다.  이렇게 했을 때 프리셋을 사용할 때보다 매 새로 고침 마다 6초에서 4초 정도 시간을 절약할 수 있습니다. 보통 2초 정도면 페이지 로드가 완료됩니다.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;노트: Node.js의 &lt;code&gt;require&lt;/code&gt;를 훅(Hook)하는 &lt;code&gt;babel-register&lt;/code&gt;는 캐시(Cache) 옵션이 기본으로 활성화되어 있습니다. 첫 로딩보다 그 다음 로딩이 훨씬 빠릅니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;pre class="json"&gt;&lt;code&gt;{&#xD;
  "plugins": [&#xD;
    "transform-es2015-destructuring",&#xD;
    "transform-es2015-for-of",&#xD;
    "transform-es2015-modules-commonjs",&#xD;
    "transform-es2015-object-super",&#xD;
    "transform-es2015-parameters",&#xD;
    "transform-es2015-shorthand-properties",&#xD;
    "transform-object-rest-spread",&#xD;
    "transform-react-jsx"&#xD;
  ]&#xD;
}&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;p&gt;노트: &lt;code&gt;sticky-regex&lt;/code&gt;와 &lt;code&gt;unicode-regex&lt;/code&gt; 그리고 &lt;code&gt;typeof-symbol&lt;/code&gt; 플러그인은 테스트를 통과하지 못해 로드하지 않았습니다. 그리고 크롬의 최신 버전인 48(아마도 Electron 0.37.x)에서는 &lt;code&gt;object-super&lt;/code&gt;와 &lt;code&gt;typeof-symbol&lt;/code&gt; 플러그인이 필요하지 않게 됩니다. 지난 26일 릴리즈된 &lt;a href="http://v8project.blogspot.kr/2016/01/v8-release-49.html"&gt;V8 버전 4.9&lt;/a&gt;(크롬 49)에서는 &lt;code&gt;destructuring&lt;/code&gt;, &lt;code&gt;parameters&lt;/code&gt;, &lt;code&gt;sticky-regex&lt;/code&gt;등이 구현되었습니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Electron 버전 0.35.x(Node 4.1.1, 크롬 45, v8 버전 4.5)에서는 아래의 3개 플러그인을 추가로 로드하여 ES6을 정상적으로 사용할 수 있습니다. &lt;a href="https://github.com/babel/babel/tree/master/packages"&gt;Babel의 Github 리파지토리&lt;/a&gt;에 있는 380여 개 테스트 케이스를 돌려서 확인했으며 속도 역시 그럭저럭 나옵니다.&lt;/p&gt;
&lt;pre class="js"&gt;&lt;code&gt;    ...&#xD;
    // Require if using electron version 0.35.x&#xD;
    "transform-es2015-block-scoping",&#xD;
    "transform-es2015-classes",&#xD;
    "transform-es2015-spread"&#xD;
    ...&#xD;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;object-rest-spread&lt;/code&gt;는 ES2015의 공식 스펙은 아니지만 ES7의 꽃이라 할만한 &lt;a href="https://github.com/sebmarkbage/ecmascript-rest-spread"&gt;멋진 연산자&lt;/a&gt;입니다. 이미 널리 사용되고 있으며, ESLint의 &lt;a href="http://eslint.org/docs/1.10.3/rules/object-shorthand"&gt;object-shorthand&lt;/a&gt; 룰에 영향을 받습니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;.eslintrc&lt;/code&gt; 파일은 ESLint의 설정입니다. ESLint는 코드를 작성하는 과정에서 빈번하게 발생하는 실수를 예방하고, 엘레강스한 코드 스타일을 추천해 주며, 미래에 발생할 수 있는 잠재적 오류를 수정할 수 있도록 도와줍니다. 제가 사용하는 코드 편집기는 &lt;a href="https://panic.com/coda/"&gt;CODA 2&lt;/a&gt;인데, 여기에 &lt;a href="https://panic.com/coda/plugins.php?id=131"&gt;ESLint JS Validator&lt;/a&gt; 플러그인을 추가하면 아래 설정에 기반을 두어 코드 검증기를 통해 꾸역꾸역 잔소리(?)해 대도록 꾸몄습니다. 만약 아톰(Atom) 편집기를 사용한다면, &lt;a href="https://atom.io/packages/linter-eslint"&gt;linter-eslint&lt;/a&gt; 패키지를 설치하여 사용할 수 있고 &lt;a href="http://www.sublimetext.com/"&gt;Sublime Text&lt;/a&gt;에도 비슷한 녀석이 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://firejune.com/attach/0119/160119214611791010/419654.gif" width="640" height="258" alt="eslint.gif" /&gt;&lt;/p&gt;
&lt;p&gt;요런 느낌입니다. 가장 우선순위에 있는 룰은 얼마 전에 번역한 바 있는 &lt;a href="https://firejune.com/1794/Airbnb%EC%9D%98+ES6+%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+%EC%8A%A4%ED%83%80%EC%9D%BC+%EA%B0%80%EC%9D%B4%EB%93%9C"&gt;Airbnb 코드 스타일&lt;/a&gt;이고, 그다음으로 &lt;a href="http://standardjs.com/"&gt;JavaScript Standard Style&lt;/a&gt;의 프리셋과 React 플러그인을 적용하고, 개인적으로 탐탁지 못한 몇몇 규칙을 &lt;code&gt;"rules"&lt;/code&gt;에 재정의한 것입니다.&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{&#xD;
  "ecmaFeatures": {&#xD;
    "jsx": true,&#xD;
    "modules": true,&#xD;
    "experimentalObjectRestSpread": true&#xD;
  },&#xD;
  "env": { "es6": true, "node": true, "browser": true },&#xD;
  "extends": ["standard", "airbnb"],&#xD;
  "globals": { "$": true },&#xD;
  "parser": "babel-eslint",&#xD;
  "plugins": ["standard", "react"],&#xD;
  "rules": {&#xD;
    "comma-dangle": [2, "never"],&#xD;
    "default-case": 0,&#xD;
    "func-names": 0,&#xD;
    "new-cap": [2, { "newIsCap": true, "capIsNew": false }],&#xD;
    "no-console": 0,&#xD;
    "object-curly-spacing": 0,&#xD;
    "react/prop-types": 0,&#xD;
    "react/sort-comp": 0,&#xD;
    "space-before-function-paren": [2, "never"],&#xD;
    "strict": 0&#xD;
  }&#xD;
}&#xD;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;p&gt;노트: 경우에 따라서는 ESLint관련 패키지를 글로벌에 설치해야 할 수도 있습니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;pre class="command"&gt;&lt;code&gt;$ npm install -g eslint&#xD;
$ npm install -g eslint-config-airbnb eslint-config-standard&#xD;
$ npm install -g eslint-plugin-react eslint-plugin-standard&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt; 파일의 내용은 다음과 같습니다. 프로젝트에서 필요한 모듈들의 정보를 포함한 여러 내용으로 구성됩니다. 더 자세한 내용은 &lt;a href="https://docs.npmjs.com/files/package.json"&gt;이곳&lt;/a&gt;을 참고하세요.&lt;/p&gt;
&lt;pre class="json"&gt;&lt;code&gt;{&#xD;
  "name": "MyProject",&#xD;
  "version": "0.0.1",&#xD;
  "license": "MIT",&#xD;
  "description": "My Awesome Project",&#xD;
  "author": "firejune",&#xD;
  "main": "main.js",&#xD;
  "dependencies": {&#xD;
    "jquery": "^2.2.0",&#xD;
    "jquery-ui": "^1.10.5",&#xD;
    "react": "^0.14.3",&#xD;
    "react-dom": "^0.14.3"&#xD;
  },&#xD;
  "devDependencies": {&#xD;
    "babel-core": "^6.4.5",&#xD;
    "babel-eslint": "^5.0.0-beta6",&#xD;
    "babel-loader": "^6.2.1",&#xD;
    "babel-plugin-transform-es2015-destructuring": "^6.4.0",&#xD;
    "babel-plugin-transform-es2015-for-of": "^6.3.13",&#xD;
    "babel-plugin-transform-es2015-modules-commonjs": "^6.4.5",&#xD;
    "babel-plugin-transform-es2015-object-super": "^6.4.0",&#xD;
    "babel-plugin-transform-es2015-parameters": "^6.4.5",&#xD;
    "babel-plugin-transform-es2015-shorthand-properties": "^6.3.13",&#xD;
    "babel-plugin-transform-object-rest-spread": "^6.3.13",&#xD;
    "babel-plugin-transform-react-jsx": "^6.4.0",&#xD;
    "electron-prebuilt": "^0.36.5",&#xD;
    "eslint": "^1.10.3",&#xD;
    "eslint-config-airbnb": "^3.1.0",&#xD;
    "eslint-config-standard": "^4.4.0",&#xD;
    "eslint-plugin-react": "^3.15.0",&#xD;
    "eslint-plugin-standard": "^1.3.1",&#xD;
    "grunt": "^0.4.5",&#xD;
    "jest-cli": "^0.8.2",&#xD;
    "nightwatch": "^0.8.15",&#xD;
    "webpack": "^1.12.11"&#xD;
  },&#xD;
  "scripts": {&#xD;
    "start": "electron .",&#xD;
    "lint": "eslint ./src",&#xD;
    "test:unit": "npm run lint &amp;amp;&amp;amp; jest -c ./scripts/unit-test.json",&#xD;
    "test:ui": "npm run test:unit  &amp;amp;&amp;amp; nightwatch --test ./scripts/ui-test.js",&#xD;
    "build": "npm run test:ui  &amp;amp;&amp;amp; webpack --config ./scripts/package.js --release"&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;p&gt;굳이 ES6 문법까지는 필요는 없고, JSX 트랜스파일만 필요한 상황이라면 &lt;code&gt;"transform-react-jsx"&lt;/code&gt; 플러그인만 남기거나 Babel이 아닌 &lt;a href="https://github.com/petehunt/node-jsx"&gt;node-jsx&lt;/a&gt; 모듈을 이용하는 방법도 있습니다. node-jsx가 사용법도 간단하고 빠르긴 한데, Babel로 이관되면서 deprecated 되었습니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;Electron Starter&lt;/h2&gt;
&lt;p&gt; 이제 Electron에서의 작업환경을 구성할 차례입니다. &lt;code&gt;main.js&lt;/code&gt; 파일은 &lt;code&gt;package.json&lt;/code&gt;에 명시되어  Electron이 처음으로 접근하는 파일이며, Electron에 의해 브라우저 윈도를 만들어줍니다. 아쉽지만, 이 파일은 ES6으로 작성할 수 없습니다.&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;'use strict';&#xD;
&#xD;
const electron = require('electron');&#xD;
const app = electron.app;&#xD;
const BrowserWindow = electron.BrowserWindow;&#xD;
&#xD;
// 실행 준비를 마치면 브라우저 창 생성&#xD;
app.on('ready', function () {&#xD;
  // 브라우저 생성&#xD;
  const mainWindow = new BrowserWindow({width: 800, height: 600});&#xD;
  // 브라우저에서 처음으로 그려질 페이지&#xD;
  mainWindow.loadURL('file://' + __dirname + '/index.html');&#xD;
  // 브라우저의 개발자 도구 자동으로 열기&#xD;
  mainWindow.webContents.openDevTools();&#xD;
  // 창이 닫히면 프로세스 종료&#xD;
  mainWindow.on('closed', function() {&#xD;
    app.quit();&#xD;
  });&#xD;
});&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;index.html&lt;/code&gt; 파일은 &lt;code&gt;main.js&lt;/code&gt;에 의해 브라우저(&lt;code&gt;BrowserWindow&lt;/code&gt;)에서 처음으로 그려질 페이지입니다. 이 브라우저가 바로 앞으로 동고동락할 작업용 브라우저입니다. 일단 다음과 같이 내용을 작성합니다.&lt;/p&gt;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&#xD;
&amp;lt;html&amp;gt;&#xD;
  &amp;lt;head&amp;gt;&#xD;
    &amp;lt;meta charset="UTF-8"&amp;gt;&#xD;
    &amp;lt;title&amp;gt;Hello World!&amp;lt;/title&amp;gt;&#xD;
  &amp;lt;/head&amp;gt;&#xD;
  &amp;lt;body&amp;gt;&#xD;
    &amp;lt;div id="example"&amp;gt;Hello&amp;lt;/div&amp;gt;&#xD;
    &amp;lt;script&amp;gt;&#xD;
      // Install babel hooks to the browser process&#xD;
      require('babel-core/register')();&#xD;
      require('./src');&#xD;
    &amp;lt;/script&amp;gt;&#xD;
  &amp;lt;/body&amp;gt;&#xD;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;p&gt;노트: Electron은 main과 browser로 구분된 프로세스 두 개를 실행합니다. 따라서 두 프로세스 간에는 IPC 스타일의 통신을 이용해야 하지만, Electron 앱이 아닌, 일반적인 웹앱 개발에 Electron을 이용하는 것이므로 main 프로세스에서 하는 일에 대해서는 크게 걱정하지 않아도 됩니다. &lt;code&gt;main.js&lt;/code&gt;는 main 프로세서에서 작동하고 &lt;code&gt;index.html&lt;/code&gt; 및 하위 참조 스크립트들은 browser 프로세스에서 작동합니다.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;자, 이제 기본적인 프로젝트 파일의 구성과 작업 실행 환경이 완료되었습니다.  &lt;code&gt;scripts&lt;/code&gt; 폴더는 정적 또는 동적 테스트 코드, 자동화 관련 코드, 작업 태스크 관리, 빌드 스크립트 등을 넣어둘 장소입니다. 이 글은 개발 환경을 구성하는 데 목적을 두기 때문에 이와 관련한 자세한 내용은 다루지 않을 것입니다. (엄청나게 다양하고 복잡하고 일일이 설명하기가 귀찮기도 하고 뭐 그렇습니다) LICENSE.md, README.md 파일에는 프로젝트와 관련된 내용을 작성하면 됩니다. 이제, 커멘드 라인에 개발에  필요한 모듈들을 설치하고 작업 결과를 확인할 수 있는 브라우저(Electron)를 실행해 봅시다. 'Hello'문자가 보이나요?&lt;/p&gt;
&lt;pre class="bash"&gt;&lt;code&gt;$ npm install&#xD;
$ npm start&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Enjoying Web Development with Electron&lt;/h2&gt;
&lt;p&gt;모든 준비는 끝났습니다. 멋들어지게 최신 자바스크립트 문법을 이용하여 본격적으로 개발을 시작해 봅시다. &lt;code&gt;src/index.js&lt;/code&gt; 파일을 열고 간단한 React 기반의 'Hello,  world!' 애플리케이션을 만들겠습니다.&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;import React from 'react';&#xD;
import ReactDOM from 'react-dom';&#xD;
import $ from 'jquery';&#xD;
import 'jquery-ui/draggable';&#xD;
&#xD;
class Title extends React.Component {&#xD;
  constructor() {&#xD;
    super();&#xD;
    this.state = {&#xD;
      value: 'Hello, world!'&#xD;
    };&#xD;
  }&#xD;
  componentDidMount() {&#xD;
    $(this.refs.el).draggable();&#xD;
  }&#xD;
  render() {&#xD;
    return (&#xD;
      &amp;lt;h1 ref="el"&amp;gt;&#xD;
        {this.state.value}&#xD;
      &amp;lt;/h1&amp;gt;&#xD;
    );&#xD;
  }&#xD;
}&#xD;
&#xD;
ReactDOM.render(&#xD;
  &amp;lt;Title /&amp;gt;,&#xD;
  document.getElementById('example')&#xD;
);&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;파일 작성 후 브라우저 창에서 새로 고칩니다. 단축키는 맥인 경우 CMD+R(윈도: Ctrl+R)입니다. 브라우저 개발자 도구는 CMD+ALT+I(윈도: Ctrl+Shift+I)로 열 수 있습니다. 'Hello, world!' 문자가 보이나요? 정상적으로 작동하는 것입니다. 놀랍죠? 문자의 드래그 앤 드롭 기능도 확인해 보세요!&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;크로스-브라우저는 어찌할까요? Browserify나 Webpack을 이용해서 번들링 한 후 실제 브라우저에서 동작하는 동적-테스트 도구(Nightwatch 와 같은)로 테스트 수행을 자동화하고 오류가 보고되면 그때 처리합니다.&lt;/p&gt;&lt;/blockquote&gt;

			&lt;br&gt;&lt;br&gt;
			&lt;a href="https://firejune.com/1797#p1797"&gt;Comments(3)&lt;/a&gt; |
			&lt;a href="https://firejune.com/1797"&gt;Hits(321,672)&lt;/a&gt;&lt;img src="http://feeds.feedburner.com/~r/firejune/~4/sQ26uwtEA4M" height="1" width="1" alt=""/&gt;</content><feedburner:origLink>https://firejune.com/1797</feedburner:origLink></entry><entry><title type="text">Airbnb의 React/JSX 스타일 가이드</title><link rel="alternate" type="text/html" href="http://feedproxy.google.com/~r/firejune/~3/1eWYnmG1zLs/1795" /><category term="자료-웹개발" /><category term="자바스크립트" /><category term="React" /><category term="JSX" /><category term="스타일 가이드" /><category term="ES6" /><category term="Airbnb" /><category term="Electron" /><category term="CommonJS" /><category term="Node.js" /><author><name>파이어준</name></author><updated>2016-01-11T06:10:07-08:00</updated><id>https://firejune.com/1795</id><content type="html">&lt;p&gt;기왕 &lt;a href="https://firejune.com/1794/Airbnb%EC%9D%98+ES6+%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8+%EC%8A%A4%ED%83%80%EC%9D%BC+%EA%B0%80%EC%9D%B4%EB%93%9C"&gt;번역&lt;/a&gt;한 김에 하나 더 했습니다. Airbnb에서 &lt;a href="https://github.com/airbnb/javascript/tree/master/react"&gt;Reac와 JSX 스타일 가이드&lt;/a&gt;도 작성했더군요. ES6과 JSX기반의 React 코드를 작성하는 것을 마치 기본적인 것인 양 소개하고 있습니다. 요즘 &lt;a href="http://electron.atom.io/"&gt;Electron&lt;/a&gt; 기반 하이브리드 데스크탑 애플리케이션을 개발하고 있는데 전반에 걸쳐 &lt;a href="https://facebook.github.io/react/"&gt;React&lt;/a&gt;를 적용하는 중입니다. Electron은 구글 크롬 브라우저와 Node.js를 포함하고 있어서 하나의 브라우저에서 작동하는 것에만 집중할 수 있고 &lt;a href="http://browserify.org/"&gt;browserify&lt;/a&gt;또는 &lt;a href="https://webpack.github.io/"&gt;webpack&lt;/a&gt;와 같은 모듈 번들러(module bundler)의 도움 없이 네이티브 &lt;code&gt;require&lt;/code&gt;를 브라우저에서도 사용할 수 있다 보니, 의존성(dependency)이나 네임스페이스(namespace) 관리는 물론이고, 실시간 트랜스파일(Transpile)이 가능해서 ES6 코드를 마구 내질러도 크게 문제 될 것이 없는 개발환경을 만들 수 있다는 것은... 이건 뭐 그냥 완전히 다른 세상이라고 밖에 표현하지 못하겠군요.&lt;/p&gt;
&#xD;
&lt;h2&gt;&lt;a id="basic-rules" href="#basic-rules"&gt;1&lt;/a&gt;. 기본 규칙(Basic Rules)&lt;/h2&gt;&#xD;
&#xD;
&lt;ul class="square"&gt;&#xD;
  &lt;li&gt;&#xD;
    하나의 파일에는 오직 하나의 React 컴포넌트를 사용합니다.&#xD;
    그러나, 다중 &lt;a href="https://facebook.github.io/react/docs/reusable-components.html#stateless-functions"&gt;스테이트가 없는(Stateless) 또는 순수한 함수나 컴포넌트&lt;/a&gt;는 허용됩니다.&#xD;
    eslint rule: &lt;a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/no-multi-comp.md#ignorestateless"&gt;&lt;code&gt;react/no-multi-comp&lt;/code&gt;&lt;/a&gt;.&#xD;
  &lt;/li&gt;&#xD;
  &lt;li&gt;항상 JSX 문법을 사용합니다.&lt;/li&gt;&#xD;
  &lt;li&gt;JSX파일이 아닌 다른 app에서 초기화하는 경우를 제외하고는 &lt;code&gt;React.createElement&lt;/code&gt;를 사용하지 않습니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="class-vs-reactcreateclass" href="#class-vs-reactcreateclass"&gt;2&lt;/a&gt;. 클래스(Class) vs React.createClass&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;특별한 이유로 믹스인(mixin)하는 경우를 제외하고는 &lt;code&gt;class extends React.Component&lt;/code&gt;를 사용하세요.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/prefer-es6-class.md"&gt;&lt;code&gt;react/prefer-es6-class&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
const Listing = React.createClass({&#xD;
  render() {&#xD;
    return &amp;lt;div /&amp;gt;;&#xD;
  }&#xD;
});&#xD;
&#xD;
// good&#xD;
class Listing extends React.Component {&#xD;
  render() {&#xD;
    return &amp;lt;div /&amp;gt;;&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="naming" href="#naming"&gt;3&lt;/a&gt;. 명명(Naming)&lt;/h2&gt;&#xD;
&#xD;
&lt;P&gt;&lt;strong&gt;확장자&lt;/strong&gt;: React 컴포넌트는 &lt;code&gt;.jsx&lt;/code&gt; 확장자를 사용합니다.&lt;/P&gt;&#xD;
&lt;P&gt;&lt;strong&gt;파일명&lt;/strong&gt;: 파일명에는 PascalCase(대문자로 시작)를 사용합니다. 예), &lt;code&gt;ReservationCard.jsx&lt;/code&gt;.&lt;/P&gt;&#xD;
&lt;P&gt;&lt;strong&gt;참조명&lt;/strong&gt;: React 컴포넌트의 참조 이름에는 PascalCase를 쓰고 그 인스턴스의 이름에는 camelCase(소문자로 시작)를 사용합니다.&lt;/P&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-pascal-case.md"&gt;&lt;code&gt;react/jsx-pascal-case&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
import reservationCard from './ReservationCard';&#xD;
&#xD;
// good&#xD;
import ReservationCard from './ReservationCard';&#xD;
&#xD;
// bad&#xD;
const ReservationItem = &amp;lt;ReservationCard /&amp;gt;;&#xD;
&#xD;
// good&#xD;
const reservationItem = &amp;lt;ReservationCard /&amp;gt;;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;P&gt;&lt;strong&gt;컴포넌트명&lt;/strong&gt;: 컴포넌트명으로 파일명을 씁니다. 예), &lt;code&gt;ReservationCard.jsx&lt;/code&gt; 파일은 &lt;code&gt;ReservationCard&lt;/code&gt;라는 참조명을 가집니다. 그러나, 루트 컴포넌트가 디렉토리에 구성되었다면 파일명을 &lt;code&gt;index.jsx&lt;/code&gt;로 쓰고 디렉토리명을 컴포넌트명으로 사용합니다:&lt;/P&gt;&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
import Footer from './Footer/Footer';&#xD;
&#xD;
// bad&#xD;
import Footer from './Footer/index';&#xD;
&#xD;
// good&#xD;
import Footer from './Footer';&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="declaration" href="#declaration"&gt;4&lt;/a&gt;. 선언(Declaration)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;displayName&lt;/code&gt;을 이용하여 컴포넌트명을 정하지 않습니다. 그대신, 참조에 의해 이름을 지정합니다.&lt;/p&gt;&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
export default React.createClass({&#xD;
  displayName: 'ReservationCard',&#xD;
  // stuff goes here&#xD;
});&#xD;
&#xD;
// good&#xD;
export default class ReservationCard extends React.Component {&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="alignment" href="#alignment"&gt;5&lt;/a&gt;. 조정(Alignment)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;JSX 구문에 따른 정렬 스타일을 사용합니다.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-closing-bracket-location.md"&gt;&lt;code&gt;react/jsx-closing-bracket-location&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
&amp;lt;Foo superLongParam="bar"&#xD;
     anotherSuperLongParam="baz" /&amp;gt;&#xD;
&#xD;
// good&#xD;
&amp;lt;Foo&#xD;
  superLongParam="bar"&#xD;
  anotherSuperLongParam="baz"&#xD;
/&amp;gt;&#xD;
&#xD;
// if props fit in one line then keep it on the same line&#xD;
&amp;lt;Foo bar="bar" /&amp;gt;&#xD;
&#xD;
// children get indented normally&#xD;
&amp;lt;Foo&#xD;
  superLongParam="bar"&#xD;
  anotherSuperLongParam="baz"&#xD;
&amp;gt;&#xD;
  &amp;lt;Spazz /&amp;gt;&#xD;
&amp;lt;/Foo&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="quotes" href="#quotes"&gt;6&lt;/a&gt;. 인용(Quotes)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;JSX 속성(attributes)에는 항상 큰 따옴표(&lt;code&gt;"&lt;/code&gt;)를 사용합니다. 그러나 다른 모든 자바스크립트에는 작은 따옴표(single quotes)를 사용합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? JSX 속성(attributes)은 &lt;a href="http://eslint.org/docs/rules/jsx-quotes"&gt;따옴표(quotes)의 탈출(escaped)을 포함할 수 없습니다&lt;/a&gt;. 그래서 큰 따옴표를 이용하여 &lt;code&gt;"don't"&lt;/code&gt;와 같은 접속사를 쉽게 입력할 수 있습니다.&#xD;
일반적으로 HTML 속성(attributes)에는 작은 따옴표 대신 큰 따옴표를 사용합니다. 그래서 JSX 속성역시 동일한 규칙이 적용됩니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/jsx-quotes"&gt;&lt;code&gt;jsx-quotes&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
&amp;lt;Foo bar='bar' /&amp;gt;&#xD;
&#xD;
// good&#xD;
&amp;lt;Foo bar="bar" /&amp;gt;&#xD;
&#xD;
// bad&#xD;
&amp;lt;Foo style={{ left: "20px" }} /&amp;gt;&#xD;
&#xD;
// good&#xD;
&amp;lt;Foo style={{ left: '20px' }} /&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="spacing" href="#spacing"&gt;7&lt;/a&gt;. 공백(Spacing)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;자신을 닫는(self-closing) 태그에는 항상 하나의 공백만을 사용합니다.&lt;/p&gt;&#xD;
&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
&amp;lt;Foo/&amp;gt;&#xD;
&#xD;
// very bad&#xD;
&amp;lt;Foo                 /&amp;gt;&#xD;
&#xD;
// bad&#xD;
&amp;lt;Foo&#xD;
 /&amp;gt;&#xD;
&#xD;
// good&#xD;
&amp;lt;Foo /&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="props" href="#props"&gt;8&lt;/a&gt;. 속성(Props)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;prop 이름은 항상 camelCase(소문자로 시작)를 사용합니다.&lt;/p&gt;&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
&amp;lt;Foo&#xD;
  UserName="hello"&#xD;
  phone_number={12345678}&#xD;
/&amp;gt;&#xD;
&#xD;
// good&#xD;
&amp;lt;Foo&#xD;
  userName="hello"&#xD;
  phoneNumber={12345678}&#xD;
/&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;명시적으로 &lt;code&gt;true&lt;/code&gt; 값을 가지는 prop은 그 값을 생략할 수 있습니다.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-boolean-value.md"&gt;&lt;code&gt;react/jsx-boolean-value&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
&amp;lt;Foo&#xD;
  hidden={true}&#xD;
/&amp;gt;&#xD;
&#xD;
// good&#xD;
&amp;lt;Foo&#xD;
  hidden&#xD;
/&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="parentheses" href="#parentheses"&gt;9&lt;/a&gt;. 괄호(Parentheses)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;JSX 태그가 감싸여(Wrap) 있어 한 줄 이상인 경우 괄호(parentheses)를 사용합니다.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/wrap-multilines.md"&gt;&lt;code&gt;react/wrap-multilines&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt; // bad&#xD;
  render() {&#xD;
    return &amp;lt;MyComponent className="long body" foo="bar"&amp;gt;&#xD;
             &amp;lt;MyChild /&amp;gt;&#xD;
           &amp;lt;/MyComponent&amp;gt;;&#xD;
  }&#xD;
  &#xD;
  // good&#xD;
  render() {&#xD;
    return (&#xD;
      &amp;lt;MyComponent className="long body" foo="bar"&amp;gt;&#xD;
        &amp;lt;MyChild /&amp;gt;&#xD;
      &amp;lt;/MyComponent&amp;gt;&#xD;
    );&#xD;
  }&#xD;
  &#xD;
  // good, when single line&#xD;
  render() {&#xD;
    const body = &amp;lt;div&amp;gt;hello&amp;lt;/div&amp;gt;;&#xD;
    return &amp;lt;MyComponent&amp;gt;{body}&amp;lt;/MyComponent&amp;gt;;&#xD;
  }&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="tags" href="#tags"&gt;10&lt;/a&gt;. 태그(Tags)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;자식(children)을 가지지 않는다면 항상 자신을 닫는(self-close) 태그로 작성합니다.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/self-closing-comp.md"&gt;&lt;code&gt;react/self-closing-comp&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
&amp;lt;Foo className="stuff"&amp;gt;&amp;lt;/Foo&amp;gt;&#xD;
&#xD;
// good&#xD;
&amp;lt;Foo className="stuff" /&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;만약, 컴포넌트의 속성(properties)을 여러 줄에 있는 경우, 닫는 태그는 다음 줄에 작성합니다.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-closing-bracket-location.md"&gt;&lt;code&gt;react/jsx-closing-bracket-location&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
&amp;lt;Foo&#xD;
  bar="bar"&#xD;
  baz="baz" /&amp;gt;&#xD;
&#xD;
// good&#xD;
&amp;lt;Foo&#xD;
  bar="bar"&#xD;
  baz="baz"&#xD;
/&amp;gt;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="methods" href="#methods"&gt;11&lt;/a&gt;. 메소드(Methods)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;렌더(Render) 메소드에서 이벤트 핸들러에 바인드(Bind)가 필요한 경우에는 생성자(constructor)에서 합니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 렌더러 메소드에서 바인드(bind)를 호출하게 되면 랜더링 할 때 마다 매번 새로운 함수를 생성하게 됩니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md"&gt;&lt;code&gt;react/jsx-no-bind&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
class extends React.Component {&#xD;
  onClickDiv() {&#xD;
    // do stuff&#xD;
  }&#xD;
&#xD;
  render() {&#xD;
    return &amp;lt;div onClick={this.onClickDiv.bind(this)} /&amp;gt;&#xD;
  }&#xD;
}&#xD;
&#xD;
// good&#xD;
class extends React.Component {&#xD;
  constructor(props) {&#xD;
    super(props);&#xD;
&#xD;
    this.onClickDiv = this.onClickDiv.bind(this);&#xD;
  }&#xD;
&#xD;
  onClickDiv() {&#xD;
    // do stuff&#xD;
  }&#xD;
&#xD;
  render() {&#xD;
    return &amp;lt;div onClick={this.onClickDiv} /&amp;gt;&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;React 컴포넌트의 내부 메소드에 밑줄(underscore)을 접두사로 사용하지 않습니다.&lt;/p&gt;&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;// bad&#xD;
React.createClass({&#xD;
  _onClickSubmit() {&#xD;
    // do stuff&#xD;
  },&#xD;
&#xD;
  // other stuff&#xD;
});&#xD;
&#xD;
// good&#xD;
class extends React.Component {&#xD;
  onClickSubmit() {&#xD;
    // do stuff&#xD;
  }&#xD;
&#xD;
  // other stuff&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="ordering" href="#ordering"&gt;12&lt;/a&gt;. 호출순서(Ordering)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;class extends React.Component&lt;/code&gt;의 호출순서(Ordering):&lt;/p&gt;&#xD;
&lt;ul class="number"&gt;&#xD;
&lt;li&gt;&lt;code&gt;constructor&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;추가적인(optional) &lt;code&gt;static&lt;/code&gt; 메소드&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;getChildContext&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;componentWillMount&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;componentDidMount&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;componentWillReceiveProps&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;shouldComponentUpdate&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;componentWillUpdate&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;componentDidUpdate&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;componentWillUnmount&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;onClickSubmit()&lt;/code&gt;와 같은 &lt;em&gt;clickHandlers 또는 eventHandlers&lt;/em&gt; 또는 &lt;code&gt;onChangeDescription()&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;getSelectReason()&lt;/code&gt;와 같은 &lt;em&gt;&lt;code&gt;render&lt;/code&gt;를 위한 getter methods&lt;/em&gt; 또는 &lt;code&gt;getFooterContent()&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;renderNavigation()&lt;/code&gt;와 같은 &lt;em&gt;추가적인 렌더러 메소드&lt;/em&gt; 또는 &lt;code&gt;renderProfilePicture()&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;p&gt;&lt;code&gt;render&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;React.createClass&lt;/code&gt;의 호출순서(Ordering):&lt;/p&gt;&#xD;
&lt;ul class="number"&gt;&#xD;
&lt;li&gt;&lt;code&gt;displayName&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;propTypes&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;contextTypes&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;childContextTypes&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;mixins&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;statics&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;defaultProps&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;getDefaultProps&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;getInitialState&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;getChildContext&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;componentWillMount&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;componentDidMount&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;componentWillReceiveProps&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;shouldComponentUpdate&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;componentWillUpdate&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;componentDidUpdate&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;componentWillUnmount&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;onClickSubmit()&lt;/code&gt;와 같은 &lt;em&gt;clickHandlers 또는 eventHandlers&lt;/em&gt; 또는 &lt;code&gt;onChangeDescription()&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;getSelectReason()&lt;/code&gt;와 같은 &lt;em&gt;&lt;code&gt;render&lt;/code&gt;를 위한 getter methods&lt;/em&gt; 또는 &lt;code&gt;getFooterContent()&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;code&gt;renderNavigation()&lt;/code&gt;와 같은 &lt;em&gt;추가적인 렌더러 메소드&lt;/em&gt; 또는 &lt;code&gt;renderProfilePicture()&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;li&gt;&lt;p&gt;&lt;code&gt;render&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/sort-comp.md"&gt;&lt;code&gt;react/sort-comp&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;propTypes&lt;/code&gt;, &lt;code&gt;defaultProps&lt;/code&gt;, &lt;code&gt;contextTypes&lt;/code&gt;, 등을 어떻게 정의할까요...&lt;/p&gt;&#xD;
&lt;pre class="jsx"&gt;&lt;code&gt;import React, { PropTypes } from 'react';&#xD;
&#xD;
const propTypes = {&#xD;
  id: PropTypes.number.isRequired,&#xD;
  url: PropTypes.string.isRequired,&#xD;
  text: PropTypes.string,&#xD;
};&#xD;
&#xD;
const defaultProps = {&#xD;
  text: 'Hello World',&#xD;
};&#xD;
&#xD;
class Link extends React.Component {&#xD;
  static methodsAreOk() {&#xD;
    return true;&#xD;
  }&#xD;
&#xD;
  render() {&#xD;
    return &amp;lt;a href={this.props.url} data-id={this.props.id}&amp;gt;{this.props.text}&amp;lt;/a&amp;gt;&#xD;
  }&#xD;
}&#xD;
&#xD;
Link.propTypes = propTypes;&#xD;
Link.defaultProps = defaultProps;&#xD;
&#xD;
export default Link;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="ismounted" href="#ismounted"&gt;13&lt;/a&gt;. isMounted&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;isMounted&lt;/code&gt;는 사용하지 않습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? &lt;code&gt;isMounted&lt;/code&gt;는 &lt;a href="https://facebook.github.io/react/blog/2015/12/16/ismounted-antipattern.html"&gt;안티-패턴(anti-pattern)&lt;/a&gt;입니다. ES6 클래스에서는 사용할수도 없습니다. 그리고 공식적으로 사용되지 않게(deprecated) 될 것입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&#xD;
&lt;p&gt;eslint rules: &lt;a href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/no-is-mounted.md"&gt;&lt;code&gt;react/no-is-mounted&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;


			&lt;br&gt;&lt;br&gt;
			&lt;a href="https://firejune.com/1795#p1795"&gt;Comments&lt;/a&gt; |
			&lt;a href="https://firejune.com/1795"&gt;Hits(334,131)&lt;/a&gt;&lt;img src="http://feeds.feedburner.com/~r/firejune/~4/1eWYnmG1zLs" height="1" width="1" alt=""/&gt;</content><feedburner:origLink>https://firejune.com/1795</feedburner:origLink></entry><entry><title type="text">Airbnb의 ES6 자바스크립트 스타일 가이드</title><link rel="alternate" type="text/html" href="http://feedproxy.google.com/~r/firejune/~3/qvJO3nY1X34/1794" /><category term="자료-웹개발" /><category term="ES6" /><category term="ES5" /><category term="ECMAScript 2015" /><category term="Airbnb" /><category term="자바스크립트" /><category term="스타일 가이드" /><category term="까막눈" /><category term="Node.js" /><author><name>파이어준</name></author><updated>2016-01-10T16:39:45-08:00</updated><id>https://firejune.com/1794</id><content type="html">&lt;p&gt;&lt;a href="https://people.mozilla.org/~jorendorff/es6-draft.html"&gt;ECMAScript 2015&lt;/a&gt;(ES6)가 우후죽순처럼 활개를 치고 있습니다. &lt;a href="https://en.wikipedia.org/wiki/Source-to-source_compiler"&gt;Transpile&lt;/a&gt;(Source-to-source compiler)이 필요한 소스들은 몇 번이고 무시하려고 했지만 ES6만큼은 그러지 못했습니다. 요즘 왠만한 Node.js 프로젝트나 &lt;a href="https://facebook.github.io/react/"&gt;React&lt;/a&gt;에 기반을 둬서 나오는 결과물들은 이미 장악되었다고 해도 과언이 아닐정도로 많은 사람이 애용하고 있어, 원만히 소스를 읽는 데에 큰 장애가 생겨났습니다. 이런, 까막눈이 되고 말았군요. 그러던 중 때마침 Airbnb에서 ES5이었던 &lt;a href="https://github.com/airbnb/javascript"&gt;자바스크립트 스타일 가이드&lt;/a&gt;를 ES6으로 업데이트했기에 학습차 번역해 보았습니다.&lt;/p&gt;
&lt;h2&gt;&lt;a id="types" href="#types"&gt;1&lt;/a&gt;. 유형(Types)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;&lt;strong&gt;Primitives&lt;/strong&gt;: 원시형(Primitive type)은 그 값을 직접 조작합니다.&lt;/p&gt;&#xD;
&lt;ul class="square"&gt;&#xD;
  &lt;li&gt;&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;code&gt;number&lt;/code&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const foo = 1;&#xD;
let bar = foo;&#xD;
&#xD;
bar = 9;&#xD;
&#xD;
console.log(foo, bar); // =&gt; 1, 9&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;strong&gt;Complex&lt;/strong&gt;: 참조형(Complex type)은 참조를 통해 값을 조작합니다.&lt;/p&gt;&#xD;
&lt;ul class="square"&gt;&#xD;
  &lt;li&gt;&lt;code&gt;object&lt;/code&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;code&gt;array&lt;/code&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;code&gt;function&lt;/code&gt;&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const foo = [1, 2];&#xD;
const bar = foo;&#xD;
&#xD;
bar[0] = 9;&#xD;
&#xD;
console.log(foo[0], bar[0]); // =&gt; 9, 9&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="references" href="#references"&gt;2&lt;/a&gt;. 참조(References)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;모든 참조에는 &lt;code&gt;const&lt;/code&gt;를 사용하고 &lt;code&gt;var&lt;/code&gt;를 사용하지 않습니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 참조를 다시 할당할 수 없어서, 버그로 연결되거나 이해하기 어려운 코드가 되는 것을 예방합니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/prefer-const.html"&gt;&lt;code&gt;prefer-const&lt;/code&gt;&lt;/a&gt;, &lt;a href="http://eslint.org/docs/rules/no-const-assign.html"&gt;&lt;code&gt;no-const-assign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
var a = 1;&#xD;
var b = 2;&#xD;
&#xD;
// good&#xD;
const a = 1;&#xD;
const b = 2;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;참조를 다시 할당해야 하는 경우 &lt;code&gt;var&lt;/code&gt; 대신에 &lt;code&gt;let&lt;/code&gt;을 사용하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? &lt;code&gt;var&lt;/code&gt;는 함수-범위(function-scoped)이고 &lt;code&gt;let&lt;/code&gt;은 블록-범위(block-scoped)이기 때문입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/no-var.html"&gt;&lt;code&gt;no-var&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
var count = 1;&#xD;
if (true) {&#xD;
  count += 1;&#xD;
}&#xD;
&#xD;
// good, use the let.&#xD;
let count = 1;&#xD;
if (true) {&#xD;
  count += 1;&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;let&lt;/code&gt;과 &lt;code&gt;const&lt;/code&gt;는 모두 블록-범위(block-scoped)인 것에 주의해야 합니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// const와 let은 선언 된 블록 안에서만 존재함. &#xD;
{&#xD;
  let a = 1;&#xD;
  const b = 1;&#xD;
}&#xD;
console.log(a); // ReferenceError&#xD;
console.log(b); // ReferenceError&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="objects" href="#objects"&gt;3&lt;/a&gt;. 객체(Objects)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;객체를 만들 때에는 리터럴 구문을 사용합니다.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/no-new-object.html"&gt;&lt;code&gt;no-new-object&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const item = new Object();&#xD;
&#xD;
// good&#xD;
const item = {};&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;코드가 브라우저에서 실행되는 경우 &lt;a href="http://es5.github.io/#x7.6.1"&gt;예약어&lt;/a&gt;를 키로 사용하지 마세요. 이것은 IE8에서 작동하지 않습니다. &lt;a href="https://github.com/airbnb/javascript/issues/61"&gt;더 알아보기&lt;/a&gt;. ES6 모듈과 서버 사이드에서는 사용할 수 있습니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const superman = {&#xD;
  default: { clark: 'kent' },&#xD;
  private: true,&#xD;
};&#xD;
&#xD;
// good&#xD;
const superman = {&#xD;
  defaults: { clark: 'kent' },&#xD;
  hidden: true,&#xD;
};&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;예약어 대신에 알기 쉬운 동의어(Readable Synonyms)를 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const superman = {&#xD;
  class: 'alien',&#xD;
};&#xD;
&#xD;
// bad&#xD;
const superman = {&#xD;
  klass: 'alien',&#xD;
};&#xD;
&#xD;
// good&#xD;
const superman = {&#xD;
  type: 'alien',&#xD;
};&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a name="es6-computed-properties"&gt;&lt;/a&gt;&lt;/p&gt;&#xD;
&lt;p&gt;동적인 속성 이름을 가진 객체를 만들 때에는 계산된 속성 이름(Computed Property Names)을 사용하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 이렇게하면 객체 속성을 한 개의 장소에서 정의 할 수 있습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;function getKey(k) {&#xD;
  return `a key named ${k}`;&#xD;
}&#xD;
&#xD;
// bad&#xD;
const obj = {&#xD;
  id: 5,&#xD;
  name: 'San Francisco',&#xD;
};&#xD;
obj[getKey('enabled')] = true;&#xD;
&#xD;
// good&#xD;
const obj = {&#xD;
  id: 5,&#xD;
  name: 'San Francisco',&#xD;
  [getKey('enabled')]: true,&#xD;
};&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a name="es6-object-shorthand"&gt;&lt;/a&gt;&lt;/p&gt;&#xD;
&lt;p&gt;메소드에 단축 구문(Object Shorthand)을 사용하세요.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/object-shorthand.html"&gt;&lt;code&gt;object-shorthand&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const atom = {&#xD;
  value: 1,&#xD;
&#xD;
  addValue: function (value) {&#xD;
    return atom.value + value;&#xD;
  },&#xD;
};&#xD;
&#xD;
// good&#xD;
const atom = {&#xD;
  value: 1,&#xD;
&#xD;
  addValue(value) {&#xD;
    return atom.value + value;&#xD;
  },&#xD;
};&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a name="es6-object-concise"&gt;&lt;/a&gt;&lt;/p&gt;&#xD;
&lt;p&gt;속성에 단축 구문(Object Concise)을 사용하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 표현이나 설명이 간결해지기 때문입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/object-shorthand.html"&gt;&lt;code&gt;object-shorthand&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const lukeSkywalker = 'Luke Skywalker';&#xD;
&#xD;
// bad&#xD;
const obj = {&#xD;
  lukeSkywalker: lukeSkywalker,&#xD;
};&#xD;
&#xD;
// good&#xD;
const obj = {&#xD;
  lukeSkywalker,&#xD;
};&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;속성의 단축 구문(Object Concise)은 객체 선언의 시작 부분에 무리를 지어줍니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 어떤 속성이 단축 구문을 사용하고 있는지를 알기가 쉽기 때문입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const anakinSkywalker = 'Anakin Skywalker';&#xD;
const lukeSkywalker = 'Luke Skywalker';&#xD;
&#xD;
// bad&#xD;
const obj = {&#xD;
  episodeOne: 1,&#xD;
  twoJediWalkIntoACantina: 2,&#xD;
  lukeSkywalker,&#xD;
  episodeThree: 3,&#xD;
  mayTheFourth: 4,&#xD;
  anakinSkywalker,&#xD;
};&#xD;
&#xD;
// good&#xD;
const obj = {&#xD;
  lukeSkywalker,&#xD;
  anakinSkywalker,&#xD;
  episodeOne: 1,&#xD;
  twoJediWalkIntoACantina: 2,&#xD;
  episodeThree: 3,&#xD;
  mayTheFourth: 4,&#xD;
};&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;속성 이름에 작은 따옴표를 사용하는 경우는 오직 잘못된 식별자(Invalid Identifiers)일 때입니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 주관적으로 쉽게 읽을 수 있는 것을 항상 고민해야 합니다. 이 것은 구문이 강조되고, 수많은 JS엔진에 쉽게 최적화되어 있습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/quote-props.html"&gt;&lt;code&gt;quote-props&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const bad = {&#xD;
  'foo': 3,&#xD;
  'bar': 4,&#xD;
  'data-blah': 5,&#xD;
};&#xD;
&#xD;
// good&#xD;
const good = {&#xD;
  foo: 3,&#xD;
  bar: 4,&#xD;
  'data-blah': 5,&#xD;
};&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="arrays" href="#arrays"&gt;4&lt;/a&gt;. 배열(Arrays)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;배열을 만들 때 리터럴 구문을 사용하세요.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/no-array-constructor.html"&gt;&lt;code&gt;no-array-constructor&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const items = new Array();&#xD;
&#xD;
// good&#xD;
const items = [];&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;배열에 항목을 직접 대체하지 말고 Array#push를 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const someStack = [];&#xD;
&#xD;
// bad&#xD;
someStack[someStack.length] = 'abracadabra';&#xD;
&#xD;
// good&#xD;
someStack.push('abracadabra');&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a name="es6-array-spreads"&gt;&lt;/a&gt;&lt;/p&gt;&#xD;
&lt;p&gt;배열을 복사하는 경우, 배열의 확장 연산자인 &lt;code&gt;...&lt;/code&gt;을 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const len = items.length;&#xD;
const itemsCopy = [];&#xD;
let i;&#xD;
&#xD;
for (i = 0; i $lt; len; i++) {&#xD;
  itemsCopy[i] = items[i];&#xD;
}&#xD;
&#xD;
// good&#xD;
const itemsCopy = [...items];&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;Array-Like 객체를 배열로 변환하려면 Array#from을 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const foo = document.querySelectorAll('.foo');&#xD;
const nodes = Array.from(foo);&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="destructuring" href="#destructuring"&gt;5&lt;/a&gt;. 구조화 대입(Destructuring)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;여러 속성에서 객체에 접근할 때 객체 구조화 대입(Destructuring)을 사용하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 구조화 대입을 이용하여 그 속성에 대한 중간 참조를 줄일 수 있습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function getFullName(user) {&#xD;
  const firstName = user.firstName;&#xD;
  const lastName = user.lastName;&#xD;
&#xD;
  return `${firstName} ${lastName}`;&#xD;
}&#xD;
&#xD;
// good&#xD;
function getFullName(user) {&#xD;
  const { firstName, lastName } = user;&#xD;
  return `${firstName} ${lastName}`;&#xD;
}&#xD;
&#xD;
// best&#xD;
function getFullName({ firstName, lastName }) {&#xD;
  return `${firstName} ${lastName}`;&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;배열에 구조화 대입(Destructuring)을 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const arr = [1, 2, 3, 4];&#xD;
&#xD;
// bad&#xD;
const first = arr[0];&#xD;
const second = arr[1];&#xD;
&#xD;
// good&#xD;
const [first, second] = arr;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;여러 값을 반환하는 경우, 배열의 구조화 대입이 아니라 객체의 구조화 대입을 사용하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 이렇게하면 나중에 새 속성을 추가하거나 호출에 영향을 주지않고 순서를 변경할 수 있습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function processInput(input) {&#xD;
  // 그러면 기적이 일어난다&#xD;
  return [left, right, top, bottom];&#xD;
}&#xD;
&#xD;
// 호출자에 반환되는 데이터의 순서를 고려해야 함&#xD;
const [left, __, top] = processInput(input);&#xD;
&#xD;
// good&#xD;
function processInput(input) {&#xD;
  // 그러면 기적이 일어난다&#xD;
  return { left, right, top, bottom };&#xD;
}&#xD;
&#xD;
// 호출하면서 필요한 데이터만 선택할 수 있음&#xD;
const { left, right } = processInput(input);&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="strings" href="#strings"&gt;6&lt;/a&gt;. 문자열(Strings)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;문자열에는 작은 따옴표&lt;code&gt;''&lt;/code&gt;를 사용하세요.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/quotes.html"&gt;&lt;code&gt;quotes&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const name = "Capt. Janeway";&#xD;
&#xD;
// good&#xD;
const name = 'Capt. Janeway';&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;100자 이상의 문자열은 여러 행을 사용하여 연결할 수 있습니다.&lt;/p&gt;&#xD;
&lt;p&gt;주의: 문자열 연결이 많으면 성능에 영향을 줄 수 있습니다. &lt;a href="http://jsperf.com/ya-string-concat"&gt;jsPerf&lt;/a&gt; &amp;amp; &lt;a href="https://github.com/airbnb/javascript/issues/40"&gt;Discussion&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';&#xD;
&#xD;
// bad&#xD;
const errorMessage = 'This is a super long error that was thrown because \&#xD;
of Batman. When you stop to think about how Batman had anything to do \&#xD;
with this, you would get nowhere \&#xD;
fast.';&#xD;
&#xD;
// good&#xD;
const errorMessage = 'This is a super long error that was thrown because ' +&#xD;
  'of Batman. When you stop to think about how Batman had anything to do ' +&#xD;
  'with this, you would get nowhere fast.';&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a name="es6-template-literals"&gt;&lt;/a&gt;&lt;/p&gt;&#xD;
&lt;p&gt;프로그램에서 문자열을 생성하는 경우, 문자열 연결이 아닌 템플릿 문자열(Template Strings)을 사용하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 템플릿 문자열의 문자열 완성 기능과 다중 문자열 기능을 가진 간결한 구문으로 가독성이 좋아지기 때문입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/prefer-template.html"&gt;&lt;code&gt;prefer-template&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function sayHi(name) {&#xD;
  return 'How are you, ' + name + '?';&#xD;
}&#xD;
&#xD;
// bad&#xD;
function sayHi(name) {&#xD;
  return ['How are you, ', name, '?'].join();&#xD;
}&#xD;
&#xD;
// good&#xD;
function sayHi(name) {&#xD;
  return `How are you, ${name}?`;&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;a href="#6.5" name="6.5"&gt;&lt;/a&gt; 절대로 &lt;code&gt;eval()&lt;/code&gt;을 사용하지 않습니다. 이것은 지금까지 수많은 취약점을 만들어 왔기 때문입니다.&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="functions" href="#functions"&gt;7&lt;/a&gt;. 함수(Functions)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;함수 선언 대신에 함수 표현식을 사용합니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 이름이 붙은 함수 선언은 콜스택에서 쉽게 알수 있습니다. 또한 함수 선언의 몸 전체가 Hoist됩니다. 반면 함수는 참조만 Hoist됩니다. 이 규칙은 함수 부분을 항상 &lt;a href="#arrow-functions"&gt;애로우 함수&lt;/a&gt;로 대체 사용할 수 있습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const foo = function () {&#xD;
};&#xD;
&#xD;
// good&#xD;
function foo() {&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;함수 표현식(Function expressions):&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// 즉시-호출(Immediately-Invoked) 함수 표현식(IIFE)&#xD;
(() =&gt; {&#xD;
  console.log('Welcome to the Internet. Please follow me.');&#xD;
})();&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;함수 이외의 블록 (&lt;code&gt;if&lt;/code&gt;나 &lt;code&gt;while&lt;/code&gt; 등)에 함수를 선언하지 않습니다. 브라우저는 변수에 함수를 할당하는 처리를 할 수는 있지만, 모두 다르게 해석됩니다.&lt;/p&gt;&#xD;
&lt;p&gt;&lt;strong&gt;주의:&lt;/strong&gt; ECMA-262에서 &lt;code&gt;block&lt;/code&gt;은 statements 목록에 정의되지만, 함수 선언은 statements가 없습니다. &lt;a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf#page=97"&gt;이 문제는 ECMA-262의 설명을 참조하세요&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
if (currentUser) {&#xD;
  function test() {&#xD;
    console.log('Nope.');&#xD;
  }&#xD;
}&#xD;
&#xD;
// good&#xD;
let test;&#xD;
if (currentUser) {&#xD;
  test = () =&gt; {&#xD;
    console.log('Yup.');&#xD;
  };&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;매개변수(parameter)에 &lt;code&gt;arguments&lt;/code&gt;를 절대로 지정하지 않습니다. 이것은 함수 영역으로 전달 될 &lt;code&gt;arguments&lt;/code&gt;객체의 참조를 덮어 써버릴 것입니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function nope(name, options, arguments) {&#xD;
  // ...stuff...&#xD;
}&#xD;
&#xD;
// good&#xD;
function yup(name, options, args) {&#xD;
  // ...stuff...&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a name="es6-rest"&gt;&lt;/a&gt;&lt;/p&gt;&#xD;
&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt;를 사용하지 않습니다. 대신 레스트(Rest) 문법인 &lt;code&gt;...&lt;/code&gt;을 사용하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? &lt;code&gt;...&lt;/code&gt; 를 이용하여 여러가지 매개변수를 모두 사용할 수 있습니다. 추가로 rest 매개변수인 &lt;code&gt;arguments&lt;/code&gt;는 Array-Like 객체가 아니라 진정한 배열(Array)입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function concatenateAll() {&#xD;
  const args = Array.prototype.slice.call(arguments);&#xD;
  return args.join('');&#xD;
}&#xD;
&#xD;
// good&#xD;
function concatenateAll(...args) {&#xD;
  return args.join('');&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a name="es6-default-parameters"&gt;&lt;/a&gt;&lt;/p&gt;&#xD;
&lt;p&gt;함수의 매개변수를 조작하지 말고 기본 매개변수(Default Parameters)를 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// really bad&#xD;
function handleThings(opts) {&#xD;
  // 안되! 함수의 매개변수를 조작하지 않습니다. &#xD;
  // 만약 opts가 falsy 인 경우는 바란대로 객체가 설정됩니다. &#xD;
  // 그러나 미묘한 버그를 일으키는 원인이 될수도 있습니다. &#xD;
  opts = opts || {};&#xD;
  // ...&#xD;
}&#xD;
&#xD;
// still bad&#xD;
function handleThings(opts) {&#xD;
  if (opts === void 0) {&#xD;
    opts = {};&#xD;
  }&#xD;
  // ...&#xD;
}&#xD;
&#xD;
// good&#xD;
function handleThings(opts = {}) {&#xD;
  // ...&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;부작용이 있는 기본 매개변수를 사용하지 않습니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 혼란스럽기 때문입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;var b = 1;&#xD;
// bad&#xD;
function count(a = b++) {&#xD;
  console.log(a);&#xD;
}&#xD;
count();  // 1&#xD;
count();  // 2&#xD;
count(3); // 3&#xD;
count();  // 3&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;항상 기본 매개변수는 앞쪽에 배치하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function handleThings(opts = {}, name) {&#xD;
  // ...&#xD;
}&#xD;
&#xD;
// good&#xD;
function handleThings(name, opts = {}) {&#xD;
  // ...&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;새로운 함수를 만드는 데 Function 생성자를 사용하지 않습니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 이 방법은 문자열을 구분하는 새로운 함수를 만들 수 있는 eval()과 같은 취약점이 발생할 수 있습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
var add = new Function('a', 'b', 'return a + b');&#xD;
&#xD;
// still bad&#xD;
var subtract = Function('a', 'b', 'return a - b');&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;함수 시그네이쳐(Signature)에 공백을 사용합니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 일관성이 좋고, 함수이름을 추가 하거나 삭제할 때 공백을 제거할 필요가 없습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const f = function(){};&#xD;
const g = function (){};&#xD;
const h = function() {};&#xD;
&#xD;
// good&#xD;
const x = function () {};&#xD;
const y = function a() {};&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;절대로 매개변수를 조작하지 않습니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 매개변수로 전달 된 객체를 조작하는 것은 원래의 호출에 원치 않는 변수 부작용을 일으킬 수 있습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/no-param-reassign.html"&gt;&lt;code&gt;no-param-reassign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function f1(obj) {&#xD;
  obj.key = 1;&#xD;
};&#xD;
&#xD;
// good&#xD;
function f2(obj) {&#xD;
  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;&#xD;
};&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;절대로 매개변수를 다시 지정하지 않습니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? &lt;code&gt;arguments&lt;/code&gt; 객체에 접근하는 경우 다시 지정된 매개변수는 예기치 않은 동작이 발생할 수 있습니다. 그리고 특히 V8 최적화에 문제가 발생할 수 있습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/no-param-reassign.html"&gt;&lt;code&gt;no-param-reassign&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function f1(a) {&#xD;
  a = 1;&#xD;
}&#xD;
&#xD;
function f2(a) {&#xD;
  if (!a) { a = 1; }&#xD;
}&#xD;
&#xD;
// good&#xD;
function f3(a) {&#xD;
  const b = a || 1;&#xD;
}&#xD;
&#xD;
function f4(a = 1) {&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="arrow-functions" href="#arrow-functions"&gt;8&lt;/a&gt;. 애로우 함수(Arrow Functions)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;함수 표현식을 사용해야하는 경우(익명 함수와 같은), 애로우 함수(Arrow Functions)를 사용하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 애로우 함수는 함수가 실행되는 컨텍스트의 &lt;code&gt;this&lt;/code&gt;를 가두어줍니다. 이것은 너무나 원했던 것이며 구문도 더욱 간결해집니다.&lt;/p&gt;&#xD;
&lt;p&gt;언제 쓰죠? 복잡한 함수 논리를 정의한 함수의 바깥쪽으로 이동하고 싶은 경우입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/prefer-arrow-callback.html"&gt;&lt;code&gt;prefer-arrow-callback&lt;/code&gt;&lt;/a&gt;, &lt;a href="http://eslint.org/docs/rules/arrow-spacing.html"&gt;&lt;code&gt;arrow-spacing&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
[1, 2, 3].map(function (x) {&#xD;
  const y = x + 1;&#xD;
  return x * y;&#xD;
});&#xD;
&#xD;
// good&#xD;
[1, 2, 3].map((x) =&gt; {&#xD;
  const y = x + 1;&#xD;
  return x * y;&#xD;
});&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;함수의 본체가 하나의 표현식으로 구성되어있는 경우 중괄호&lt;code&gt;{}&lt;/code&gt;를 생략하고 암묵적 &lt;code&gt;return&lt;/code&gt;을 사용할 수 있습니다. 그렇지 않으면 &lt;code&gt;return&lt;/code&gt; 문을 사용해야 합니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 가독성이 좋아지기 때문입니다. 여러 함수가 연결되는 경우에 쉽게 읽을 수 있습니다.&lt;/p&gt;&#xD;
&lt;p&gt;언제 쓰죠? 객체를 반환하는 경우.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/arrow-parens.html"&gt;&lt;code&gt;arrow-parens&lt;/code&gt;&lt;/a&gt;, &lt;a href="http://eslint.org/docs/rules/arrow-body-style.html"&gt;&lt;code&gt;arrow-body-style&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// good&#xD;
[1, 2, 3].map(number =&gt; `A string containing the ${number}.`);&#xD;
&#xD;
// bad&#xD;
[1, 2, 3].map(number =&gt; {&#xD;
  const nextNumber = number + 1;&#xD;
  `A string containing the ${nextNumber}.`;&#xD;
});&#xD;
&#xD;
// good&#xD;
[1, 2, 3].map(number =&gt; {&#xD;
  const nextNumber = number + 1;&#xD;
  return `A string containing the ${nextNumber}.`;&#xD;
});&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;구문의 길이가 여러 행에 걸치는 경우 가독성을 향상시키기 위해 괄호&lt;code&gt;()&lt;/code&gt; 안에 써주세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 함수의 시작과 끝 부분을 알아보기 쉽게 합니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
[1, 2, 3].map(number =&gt; 'As time went by, the string containing the ' +&#xD;
  `${number} became much longer. So we needed to break it over multiple ` +&#xD;
  'lines.'&#xD;
);&#xD;
&#xD;
// good&#xD;
[1, 2, 3].map(number =&gt; (&#xD;
  `As time went by, the string containing the ${number} became much ` +&#xD;
  'longer. So we needed to break it over multiple lines.'&#xD;
));&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;함수의 인수가 한 개인 경우 괄호&lt;code&gt;()&lt;/code&gt;를 생략할 수 있습니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 시각적 혼란이 덜하기 때문입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/arrow-parens.html"&gt;&lt;code&gt;arrow-parens&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
[1, 2, 3].map((x) =&gt; x * x);&#xD;
&#xD;
// good&#xD;
[1, 2, 3].map(x =&gt; x * x);&#xD;
&#xD;
// good&#xD;
[1, 2, 3].map(number =&gt; (&#xD;
  `A long string with the ${number}. It’s so long that we’ve broken it ` +&#xD;
  'over multiple lines!'&#xD;
));&#xD;
&#xD;
// bad&#xD;
[1, 2, 3].map(x =&gt; {&#xD;
  const y = x + 1;&#xD;
  return x * y;&#xD;
});&#xD;
&#xD;
// good&#xD;
[1, 2, 3].map((x) =&gt; {&#xD;
  const y = x + 1;&#xD;
  return x * y;&#xD;
});&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="constructors" href="#constructors"&gt;9&lt;/a&gt;. 생성자(Constructors)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;prototype&lt;/code&gt;의 직접 조작을 피하고 항상 &lt;code&gt;class&lt;/code&gt;를 사용하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? &lt;code&gt;class&lt;/code&gt; 구문은 간결하고 의도를 알아내기가 쉽기 때문입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function Queue(contents = []) {&#xD;
  this._queue = [...contents];&#xD;
}&#xD;
Queue.prototype.pop = function () {&#xD;
  const value = this._queue[0];&#xD;
  this._queue.splice(0, 1);&#xD;
  return value;&#xD;
}&#xD;
&#xD;
&#xD;
// good&#xD;
class Queue {&#xD;
  constructor(contents = []) {&#xD;
    this._queue = [...contents];&#xD;
  }&#xD;
  pop() {&#xD;
    const value = this._queue[0];&#xD;
    this._queue.splice(0, 1);&#xD;
    return value;&#xD;
  }&#xD;
}&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;상속에는 &lt;code&gt;extends&lt;/code&gt;를 사용하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 프로토타입을 상속하기 위해 내장된 방식으로 &lt;code&gt;instanceof&lt;/code&gt; 를 파괴할 수 없기 때문입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const inherits = require('inherits');&#xD;
function PeekableQueue(contents) {&#xD;
  Queue.apply(this, contents);&#xD;
}&#xD;
inherits(PeekableQueue, Queue);&#xD;
PeekableQueue.prototype.peek = function () {&#xD;
  return this._queue[0];&#xD;
}&#xD;
&#xD;
// good&#xD;
class PeekableQueue extends Queue {&#xD;
  peek() {&#xD;
    return this._queue[0];&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;메소드의 반환값에 &lt;code&gt;this&lt;/code&gt;를 돌려주는 것으로, 메소드 체인을 구현할 수 있습니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
Jedi.prototype.jump = function () {&#xD;
  this.jumping = true;&#xD;
  return true;&#xD;
};&#xD;
&#xD;
Jedi.prototype.setHeight = function (height) {&#xD;
  this.height = height;&#xD;
};&#xD;
&#xD;
const luke = new Jedi();&#xD;
luke.jump(); // =&gt; true&#xD;
luke.setHeight(20); // =&gt; undefined&#xD;
&#xD;
// good&#xD;
class Jedi {&#xD;
  jump() {&#xD;
    this.jumping = true;&#xD;
    return this;&#xD;
  }&#xD;
&#xD;
  setHeight(height) {&#xD;
    this.height = height;&#xD;
    return this;&#xD;
  }&#xD;
}&#xD;
&#xD;
const luke = new Jedi();&#xD;
&#xD;
luke.jump()&#xD;
  .setHeight(20);&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;조작된(Custom) &lt;code&gt;toString()&lt;/code&gt; 메소드를 이용할 수도 있지만, 올바르게 작동 하는지, 부작용이 없는지를 꼭 확인하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;class Jedi {&#xD;
  constructor(options = {}) {&#xD;
    this.name = options.name || 'no name';&#xD;
  }&#xD;
&#xD;
  getName() {&#xD;
    return this.name;&#xD;
  }&#xD;
&#xD;
  toString() {&#xD;
    return `Jedi - ${this.getName()}`;&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="modules" href="#modules"&gt;10&lt;/a&gt;. 모듈(Modules)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;비표준 모듈 시스템이 아니라면 항상 (&lt;code&gt;import&lt;/code&gt;/&lt;code&gt;export&lt;/code&gt;) 를 사용하세요. 이렇게 함으로써 원하는 모듈 시스템에 언제든지 트랜스파일(Transpile) 할 수 있습니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 모듈은 곧 미래입니다. 미래를 선점하고 애용합시다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const AirbnbStyleGuide = require('./AirbnbStyleGuide');&#xD;
module.exports = AirbnbStyleGuide.es6;&#xD;
&#xD;
// ok&#xD;
import AirbnbStyleGuide from './AirbnbStyleGuide';&#xD;
export default AirbnbStyleGuide.es6;&#xD;
&#xD;
// best&#xD;
import { es6 } from './AirbnbStyleGuide';&#xD;
export default es6;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;와일드카드를 이용한 가져오기는 사용하지 않습니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? single default export인 것에 주의할 필요가 있기 때문입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
import * as AirbnbStyleGuide from './AirbnbStyleGuide';&#xD;
&#xD;
// good&#xD;
import AirbnbStyleGuide from './AirbnbStyleGuide';&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;import 문에서 직접 추출(Export)하지 않습니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 한개의 라인이라 간결하기는 하지만, import와 export하는 방법을 명확하게 구분함으로써 일관성을 유지할 수 있습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
// filename es6.js&#xD;
export { es6 as default } from './airbnbStyleGuide';&#xD;
&#xD;
// good&#xD;
// filename es6.js&#xD;
import { es6 } from './AirbnbStyleGuide';&#xD;
export default es6;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="iterators-and-generators" href="#iterators-and-generators"&gt;11&lt;/a&gt;. 이터레이터와 제너레이터(Iterators and Generators)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;이터레이터(Iterators)를 사용하지 않습니다. &lt;code&gt;for-of&lt;/code&gt; 루프 대신  &lt;code&gt;map()&lt;/code&gt;과 &lt;code&gt;reduce()&lt;/code&gt;같은 자바스크립트의 고급함수(higher-order functions)를 사용하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 이것은 불변(Immutable)의 규칙을 적용합니다. 값을 반환하는 함수를 처리하는 것이 부작용을 예측하기가 더 쉽습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/no-iterator.html"&gt;&lt;code&gt;no-iterator&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const numbers = [1, 2, 3, 4, 5];&#xD;
&#xD;
// bad&#xD;
let sum = 0;&#xD;
for (let num of numbers) {&#xD;
  sum += num;&#xD;
}&#xD;
&#xD;
sum === 15;&#xD;
&#xD;
// good&#xD;
let sum = 0;&#xD;
numbers.forEach((num) =&gt; sum += num);&#xD;
sum === 15;&#xD;
&#xD;
// best (use the functional force)&#xD;
const sum = numbers.reduce((total, num) =&gt; total + num, 0);&#xD;
sum === 15;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;현재 제너레이터(Generators)는 사용하지 않는 것이 좋습니다&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? ES5에서 트랜스파일(Transpile)이 올바로 작동하지 않습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="properties" href="#properties"&gt;12&lt;/a&gt;. 속성(Properties)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;속성에 접근하려면 점&lt;code&gt;.&lt;/code&gt;을 사용하세요.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/dot-notation.html"&gt;&lt;code&gt;dot-notation&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const luke = {&#xD;
  jedi: true,&#xD;
  age: 28,&#xD;
};&#xD;
&#xD;
// bad&#xD;
const isJedi = luke['jedi'];&#xD;
&#xD;
// good&#xD;
const isJedi = luke.jedi;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;변수를 사용하여 속성에 접근하려면 대괄호&lt;code&gt;[]&lt;/code&gt;를 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const luke = {&#xD;
  jedi: true,&#xD;
  age: 28,&#xD;
};&#xD;
&#xD;
function getProp(prop) {&#xD;
  return luke[prop];&#xD;
}&#xD;
&#xD;
const isJedi = getProp('jedi');&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="variables" href="#variables"&gt;13&lt;/a&gt;. 변수(Variables)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;변수를 선언할 때는 항상 &lt;code&gt;const&lt;/code&gt;를 사용하세요. 그렇지 않으면 전역 변수로 선언됩니다. 글로벌 네임 스페이스가 오염되지 않도록 캡틴 플래닛(역자주: 환경보호와 생태를 테마로 한 슈퍼히어로 애니메이션)도 경고하고 있습니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
superPower = new SuperPower();&#xD;
&#xD;
// good&#xD;
const superPower = new SuperPower();&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;하나의 변수 선언에 대해 하나의 &lt;code&gt;const&lt;/code&gt;를 사용하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 이 방법은 새로운 변수를 쉽게 추가할 수 있습니다. 또한 구분 기호의 차이에 의한 &lt;code&gt;;&lt;/code&gt;을 &lt;code&gt;,&lt;/code&gt;로 다시금 대체하는 작업에 대해 신경쓸 필요가 없습니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/one-var.html"&gt;&lt;code&gt;one-var&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const items = getItems(),&#xD;
    goSportsTeam = true,&#xD;
    dragonball = 'z';&#xD;
&#xD;
// bad&#xD;
// (compare to above, and try to spot the mistake)&#xD;
const items = getItems(),&#xD;
    goSportsTeam = true;&#xD;
    dragonball = 'z';&#xD;
&#xD;
// good&#xD;
const items = getItems();&#xD;
const goSportsTeam = true;&#xD;
const dragonball = 'z';&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;먼저 &lt;code&gt;const&lt;/code&gt;를 그룹화하고 그 다음으로 &lt;code&gt;let&lt;/code&gt;을 그룹화 하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 이전에 할당 된 변수에 따라 나중에 새로운 변수를 추가하는 경우에 유용하기 때문입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
let i, len, dragonball,&#xD;
    items = getItems(),&#xD;
    goSportsTeam = true;&#xD;
&#xD;
// bad&#xD;
let i;&#xD;
const items = getItems();&#xD;
let dragonball;&#xD;
const goSportsTeam = true;&#xD;
let len;&#xD;
&#xD;
// good&#xD;
const goSportsTeam = true;&#xD;
const items = getItems();&#xD;
let dragonball;&#xD;
let i;&#xD;
let length;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;변수를 할당을 필요로 하는 부분에서 적당한 장소에 배치해야 합니다.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? &lt;code&gt;let&lt;/code&gt;과 &lt;code&gt;const&lt;/code&gt;는 함수 범위에는 없는 블록 범위이기 때문입니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// good&#xD;
function () {&#xD;
  test();&#xD;
  console.log('doing stuff..');&#xD;
&#xD;
  //..other stuff..&#xD;
&#xD;
  const name = getName();&#xD;
&#xD;
  if (name === 'test') {&#xD;
    return false;&#xD;
  }&#xD;
&#xD;
  return name;&#xD;
}&#xD;
&#xD;
// bad - unnecessary function call&#xD;
function (hasName) {&#xD;
  const name = getName();&#xD;
&#xD;
  if (!hasName) {&#xD;
    return false;&#xD;
  }&#xD;
&#xD;
  this.setFirstName(name);&#xD;
&#xD;
  return true;&#xD;
}&#xD;
&#xD;
// good&#xD;
function (hasName) {&#xD;
  if (!hasName) {&#xD;
    return false;&#xD;
  }&#xD;
&#xD;
  const name = getName();&#xD;
  this.setFirstName(name);&#xD;
&#xD;
  return true;&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="hoisting" href="#hoisting"&gt;14&lt;/a&gt;. 호이스팅(Hoisting)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;var&lt;/code&gt; 선언은 할당이 없는 상태로 범위(Scope)의 위로 Hoist될 수 있습니다. 하지만 &lt;code&gt;const&lt;/code&gt;와 &lt;code&gt;let&lt;/code&gt; 선언은 시간적 데드 존(&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let"&gt;Temporal Dead Zones (TDZ)&lt;/a&gt;)이라는 새로운 개념의 혜택을 받고 있습니다. 이것은 왜 typeof가 안전하지 않은가(&lt;a href="http://es-discourse.com/t/why-typeof-is-no-longer-safe/15"&gt;typeof is no longer safe&lt;/a&gt;)를 알고있는 것이 중요합니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// (notDefined가 글로벌 변수에 존재하지 않는다고 가정했을 경우)&#xD;
// 이것은 잘 작동하지 않습니다. &#xD;
function example() {&#xD;
  console.log(notDefined); // =&gt; throws a ReferenceError&#xD;
}&#xD;
&#xD;
// 변수를 참조하는 코드 후에 그 변수를 선언한 경우&#xD;
// 변수가 Hoist되어서 작동합니다.&#xD;
// 주의: `true` 값 자체는 Hoist할 수 없습니다.&#xD;
function example() {&#xD;
  console.log(declaredButNotAssigned); // =&gt; undefined&#xD;
  var declaredButNotAssigned = true;&#xD;
}&#xD;
&#xD;
// 인터프린터는 변수 선언을 범위(Scope)의 시작부분에 Hoist합니다.&#xD;
// 위의 예는 다음과 같이 다시 작성할 수 있습니다:&#xD;
function example() {&#xD;
  let declaredButNotAssigned;&#xD;
  console.log(declaredButNotAssigned); // =&gt; undefined&#xD;
  declaredButNotAssigned = true;&#xD;
}&#xD;
&#xD;
// const와 let을 사용하는 경우&#xD;
function example() {&#xD;
  console.log(declaredButNotAssigned); // =&gt; throws a ReferenceError&#xD;
  console.log(typeof declaredButNotAssigned); // =&gt; throws a ReferenceError&#xD;
  const declaredButNotAssigned = true;&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;익명 함수 표현식에서는 함수가 할당되기 전에 변수가 Hoist될 수 있습니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;function example() {&#xD;
  console.log(anonymous); // =&gt; undefined&#xD;
&#xD;
  anonymous(); // =&gt; TypeError anonymous is not a function&#xD;
&#xD;
  var anonymous = function () {&#xD;
    console.log('anonymous function expression');&#xD;
  };&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;명명된 함수의 경우도 마찬가지로 변수가 Hoist될 수 있습니다. 함수이름과 함수본문은 Hoist되지 않습니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;function example() {&#xD;
  console.log(named); // =&gt; undefined&#xD;
&#xD;
  named(); // =&gt; TypeError named is not a function&#xD;
&#xD;
  superPower(); // =&gt; ReferenceError superPower is not defined&#xD;
&#xD;
  var named = function superPower() {&#xD;
    console.log('Flying');&#xD;
  };&#xD;
}&#xD;
&#xD;
// 함수이름과 변수이름이 같은 경우에도 같은 일이 일어납니다.&#xD;
function example() {&#xD;
  console.log(named); // =&gt; undefined&#xD;
&#xD;
  named(); // =&gt; TypeError named is not a function&#xD;
&#xD;
  var named = function named() {&#xD;
    console.log('named');&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;함수 선언은 함수이름과 함수본문이 Hoist됩니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;function example() {&#xD;
  superPower(); // =&gt; Flying&#xD;
&#xD;
  function superPower() {&#xD;
    console.log('Flying');&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;더 자세한 정보는 &lt;a href="http://www.adequatelygood.com/"&gt;Ben Cherry&lt;/a&gt;의 &lt;a href="http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting/"&gt;JavaScript Scoping &amp;amp; Hoisting&lt;/a&gt;을 참조하세요.&lt;/p&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="comparison-operators--equality" href="#comparison-operators--equality"&gt;15&lt;/a&gt;. 조건식과 등가식(Comparison Operators &amp;amp; Equality)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;==&lt;/code&gt;와 &lt;code&gt;!=&lt;/code&gt; 보다는 &lt;code&gt;===&lt;/code&gt;와 &lt;code&gt;!==&lt;/code&gt;를 사용하세요.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt;와 같은 조건문은 &lt;code&gt;ToBoolean&lt;/code&gt;방법에 의한 강제 형(Type) 변환으로 구분되고 항상 다음과 같은 간단한 규칙을 따릅니다:&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/eqeqeq.html"&gt;&lt;code&gt;eqeqeq&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;ul class="square"&gt;&#xD;
  &lt;li&gt;&lt;strong&gt;Objects&lt;/strong&gt;는 &lt;strong&gt;true&lt;/strong&gt;로 구분됩니다.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;strong&gt;Undefined&lt;/strong&gt;는 &lt;strong&gt;false&lt;/strong&gt;로 구분됩니다.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;strong&gt;Null&lt;/strong&gt;은 &lt;strong&gt;false&lt;/strong&gt;로 구분됩니다.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;strong&gt;Booleans&lt;/strong&gt;은 &lt;strong&gt;boolean형의 값&lt;/strong&gt;으로 구분됩니다.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;strong&gt;Numbers&lt;/strong&gt;는 &lt;strong&gt;true&lt;/strong&gt;로 구분됩니다. 그러나, &lt;strong&gt;+0, -0, 또는 NaN&lt;/strong&gt;인 경우 &lt;strong&gt;false&lt;/strong&gt;로 구분됩니다.&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;strong&gt;Strings&lt;/strong&gt;는 &lt;strong&gt;true&lt;/strong&gt;로 구분됩니다. 그러나, 비어있는 &lt;code&gt;''&lt;/code&gt;경우는 &lt;strong&gt;false&lt;/strong&gt;로 구분됩니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;if ([0]) {&#xD;
  // true&#xD;
  // 배열은 객체이므로 true로 구분됩니다.&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;손쉬운 방법(Shortcuts)을 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
if (name !== '') {&#xD;
  // ...stuff...&#xD;
}&#xD;
&#xD;
// good&#xD;
if (name) {&#xD;
  // ...stuff...&#xD;
}&#xD;
&#xD;
// bad&#xD;
if (collection.length &gt; 0) {&#xD;
  // ...stuff...&#xD;
}&#xD;
&#xD;
// good&#xD;
if (collection.length) {&#xD;
  // ...stuff...&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;더 자세한 내용은 여기를 참조하세요. &lt;a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108"&gt;Truth Equality and JavaScript&lt;/a&gt; by Angus Croll.&lt;/p&gt;&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="blocks" href="#blocks"&gt;16&lt;/a&gt;. 블록(Blocks)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;여러 줄의 블록은 중괄호&lt;code&gt;{}&lt;/code&gt;를 사용합니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
if (test)&#xD;
  return false;&#xD;
&#xD;
// good&#xD;
if (test) return false;&#xD;
&#xD;
// good&#xD;
if (test) {&#xD;
  return false;&#xD;
}&#xD;
&#xD;
// bad&#xD;
function () { return false; }&#xD;
&#xD;
// good&#xD;
function () {&#xD;
  return false;&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;여러 블록에 걸친 &lt;code&gt;if&lt;/code&gt;와 &lt;code&gt;else&lt;/code&gt;를 사용하는 경우, &lt;code&gt;else&lt;/code&gt;는 &lt;code&gt;if&lt;/code&gt;블록의 끝 중괄호&lt;code&gt;{}&lt;/code&gt;와 같은 행에 두세요.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/brace-style.html"&gt;&lt;code&gt;brace-style&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
if (test) {&#xD;
  thing1();&#xD;
  thing2();&#xD;
}&#xD;
else {&#xD;
  thing3();&#xD;
}&#xD;
&#xD;
// good&#xD;
if (test) {&#xD;
  thing1();&#xD;
  thing2();&#xD;
} else {&#xD;
  thing3();&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="comments" href="#comments"&gt;17&lt;/a&gt;. 주석(Comments)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;여러 줄의 주석에는 &lt;code&gt;/** ... */&lt;/code&gt;를 사용하세요. 그 안에는 설명과 모든 매개변수와 반환값에 대한 형식과 값을 표기합니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
// make() returns a new element&#xD;
// based on the passed in tag name&#xD;
//&#xD;
// @param {String} tag&#xD;
// @return {Element} element&#xD;
function make(tag) {&#xD;
&#xD;
  // ...stuff...&#xD;
&#xD;
  return element;&#xD;
}&#xD;
&#xD;
// good&#xD;
/**&#xD;
 * make() returns a new element&#xD;
 * based on the passed in tag name&#xD;
 *&#xD;
 * @param {String} tag&#xD;
 * @return {Element} element&#xD;
 */&#xD;
function make(tag) {&#xD;
&#xD;
  // ...stuff...&#xD;
&#xD;
  return element;&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;한 줄 주석에는 &lt;code&gt;//&lt;/code&gt;를 사용하세요. 주석을 추가하고 싶은 코드의 상단에 배치하세요. 또한 주석 앞에 빈 줄을 넣어주세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const active = true;  // is current tab&#xD;
&#xD;
// good&#xD;
// is current tab&#xD;
const active = true;&#xD;
&#xD;
// bad&#xD;
function getType() {&#xD;
  console.log('fetching type...');&#xD;
  // set the default type to 'no type'&#xD;
  const type = this._type || 'no type';&#xD;
&#xD;
  return type;&#xD;
}&#xD;
&#xD;
// good&#xD;
function getType() {&#xD;
  console.log('fetching type...');&#xD;
&#xD;
  // set the default type to 'no type'&#xD;
  const type = this._type || 'no type';&#xD;
&#xD;
  return type;&#xD;
}&#xD;
&#xD;
// also good&#xD;
function getType() {&#xD;
  // set the default type to 'no type'&#xD;
  const type = this._type || 'no type';&#xD;
&#xD;
  return type;&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;문제를 지적하고 재고를 촉구하거나 문제의 해결책을 제시하는 경우 등, 주석 앞에 &lt;code&gt;FIXME&lt;/code&gt; 또는 &lt;code&gt;TODO&lt;/code&gt; 를 붙이는 것으로 다른 개발자의 빠른 이해를 도울 수 있습니다. 이들은 어떠한 액션을 따른다는 의미에서 일반 댓글과 다를 수 있습니다. 액션은 &lt;code&gt;FIXME -- 해결책 필요&lt;/code&gt; 또는 &lt;code&gt;TODO -- 구현 필요&lt;/code&gt;.&lt;/p&gt;&#xD;
&lt;p&gt;문제에 대한 주석으로 &lt;code&gt;// FIXME:&lt;/code&gt;를 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;class Calculator extends Abacus {&#xD;
  constructor() {&#xD;
    super();&#xD;
&#xD;
    // FIXME: shouldn't use a global here&#xD;
    total = 0;&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;해결책에 대한 주석으로 &lt;code&gt;// TODO:&lt;/code&gt;를 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;class Calculator extends Abacus {&#xD;
  constructor() {&#xD;
    super();&#xD;
&#xD;
    // TODO: total should be configurable by an options param&#xD;
    this.total = 0;&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="whitespace" href="#whitespace"&gt;18&lt;/a&gt;. 공백(Whitespace)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;탭에는 공백 2개를 설정하세요.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/indent.html"&gt;&lt;code&gt;indent&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function () {&#xD;
∙∙∙∙const name;&#xD;
}&#xD;
&#xD;
// bad&#xD;
function () {&#xD;
∙const name;&#xD;
}&#xD;
&#xD;
// good&#xD;
function () {&#xD;
∙∙const name;&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;중괄호&lt;code&gt;{}&lt;/code&gt; 앞에 공백을 넣어주세요.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/space-before-blocks.html"&gt;&lt;code&gt;space-before-blocks&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function test(){&#xD;
  console.log('test');&#xD;
}&#xD;
&#xD;
// good&#xD;
function test() {&#xD;
  console.log('test');&#xD;
}&#xD;
&#xD;
// bad&#xD;
dog.set('attr',{&#xD;
  age: '1 year',&#xD;
  breed: 'Bernese Mountain Dog',&#xD;
});&#xD;
&#xD;
// good&#xD;
dog.set('attr', {&#xD;
  age: '1 year',&#xD;
  breed: 'Bernese Mountain Dog',&#xD;
});&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;제어 구문(&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; 등)의 괄호&lt;code&gt;()&lt;/code&gt; 앞에 공백을 넣어주세요. 함수 선언과 함수 호출시 인수 목록 앞에는 공백을 넣지 않습니다.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/space-after-keywords.html"&gt;&lt;code&gt;space-after-keywords&lt;/code&gt;&lt;/a&gt;, &lt;a href="http://eslint.org/docs/rules/space-before-keywords.html"&gt;&lt;code&gt;space-before-keywords&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
if(isJedi) {&#xD;
  fight ();&#xD;
}&#xD;
&#xD;
// good&#xD;
if (isJedi) {&#xD;
  fight();&#xD;
}&#xD;
&#xD;
// bad&#xD;
function fight () {&#xD;
  console.log ('Swooosh!');&#xD;
}&#xD;
&#xD;
// good&#xD;
function fight() {&#xD;
  console.log('Swooosh!');&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;연산자 사이에는 공백이 있습니다.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/space-infix-ops.html"&gt;&lt;code&gt;space-infix-ops&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const x=y+5;&#xD;
&#xD;
// good&#xD;
const x = y + 5;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;파일의 마지막에 빈 줄을 하나 넣어주세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
(function (global) {&#xD;
  // ...stuff...&#xD;
})(this);&#xD;
&#xD;
// bad&#xD;
(function (global) {&#xD;
  // ...stuff...&#xD;
})(this);↵&#xD;
↵&#xD;
&#xD;
// good&#xD;
(function (global) {&#xD;
  // ...stuff...&#xD;
})(this);↵&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;메소드 체인이 길어지는 경우 적절히 들여쓰기(indentation) 하세요. 행이 메소드 호출이 아닌 새로운 문장임을 강조하기 위해 선두에 점&lt;code&gt;.&lt;/code&gt;을 배치하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
$('#items').find('.selected').highlight().end().find('.open').updateCount();&#xD;
&#xD;
// bad&#xD;
$('#items').&#xD;
  find('.selected').&#xD;
    highlight().&#xD;
    end().&#xD;
  find('.open').&#xD;
    updateCount();&#xD;
&#xD;
// good&#xD;
$('#items')&#xD;
  .find('.selected')&#xD;
    .highlight()&#xD;
    .end()&#xD;
  .find('.open')&#xD;
    .updateCount();&#xD;
&#xD;
// bad&#xD;
const leds = stage.selectAll('.led').data(data).enter().append('svg:svg').class('led', true)&#xD;
    .attr('width', (radius + margin) * 2).append('svg:g')&#xD;
    .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')')&#xD;
    .call(tron.led);&#xD;
&#xD;
// good&#xD;
const leds = stage.selectAll('.led')&#xD;
    .data(data)&#xD;
  .enter().append('svg:svg')&#xD;
    .classed('led', true)&#xD;
    .attr('width', (radius + margin) * 2)&#xD;
  .append('svg:g')&#xD;
    .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')')&#xD;
    .call(tron.led);&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;블록과 다음 Statement 사이에 빈 줄을 넣어주세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
if (foo) {&#xD;
  return bar;&#xD;
}&#xD;
return baz;&#xD;
&#xD;
// good&#xD;
if (foo) {&#xD;
  return bar;&#xD;
}&#xD;
&#xD;
return baz;&#xD;
&#xD;
// bad&#xD;
const obj = {&#xD;
  foo() {&#xD;
  },&#xD;
  bar() {&#xD;
  },&#xD;
};&#xD;
return obj;&#xD;
&#xD;
// good&#xD;
const obj = {&#xD;
  foo() {&#xD;
  },&#xD;
&#xD;
  bar() {&#xD;
  },&#xD;
};&#xD;
&#xD;
return obj;&#xD;
&#xD;
// bad&#xD;
const arr = [&#xD;
  function foo() {&#xD;
  },&#xD;
  function bar() {&#xD;
  },&#xD;
];&#xD;
return arr;&#xD;
&#xD;
// good&#xD;
const arr = [&#xD;
  function foo() {&#xD;
  },&#xD;
&#xD;
  function bar() {&#xD;
  },&#xD;
];&#xD;
&#xD;
return arr;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;블록에 빈 줄을 끼워넣지 않습니다.&lt;/p&gt;&#xD;
&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/padded-blocks.html"&gt;&lt;code&gt;padded-blocks&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function bar() {&#xD;
&#xD;
  console.log(foo);&#xD;
&#xD;
}&#xD;
&#xD;
// also bad&#xD;
if (baz) {&#xD;
&#xD;
  console.log(qux);&#xD;
} else {&#xD;
  console.log(foo);&#xD;
&#xD;
}&#xD;
&#xD;
// good&#xD;
function bar() {&#xD;
  console.log(foo);&#xD;
}&#xD;
&#xD;
// good&#xD;
if (baz) {&#xD;
  console.log(qux);&#xD;
} else {&#xD;
  console.log(foo);&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;괄호&lt;code&gt;()&lt;/code&gt; 안에 공백을 추가하지 않습니다.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/space-in-parens.html"&gt;&lt;code&gt;space-in-parens&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function bar( foo ) {&#xD;
  return foo;&#xD;
}&#xD;
&#xD;
// good&#xD;
function bar(foo) {&#xD;
  return foo;&#xD;
}&#xD;
&#xD;
// bad&#xD;
if ( foo ) {&#xD;
  console.log(foo);&#xD;
}&#xD;
&#xD;
// good&#xD;
if (foo) {&#xD;
  console.log(foo);&#xD;
}&#xD;
&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;대괄호&lt;code&gt;[]&lt;/code&gt; 안에 공백을 추가하지 않습니다.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/array-bracket-spacing.html"&gt;&lt;code&gt;array-bracket-spacing&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const foo = [ 1, 2, 3 ];&#xD;
console.log(foo[ 0 ]);&#xD;
&#xD;
// good&#xD;
const foo = [1, 2, 3];&#xD;
console.log(foo[0]);&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;중괄호&lt;code&gt;{}&lt;/code&gt; 안에 공백을 추가합니다.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/object-curly-spacing.html"&gt;&lt;code&gt;object-curly-spacing&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const foo = {clark: 'kent'};&#xD;
&#xD;
// good&#xD;
const foo = { clark: 'kent' };&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;한 줄에 100문자(공백 포함)가 넘는 코드는 피하세요.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 가독성과 유지 보수성을 보장합니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/max-len.html"&gt;&lt;code&gt;max-len&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const foo = 'Whatever national crop flips the window. The cartoon reverts within the screw. Whatever wizard constrains a helpful ally. The counterpart ascends!';&#xD;
&#xD;
// bad&#xD;
$.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' } }).done(() =&gt; console.log('Congratulations!')).fail(() =&gt; console.log('You have failed this city.'));&#xD;
&#xD;
// good&#xD;
const foo = 'Whatever national crop flips the window. The cartoon reverts within the screw. ' +&#xD;
  'Whatever wizard constrains a helpful ally. The counterpart ascends!';&#xD;
&#xD;
// good&#xD;
$.ajax({&#xD;
  method: 'POST',&#xD;
  url: 'https://airbnb.com/',&#xD;
  data: { name: 'John' },&#xD;
})&#xD;
  .done(() =&gt; console.log('Congratulations!'))&#xD;
  .fail(() =&gt; console.log('You have failed this city.'));&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="commas" href="#commas"&gt;19&lt;/a&gt;. 쉼표(Commas)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;쉼표로 시작: &lt;strong&gt;제발 그만하세요.&lt;/strong&gt;&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/comma-style.html"&gt;&lt;code&gt;comma-style&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const story = [&#xD;
    once&#xD;
  , upon&#xD;
  , aTime&#xD;
];&#xD;
&#xD;
// good&#xD;
const story = [&#xD;
  once,&#xD;
  upon,&#xD;
  aTime,&#xD;
];&#xD;
&#xD;
// bad&#xD;
const hero = {&#xD;
    firstName: 'Ada'&#xD;
  , lastName: 'Lovelace'&#xD;
  , birthYear: 1815&#xD;
  , superPower: 'computers'&#xD;
};&#xD;
&#xD;
// good&#xD;
const hero = {&#xD;
  firstName: 'Ada',&#xD;
  lastName: 'Lovelace',&#xD;
  birthYear: 1815,&#xD;
  superPower: 'computers',&#xD;
};&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;마지막에 쉼표: &lt;strong&gt;좋습니다.&lt;/strong&gt;&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/comma-dangle.html"&gt;&lt;code&gt;comma-dangle&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;blockquote&gt;&#xD;
&lt;p&gt;왜죠? 이것은 git의 diff를 깨끗하게 합니다. 또한 Babel과 같은 트랜스 컴파일러는 끝에 불필요한 쉼표를 알아서 제거합니다. 이것은 기존 브라우저에서 &lt;a href="https://github.com/firejune/javascript/blob/master/es5/README.md#commas"&gt;불필요한 쉼표 문제&lt;/a&gt;를 걱정할 필요가 없다는 것을 의미합니다.&lt;/p&gt;&#xD;
&lt;/blockquote&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad - git diff without trailing comma&#xD;
const hero = {&#xD;
     firstName: 'Florence',&#xD;
-    lastName: 'Nightingale'&#xD;
+    lastName: 'Nightingale',&#xD;
+    inventorOf: ['coxcomb graph', 'modern nursing']&#xD;
};&#xD;
&#xD;
// good - git diff with trailing comma&#xD;
const hero = {&#xD;
     firstName: 'Florence',&#xD;
     lastName: 'Nightingale',&#xD;
+    inventorOf: ['coxcomb chart', 'modern nursing'],&#xD;
};&#xD;
&#xD;
// bad&#xD;
const hero = {&#xD;
  firstName: 'Dana',&#xD;
  lastName: 'Scully'&#xD;
};&#xD;
&#xD;
const heroes = [&#xD;
  'Batman',&#xD;
  'Superman'&#xD;
];&#xD;
&#xD;
// good&#xD;
const hero = {&#xD;
  firstName: 'Dana',&#xD;
  lastName: 'Scully',&#xD;
};&#xD;
&#xD;
const heroes = [&#xD;
  'Batman',&#xD;
  'Superman',&#xD;
];&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="semicolons" href="#semicolons"&gt;20&lt;/a&gt;. 세미콜론(Semicolons)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;&lt;strong&gt;물론 사용합시다.&lt;/strong&gt;&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/semi.html"&gt;&lt;code&gt;semi&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
(function () {&#xD;
  const name = 'Skywalker'&#xD;
  return name&#xD;
})()&#xD;
&#xD;
// good&#xD;
(() =&gt; {&#xD;
  const name = 'Skywalker';&#xD;
  return name;&#xD;
})();&#xD;
&#xD;
// good (guards against the function becoming an argument when two files with IIFEs are concatenated)&#xD;
;(() =&gt; {&#xD;
  const name = 'Skywalker';&#xD;
  return name;&#xD;
})();&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/7365172/semicolon-before-self-invoking-function/7365214%237365214"&gt;Read more&lt;/a&gt;.&lt;/p&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="type-casting--coercion" href="#type-casting--coercion"&gt;21&lt;/a&gt;. 형변환과 강제(Type Casting &amp;amp; Coercion)&lt;/h2&gt;&#xD;
&#xD;
&lt;a href="#21.1" name="21.1"&gt;&lt;/a&gt; 문장의 시작 부분에서 형(Type)을 강제합니다.&#xD;
&#xD;
&lt;p&gt;String:&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;//  =&gt; this.reviewScore = 9;&#xD;
&#xD;
// bad&#xD;
const totalScore = this.reviewScore + '';&#xD;
&#xD;
// good&#xD;
const totalScore = String(this.reviewScore);&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;Number: &lt;code&gt;Number&lt;/code&gt;형으로 변환하려면 &lt;code&gt;parseInt&lt;/code&gt;를 사용하세요. 항상 형변환을 위한 기수(radix)를 인수로 전달합니다.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/radix"&gt;&lt;code&gt;radix&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const inputValue = '4';&#xD;
&#xD;
// bad&#xD;
const val = new Number(inputValue);&#xD;
&#xD;
// bad&#xD;
const val = +inputValue;&#xD;
&#xD;
// bad&#xD;
const val = inputValue &gt;&gt; 0;&#xD;
&#xD;
// bad&#xD;
const val = parseInt(inputValue);&#xD;
&#xD;
// good&#xD;
const val = Number(inputValue);&#xD;
&#xD;
// good&#xD;
const val = parseInt(inputValue, 10);&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;어떤 이유로 &lt;code&gt;parseInt&lt;/code&gt;가 병목이되고, &lt;a href="http://jsperf.com/coercion-vs-casting/3"&gt;성능적인 이유&lt;/a&gt;에서 Bitshift를 사용해야 하는 경우, 무엇을(what) 왜(why)에 대한 설명을 댓글로 남겨 주세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// good&#xD;
/**&#xD;
 * parseInt가 병목이되고 있었기 때문에, &#xD;
 * Bitshift 문자열을 수치로 강제로 변환하여 &#xD;
 * 성능을 향상시킵니다.&#xD;
 */&#xD;
const val = inputValue &gt;&gt; 0;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;strong&gt;주의:&lt;/strong&gt; Bitshift를 사용하는 경우 수치는 &lt;a href="http://es5.github.io/#x4.3.19"&gt;64-비트 값들&lt;/a&gt;로 표현되어 있지만, Bitshift를 연산하면 항상 32-비트 단 정밀도로 돌려 주어집니다(&lt;a href="http://es5.github.io/#x11.7"&gt;source&lt;/a&gt;). 32-비트 이상의 값을 비트 이동하면 예상치 못한 행동을 일으킬 가능성이 있습니다. &lt;a href="https://github.com/airbnb/javascript/issues/109"&gt;Discussion&lt;/a&gt;. 부호있는 32-비트 정수의 최대 값은 2,147,483,647입니다:&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;2147483647 &gt;&gt; 0 //=&gt; 2147483647&#xD;
2147483648 &gt;&gt; 0 //=&gt; -2147483648&#xD;
2147483649 &gt;&gt; 0 //=&gt; -2147483647&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;Booleans:&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const age = 0;&#xD;
&#xD;
// bad&#xD;
const hasAge = new Boolean(age);&#xD;
&#xD;
// good&#xD;
const hasAge = Boolean(age);&#xD;
&#xD;
// good&#xD;
const hasAge = !!age;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="naming-conventions" href="#naming-conventions"&gt;22&lt;/a&gt;. 명명 규칙(Naming Conventions)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;하나의 문자로 구성된 이름은 피하세요. 이름에서 의도를 읽을 수 있도록 해야 합니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function q() {&#xD;
  // ...stuff...&#xD;
}&#xD;
&#xD;
// good&#xD;
function query() {&#xD;
  // ..stuff..&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;객체, 함수 인스턴스에는 camelCase(소문자로 시작)를 사용하세요.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/camelcase.html"&gt;&lt;code&gt;camelcase&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const OBJEcttsssss = {};&#xD;
const this_is_my_object = {};&#xD;
function c() {}&#xD;
&#xD;
// good&#xD;
const thisIsMyObject = {};&#xD;
function thisIsMyFunction() {}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;클래스와 생성자는 PascalCase(대문자로 시작)를 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function user(options) {&#xD;
  this.name = options.name;&#xD;
}&#xD;
&#xD;
const bad = new user({&#xD;
  name: 'nope',&#xD;
});&#xD;
&#xD;
// good&#xD;
class User {&#xD;
  constructor(options) {&#xD;
    this.name = options.name;&#xD;
  }&#xD;
}&#xD;
&#xD;
const good = new User({&#xD;
  name: 'yup',&#xD;
});&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;Private 속성 이름은 앞에 밑줄&lt;code&gt;_&lt;/code&gt;을 사용하세요.&lt;/p&gt;&#xD;
&lt;p&gt;eslint rules: &lt;a href="http://eslint.org/docs/rules/no-underscore-dangle.html"&gt;&lt;code&gt;no-underscore-dangle&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
this.__firstName__ = 'Panda';&#xD;
this.firstName_ = 'Panda';&#xD;
&#xD;
// good&#xD;
this._firstName = 'Panda';&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;에 대한 참조를 저장하지 않습니다. 애로우 함수 또는 Function#bind를 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function foo() {&#xD;
  const self = this;&#xD;
  return function () {&#xD;
    console.log(self);&#xD;
  };&#xD;
}&#xD;
&#xD;
// bad&#xD;
function foo() {&#xD;
  const that = this;&#xD;
  return function () {&#xD;
    console.log(that);&#xD;
  };&#xD;
}&#xD;
&#xD;
// good&#xD;
function foo() {&#xD;
  return () =&gt; {&#xD;
    console.log(this);&#xD;
  };&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;파일을 하나의 클래스로 추출(Export)할 경우 파일 이름은 클래스 이름과 정확하게 일치해야 합니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// file contents&#xD;
class CheckBox {&#xD;
  // ...&#xD;
}&#xD;
export default CheckBox;&#xD;
&#xD;
// in some other file&#xD;
// bad&#xD;
import CheckBox from './checkBox';&#xD;
&#xD;
// bad&#xD;
import CheckBox from './check_box';&#xD;
&#xD;
// good&#xD;
import CheckBox from './CheckBox';&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;export-default 함수의 경우, camelCase(소문자로 시작)를 사용하세요. 파일이름은 함수이름과 동일해야 합니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;function makeStyleGuide() {&#xD;
}&#xD;
&#xD;
export default makeStyleGuide;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;싱글톤(singleton) / 함수 라이브러리(function library) / 단순한 객체(bare object)를 추출하는 경우, PascalCase(대문자로 시작)를 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;const AirbnbStyleGuide = {&#xD;
  es6: {&#xD;
  }&#xD;
};&#xD;
&#xD;
export default AirbnbStyleGuide;&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="accessors" href="#accessors"&gt;23&lt;/a&gt;. 액세서(Accessors)&lt;/h2&gt;&#xD;
&#xD;
속성에 대한 접근자(Accessor) 함수는 필요하지 않습니다.&#xD;
&#xD;
&lt;p&gt;접근자 함수가 필요한 경우 &lt;code&gt;getVal()&lt;/code&gt;과 &lt;code&gt;setVal('hello')&lt;/code&gt;로 하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
dragon.age();&#xD;
&#xD;
// good&#xD;
dragon.getAge();&#xD;
&#xD;
// bad&#xD;
dragon.age(25);&#xD;
&#xD;
// good&#xD;
dragon.setAge(25);&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;속성이 &lt;code&gt;boolean&lt;/code&gt;의 경우 &lt;code&gt;isVal()&lt;/code&gt; 또는 &lt;code&gt;hasVal()&lt;/code&gt;로 하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
if (!dragon.age()) {&#xD;
  return false;&#xD;
}&#xD;
&#xD;
// good&#xD;
if (!dragon.hasAge()) {&#xD;
  return false;&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;일관된다면, &lt;code&gt;get()&lt;/code&gt;과 &lt;code&gt;set()&lt;/code&gt; 함수를 작성해도 좋습니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;class Jedi {&#xD;
  constructor(options = {}) {&#xD;
    const lightsaber = options.lightsaber || 'blue';&#xD;
    this.set('lightsaber', lightsaber);&#xD;
  }&#xD;
&#xD;
  set(key, val) {&#xD;
    this[key] = val;&#xD;
  }&#xD;
&#xD;
  get(key) {&#xD;
    return this[key];&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="events" href="#events"&gt;24&lt;/a&gt;. 이벤트(Events)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;(DOM 이벤트, Backbone 이벤트)처럼 자신의 이벤트 페이로드 값을 전달하려면 원시값 대신 해시인수를 전달합니다. 이렇게 하면 나중에 개발자가 이벤트에 관련된 모든 핸들러를 찾아 업데이트하지 않고 이벤트 페이로드에 값을 추가할 수 있습니다. 예를 들면:&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
$(this).trigger('listingUpdated', listing.id);&#xD;
&#xD;
...&#xD;
&#xD;
$(this).on('listingUpdated', function (e, listingId) {&#xD;
  // do something with listingId&#xD;
});&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;보다 아래쪽이 더 선호됨:&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// good&#xD;
$(this).trigger('listingUpdated', { listingId: listing.id });&#xD;
&#xD;
...&#xD;
&#xD;
$(this).on('listingUpdated', function (e, data) {&#xD;
  // do something with data.listingId&#xD;
});&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="jquery" href="#jquery"&gt;25&lt;/a&gt;. jQuery&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;jQuery 객체 변수 앞에는 &lt;code&gt;$&lt;/code&gt;로 구분합니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
const sidebar = $('.sidebar');&#xD;
&#xD;
// good&#xD;
const $sidebar = $('.sidebar');&#xD;
&#xD;
// good&#xD;
const $sidebarBtn = $('.sidebar-btn');&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;jQuery의 검색 결과를 캐시합니다.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
function setSidebar() {&#xD;
  $('.sidebar').hide();&#xD;
&#xD;
  // ...stuff...&#xD;
&#xD;
  $('.sidebar').css({&#xD;
    'background-color': 'pink'&#xD;
  });&#xD;
}&#xD;
&#xD;
// good&#xD;
function setSidebar() {&#xD;
  const $sidebar = $('.sidebar');&#xD;
  $sidebar.hide();&#xD;
&#xD;
  // ...stuff...&#xD;
&#xD;
  $sidebar.css({&#xD;
    'background-color': 'pink'&#xD;
  });&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;DOM의 검색에는 &lt;code&gt;$('.sidebar ul')&lt;/code&gt; 또는 &lt;code&gt;$('.sidebar &amp;gt; ul')&lt;/code&gt;과 같은 Cascading을 사용하세요. &lt;a href="http://jsperf.com/jquery-find-vs-context-sel/16"&gt;jsPerf&lt;/a&gt;&lt;/p&gt;&#xD;
&lt;p&gt;jQuery 객체의 검색에는 범위가있는 &lt;code&gt;find&lt;/code&gt; 를 사용하세요.&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;// bad&#xD;
$('ul', '.sidebar').hide();&#xD;
&#xD;
// bad&#xD;
$('.sidebar').find('ul').hide();&#xD;
&#xD;
// good&#xD;
$('.sidebar ul').hide();&#xD;
&#xD;
// good&#xD;
$('.sidebar &gt; ul').hide();&#xD;
&#xD;
// good&#xD;
$sidebar.find('ul').hide();&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="ecmascript-5-compatibility" href="#ecmascript-5-compatibility"&gt;26&lt;/a&gt;. ECMAScript 5 호환성(ECMAScript 5 Compatibility)&lt;/h2&gt;&#xD;
&#xD;
&lt;a href="https://twitter.com/kangax/"&gt;Kangax&lt;/a&gt;의 ES5 &lt;a href="http://kangax.github.io/es5-compat-table/"&gt;호환성 표&lt;/a&gt;를 참조하세요.&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="ecmascript-6-styles" href="#ecmascript-6-styles"&gt;27&lt;/a&gt;. ECMAScript 6 스타일(ECMAScript 6 Styles)&lt;/h2&gt;&#xD;
&#xD;
&lt;a href="#27.1" name="27.1"&gt;&lt;/a&gt; 이것은 ES6 명세 링크를 모아 놓은 것입니다.&#xD;
&lt;ul class="square"&gt;&#xD;
  &lt;li&gt;&lt;a href="#arrow-functions"&gt;애로우 함수(Arrow Functions)&lt;/a&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="#constructors"&gt;클래스(Classes)&lt;/a&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="#es6-object-shorthand"&gt;객체 단축 구문(Object Shorthand)&lt;/a&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="#es6-object-concise"&gt;속성 단축 구문(Object Concise)&lt;/a&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="#es6-computed-properties"&gt;계산된 속성 이름(Object Computed Properties)&lt;/a&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="#es6-template-literals"&gt;템플릿 문자열(Template Strings)&lt;/a&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="#destructuring"&gt;구조화 대입(Destructuring)&lt;/a&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="#es6-default-parameters"&gt;기본 매개변수(Default Parameters)&lt;/a&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="#es6-rest"&gt;레스트(Rest)&lt;/a&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="#es6-array-spreads"&gt;배열 스프레드(Array Spreads)&lt;/a&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="#references"&gt;Let과 Const(Let and Const)&lt;/a&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="#iterators-and-generators"&gt;이터레이터와 제너레이터(Iterators and Generators)&lt;/a&gt;&lt;/li&gt;&#xD;
  &lt;li&gt;&lt;a href="#modules"&gt;모듈(Modules)&lt;/a&gt;&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;
&#xD;
&#xD;
&#xD;
&lt;h2&gt;&lt;a id="testing" href="#testing"&gt;28&lt;/a&gt;. 테스팅(Testing)&lt;/h2&gt;&#xD;
&#xD;
&lt;p&gt;&lt;strong&gt;물론 해야 합니다.&lt;/strong&gt;&lt;/p&gt;&#xD;
&lt;pre class="javascript"&gt;&lt;code&gt;function () {&#xD;
  return true;&#xD;
}&lt;/code&gt;&lt;/pre&gt;&#xD;
&#xD;
&lt;p&gt;&lt;strong&gt;물론 심각하게&lt;/strong&gt;:&lt;/p&gt;&#xD;
&lt;ul class="square"&gt;&#xD;
  &lt;li&gt;대부분 테스트 프레임워크를 이용하여 테스트를 작성합니다.&lt;/li&gt;&#xD;
  &lt;li&gt;작은 기능의 함수를 자주 쓰고 이변이 발생할 수 있는 부분을 최소화하기 위해 노력합니다.&lt;/li&gt;&#xD;
  &lt;li&gt;stubs와 mocks에 주의하세요. 이 것들로 인해 테스트가 깨지기 쉽습니다.&lt;/li&gt;&#xD;
  &lt;li&gt;Airbnb는 &lt;a href="https://www.npmjs.com/package/mocha"&gt;&lt;code&gt;mocha&lt;/code&gt;&lt;/a&gt;를 이용하고 있습니다. 작게 분할된 개별 모듈은 &lt;a href="https://www.npmjs.com/package/tape"&gt;&lt;code&gt;tape&lt;/code&gt;&lt;/a&gt;을 사용합니다.&lt;/li&gt;&#xD;
  &lt;li&gt;지금은 달성할 필요가 없어도 100%의 테스트 커버리지를 목표로하는 것이 좋습니다.&lt;/li&gt;&#xD;
  &lt;li&gt;버그를 수정할 때 마다 &lt;em&gt;회귀 테스트를 씁니다&lt;/em&gt;. 회귀 테스트 없는 버그 수정은 나중에 반드시 다시 출현할 것입니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;&#xD;


			&lt;br&gt;&lt;br&gt;
			&lt;a href="https://firejune.com/1794#p1794"&gt;Comments&lt;/a&gt; |
			&lt;a href="https://firejune.com/1794"&gt;Hits(127,631)&lt;/a&gt;&lt;img src="http://feeds.feedburner.com/~r/firejune/~4/qvJO3nY1X34" height="1" width="1" alt=""/&gt;</content><feedburner:origLink>https://firejune.com/1794</feedburner:origLink></entry><entry><title type="text">2015년 회고</title><link rel="alternate" type="text/html" href="http://feedproxy.google.com/~r/firejune/~3/sIv5G9TZufw/1796" /><category term="자료-웹개발" /><category term="자바스크립트" /><category term="JSDoc" /><category term="Nightwatch.js" /><category term="UI Test Automation" /><category term="Electron" /><category term="React" /><category term="Cordova" /><category term="하이브리드 애플리케이션" /><category term="Node.js" /><category term="프로젝트" /><author><name>파이어준</name></author><updated>2015-12-31T00:16:40-08:00</updated><id>https://firejune.com/1796</id><content type="html">&lt;p&gt;아! 2015년에는 하나도 포스팅한게 없군요. 그래서 땜빵용으로 회고록을 몰래 끼워넣기로 했습니다. 2015년은 변화가 많았던 해였습니다. &lt;a href="https://www.mobizen.com/"&gt;모비즌2 프로젝트&lt;/a&gt;에서 나와 새로운 프로젝트를 제안하고 비전을 현실로 만드는 작업을 수행하고 있습니다. 알서포트에 재입사 한지도 벌써 3년째군요. 새로운 프로젝트에 걸맞은 새로운 기술을들 공부하다 보니 자바스크립트도 아주 많이 변하고 발전했습니다. 특히 문법적으로 많은 변화를 가져온 ES6을 접하면서 문맹이 된듯한 기분이 들었을 정도입니다. &lt;/p&gt;
&lt;h2&gt;API 문서 작성 - JSDoc3&lt;/h2&gt;
&lt;p&gt; 모비즌2 프로젝트에서 발을 빼기 위해(?) &lt;a href="https://github.com/jsdoc3/jsdoc"&gt;JSDoc3&lt;/a&gt;를 이용해서 &lt;a href="http://mobizen.firejune.io/doc/"&gt;API 문서화 프로젝트&lt;/a&gt;를 별도로 진행했습니다. JSDoc은 JavaDoc과 비슷한 것으로 코드에 표현한 주석을 이용하여 API 문서를 자동으로 생성해 주는 도구입니다. 함수의 파라미터 설명은 기본이고 클래스 간 관계 표현이나 이벤트 리스너와 트리거의 링크를 제공하는 등 작성한 코드를 협업자가 별 어려움 없이 이해하고 사용할 수 있도록 할 수 있습니다. 느낀 점들:&lt;/p&gt;
&lt;ul class="square"&gt;&#xD;
  &lt;li&gt;총 6만 라인이었던 소스코드가 8만 라인 정도로 늘어났습니다. 약 20%~30% 정도 늘어납니다.&lt;/li&gt;&#xD;
  &lt;li&gt;문서를 작성하면서 구조적으로 관계가 더욱 명확해지는 것을 발견했습니다.&lt;/li&gt;&#xD;
  &lt;li&gt;LINT에서는 발견하기 어려운 구조적 문제점 발견하고 개선할 기회가 됩니다.&lt;/li&gt;&#xD;
  &lt;li&gt;템플릿을 이용하여 문서를 뽑아내는 데까지 3개월 정도 걸렸습니다.&lt;/li&gt;&#xD;
  &lt;li&gt;함수에 매개변수를 설명하는 주석 정도만 충실히 달았어도 이렇게 오래걸리지는 않았을 것이라는 반성을 했습니다.&lt;/li&gt;&#xD;
  &lt;li&gt;템플릿은 davidshimjs님의 &lt;a href="https://github.com/davidshimjs/jaguarjs-jsdoc"&gt;jaguarjs-jsdoc&lt;/a&gt;이 예쁩니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;
&lt;h2&gt;웹 UI 테스트 자동화 - Nightwatch.js&lt;/h2&gt;
&lt;p&gt; 웹 프로젝트의 UI 테스트 자동화를 도입하기 위해 &lt;a href="https://en.wikipedia.org/wiki/Headless_browser"&gt;Headless browser&lt;/a&gt; 방식의 여러 가지 방법을 검토해 보았는데, 가장 와 닫는 것이 &lt;a href="http://nightwatchjs.org/"&gt;Nightwatch.js&lt;/a&gt;이었습니다. 이 녀석은 End-to-End 테스트가 가능한 녀석으로,  Node.js로 작성되었으며 &lt;a href="https://code.google.com/p/selenium/wiki/JsonWireProtocol"&gt;Selenium WebDriver API&lt;/a&gt;를 이용하여 DOM 요소에 직접 접근하는 방식으로 테스트 코드를 작성할 수 있습니다. 느낀 점:&lt;/p&gt;
&lt;ul class="square"&gt;&#xD;
  &lt;li&gt;테스트는 필수입니다. 총 작업 시간의 최소 3할 이상을 테스트하는 것에 소비해야 합니다.&lt;/li&gt;&#xD;
  &lt;li&gt;테스트를 자동화해 놓으면 테스트에 들어가는 시간과 노력의 비용을 낮출 수 있습니다.&lt;/li&gt;&#xD;
  &lt;li&gt;유닛 테스트는 프로젝트 빌드 직전인 시점에, UI 테스트는 빌드 이후에 자동으로 수행하도록 grunt나 gulp을 이용해서 구성하는 게 좋습니다.&lt;/li&gt;&#xD;
  &lt;li&gt;모든 기능을 사람이 직접 쓰는 것처럼 테스트 해 주니, 주위 사람들이 신기해합니다.&lt;/li&gt;&#xD;
  &lt;li&gt;동적 테스트입니다. 정적 테스트보다 변수가 많고 기능이 추가되거나 변경되었을 때 테스트 코드 유지/보수에 추가적인 리소스를 투자해야 합니다.&lt;/li&gt;&#xD;
  &lt;li&gt;브라우저별로 동일한 테스트를 반복하게 할 경우, 상당히 오래 걸립니다. 별도의 테스트 머신에서 돌리거나 퇴근 직전에 돌리고 가는 것이 좋겠다는 생각이 들었습니다.&lt;/li&gt;&#xD;
  &lt;li&gt;UI에 웬 스트레스 테스트냐 하는 분도 있겠지만, 가능하긴 합니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;
&lt;h2&gt;웹기반 데스크탑 애플리케이션 개발 - Electron&lt;/h2&gt;
&lt;p&gt; &lt;a href="http://nwjs.io/"&gt;NW.js&lt;/a&gt;와 &lt;a href="http://electron.atom.io/"&gt;Electron&lt;/a&gt; 둘 중에 Electron이 뭔가 더 깔끔한 것 같다는 생각이 들어서 선택했을 뿐입니다. &lt;a href="https://github.com"&gt;GitHub&lt;/a&gt;에서 만들었고, &lt;a href="https://atom.io/"&gt;Atom editor&lt;/a&gt;가 이 녀석을 이용해서 만들어졌고요. 새롭게 시작하는 프로젝트의 데스크탑 애플리케이션이 필요한 부분에 쓰이고 있습니다. 구글 크롬 브라우저와 Node.js를 포함하고 있어서 하나의 브라우저에서 작동하는 것에만 집중할 수 있습니다. 이 밖에도:&lt;/p&gt;
&lt;ul class="square"&gt;&#xD;
  &lt;li&gt;하이브리드하게 개발하는 모든 장점을 안고 있습니다. 특히, 크로스-플랫폼&lt;/li&gt;&#xD;
  &lt;li&gt;프로세스를 관리해야 하고 IPC 스타일 통신에 익숙해져야 합니다.&lt;/li&gt;&#xD;
  &lt;li&gt;크로스-브라우징을 하지 않는 대신에 OS별 특징들을 관리해야 합니다.&lt;/li&gt;&#xD;
  &lt;li&gt;React와 환상의 궁합입니다. &lt;a href="http://gabrielbull.github.io/react-desktop/demo/"&gt;요런 컴포넌트&lt;/a&gt;가 마구 쏟아진다고 생각해 보세요.&lt;/li&gt;&#xD;
  &lt;li&gt;네이티브 &lt;code&gt;require&lt;/code&gt;를 WebView에서 사용할 수 있습니다.&lt;/li&gt;&#xD;
  &lt;li&gt;ES6과 같은 Transpile이 필요한 코드를 더욱 마음껏 사용할 수 있습니다.&lt;/li&gt;&#xD;
&lt;/ul&gt;
&lt;h2&gt;UI 라이브러리 - React&lt;/h2&gt;
&lt;p&gt; &lt;a href="https://facebook.github.io/react/"&gt;React&lt;/a&gt;는 Facebook 개발자들이 만든 UI 라이브러리입니다. 복잡하고 귀찮은 MVC 개념 따위 과감하게 던져버리고 로직에만 집중할 수 있게 한 새로운 개념 덩어리라고 볼 수 있습니다. 지금까지 OO스럽게 프로그램하려고 상당히 노력해왔는데 그 목마름을  React에서 찾은듯한 느낌입니다. React를 학습하면서 메모했던 내용을 공유합니다.&lt;/p&gt;
&lt;ul class="square"&gt;&#xD;
  &lt;li&gt;React의 컴포넌트는 소유관계이다. 부모는 자식 컴포넌트의 값이나 상태 등을 변경할 수 있지만, 자식은 부모가 가진 모든 것에 접근할 수 없다.&lt;/li&gt;&#xD;
  &lt;li&gt;심지어 자식은 자신이 가진 값(props)도 변경할 수 없으며, 오직 부모에 의해 변경되거나 할당 받을 수 있다.&lt;/li&gt;&#xD;
  &lt;li&gt;HTML 코드를 자바스크립트로 직접 만들어 낼 필요가 없다. state가 변하면(setState) 항상 render가 호출되기 때문에 그때 처리하면 된다.&lt;/li&gt;&#xD;
  &lt;li&gt;DOM event를 직접 바인딩 할 필요 없다. render 메소드 안에서 컴포넌트 메소드에 직접 매핑할 수 있기 때문이다.&lt;/li&gt;&#xD;
  &lt;li&gt;render는 무조건 하나의 객체(요소?)만을 리턴해야 한다.&lt;/li&gt;&#xD;
  &lt;li&gt;show/hide, active/disable 등과 같은 상태성 코드를 작성할 필요가 없다. 만약 이와 같은 코드가 존재한다면 state와 render의 상호작용으로  작동되도록 다시 작성하는 것을 고민해야 한다.&lt;/li&gt;&#xD;
  &lt;li&gt;마찬가지로 dom-storage에 의존할 필요도 없다. 만약 dom-storage를 이용하는 코드가 존재한다면 props와 render의 상호작용으로 작동되도록 다시 작성하는 것을 고민해야 한다.&lt;/li&gt;&#xD;
  &lt;li&gt;같은 레벨의 자식들끼리 소통할 수 없으며 오직 부모에 의해 자식들의 행동이 결정되어야 한다.&lt;/li&gt;&#xD;
  &lt;li&gt;state는 자신이 스스로 값을 변경할 수 있지만, 부모에서 refs 속성으로 접근하여 변경할 수도 있다.&lt;/li&gt;&#xD;
  &lt;li&gt;Virtual DOM을 이용하기 때문에 DOM 선택자를 이용하는 비용을 줄일 수 있다.&lt;/li&gt;&#xD;
  &lt;li&gt;JSX와 궁합이 아주 잘 맞지만, 별도의 Transpiler를 필요로 한다.&lt;/li&gt;&#xD;
  &lt;li&gt;ES6과의 호환성이 좋다. 특히 ES7의 Decorator와 잘 어울린다.&lt;/li&gt;&#xD;
  &lt;li&gt;state를 너무 남용하면 불필요한 렌더링이 자주 발생하기 때문에 컴포넌트의 값을 props와 state중 어디에 담을 것인지 신중히 정하자.&lt;/li&gt;&#xD;
  &lt;li&gt;7가지 생명주기를 가진 컴포넌트 메소드들의 명세를 항상 숙지하고 있어야 한다.&lt;/li&gt;&#xD;
  &lt;li&gt;React 컴포넌트 클래스는 우리가 일반적으로 생각하는 자바스크립 클래스와는 크게 다르며, 모든 메소드는 private으로 작동한다. statics 속성을 이용하여 static 메소드를 작성할 수 있지만, 인스턴스의 this에는 접근할 수 없다.&lt;/li&gt;&#xD;
  &lt;li&gt;그래서 React 컴포넌트의 메소드를 밑줄(&lt;code&gt;_&lt;/code&gt;)을 이용하여 private으로 구분해야 할 필요가 없다.&lt;/li&gt;&#xD;
  &lt;li&gt;클래스 상속과 유사한 개념으로 mixins 기능을 제공한다. 이것은 단순히 공통 메소드를 공유하는 목적일 뿐이다.&lt;/li&gt;&#xD;
&lt;/ul&gt;
&lt;h2&gt;변화&lt;/h2&gt;
&lt;p&gt;개인적인 변화로는 가을에 &lt;a href="https://firejune.com/1806/우리+결혼했어요."&gt;결혼&lt;/a&gt;한 것인데, 덕이 부족하여 생각보다 쉽지 않은 변화된 환경에 적응을 잘하지 못하고 있습니다. 이런저런 변화에 대처하느라 자원를 효율적이지 못하게 소모해 버린 정신없는 한 해였던 것 같습니다.&lt;/p&gt;
&lt;p&gt;2016년에는 일단 정신줄부터 다잡고 진행 중인 프로젝트 성공적으로 마무리 지을 수 있도록 노력하고, 개인적으로는 &lt;a href="https://cordova.apache.org/"&gt;Cordova&lt;/a&gt;를 이용한 하이브리드 모바일 앱 개발에 도전해 보고 싶습니다.&lt;/p&gt;

			&lt;br&gt;&lt;br&gt;
			&lt;a href="https://firejune.com/1796#p1796"&gt;Comments&lt;/a&gt; |
			&lt;a href="https://firejune.com/1796"&gt;Hits(48,643)&lt;/a&gt;&lt;img src="http://feeds.feedburner.com/~r/firejune/~4/sIv5G9TZufw" height="1" width="1" alt=""/&gt;</content><feedburner:origLink>https://firejune.com/1796</feedburner:origLink></entry><entry><title type="text">웹에서 사무용 문서 다루기 - WebODF</title><link rel="alternate" type="text/html" href="http://feedproxy.google.com/~r/firejune/~3/fv3DtyAGjN4/1793" /><category term="자료-웹개발" /><category term="WebODF" /><category term="ViewerJS" /><category term="ODF" /><category term="KO GmbH" /><category term="그래도 일년에 한번은 써야지..." /><category term="자바스크립트" /><author><name>파이어준</name></author><updated>2014-12-21T18:12:11-08:00</updated><id>https://firejune.com/1793</id><content type="html">&lt;p&gt;&lt;a href="http://kogmbh.com/"&gt;KO GmbH&lt;/a&gt;에 의해서 시작된 &lt;a href="http://www.webodf.org/"&gt;WebODF&lt;/a&gt;는 &lt;a href="http://www.opendocumentformat.org/"&gt;OpenDocument Format&lt;/a&gt;(ODF)를 웹사이트에서 사용할 수 있도록 CSS와 HTML을 이용하여 문서를 출력하거나 생성할 수 있게 하는 자바스크립트 라이브러리입니다. 실시간 협업 편집 서비스인 &lt;a href="http://owncloud.org/"&gt;ownCloud&lt;/a&gt;와 문서를 손쉽게 웹페이지에 추가할 수 있게 하는 &lt;a href="http://viewerjs.org/"&gt;ViewerJS&lt;/a&gt; 등에서 WebODF를 사용하고 있습니다.&lt;/p&gt;
&lt;p&gt;ODF는 여러 업무용 애플리케이션에서 사용할 수 있도록 고안되었습니다. XML기반의 파일 포맷이고 스프레드시트, 차트, 프리젠테이션 그리고 워드 프로세싱 등의 사무용 문서를 저장할 수 있습니다. 이 파일 포맷은 Microsoft의 오피스에서 지원되며, &lt;a href="http://en.wikipedia.org/wiki/Sun_Microsystems"&gt;선 마이크로스시템즈&lt;/a&gt;의 &lt;a href="http://blogs.office.com/"&gt;OpenOffice&lt;/a&gt;에서 사용었고 지금은 순수 웹 브라우저만으로도 다룰 수 있게 된 것입니다.&lt;/p&gt;
&lt;p&gt;이 라이브러리는 뷰어와 에디터로 구분하여 사용할 수 있는데, 단순히 ODF 파일을 보여주기만 할 것이라면  &lt;a href="http://webodf.org/download/webodf.js-0.5.4.zip"&gt;webodf.js&lt;/a&gt;를 로드하고 다음과 같이 코드를 작성하면 됩니다.&lt;/p&gt;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;html&amp;gt;&#xD;
 &amp;lt;head&amp;gt;&#xD;
  &amp;lt;script src="webodf.js" type="text/javascript" charset="utf-8"&amp;gt;&amp;lt;/script&amp;gt;&#xD;
  &amp;lt;script type="text/javascript" charset="utf-8"&amp;gt;&#xD;
function init() {&#xD;
  var odfelement = document.getElementById("odf"),&#xD;
      odfcanvas = new odf.OdfCanvas(odfelement);&#xD;
  odfcanvas.load("myfile.odt");&#xD;
}&#xD;
window.setTimeout(init, 0);&#xD;
  &amp;lt;/script&amp;gt;&#xD;
 &amp;lt;/head&amp;gt;&#xD;
 &amp;lt;body&amp;gt;&#xD;
  &amp;lt;div id="odf"&amp;gt;&amp;lt;/div&amp;gt;&#xD;
 &amp;lt;/body&amp;gt;&#xD;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;webodf.js는 여러 개의 자바스크립트가 하나로 합쳐져 만들어진 것입니다. 소스는 &lt;a href="https://github.com/kogmbh/WebODF/"&gt;GitHub 리파지토리&lt;/a&gt;에서 확인하거나 &lt;a href="https://github.com/kogmbh/WebODF/archive/master.zip"&gt;다운로드&lt;/a&gt; 할 수 있으며, &lt;a href="http://webodf.org/tools/index.html#cmake"&gt;CMake&lt;/a&gt;를 이용하여 빌드하는 방법은 다음과 같습니다.&lt;/p&gt;
&lt;pre class="command"&gt;&lt;code&gt;git clone https://github.com/kogmbh/WebODF.git webodf&#xD;
mkdir build&#xD;
cd build&#xD;
cmake ../webodf&#xD;
make webodf.js-target&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;에디터는 일반 편집과 협업 편집모드를 제공하며, &lt;a href="http://webodf.org/download/wodotexteditor-0.5.4.zip"&gt;Wodo.TextEditor&lt;/a&gt;라는 컴포넌트를 필요로 합니다. Wodo.TextEditor는 &lt;a href="http://dojotoolkit.org/"&gt;Dojo&lt;/a&gt;를 기반으로 작성되었으며, webodf.js를 포함하고 있습니다. 다음과 같은 코드로 페이지에 추가할 수 있습니다.&lt;/p&gt;
&lt;pre class="html"&gt;&lt;code&gt;&amp;lt;head&amp;gt;&#xD;
&amp;lt;!-- ... --&amp;gt;&#xD;
&#xD;
&amp;lt;script src="wodotexteditor/wodotexteditor.js" type="text/javascript" charset="utf-8"&amp;gt;&amp;lt;/script&amp;gt;&#xD;
&#xD;
&amp;lt;!-- ... --&amp;gt;&#xD;
&amp;lt;/head&amp;gt;&#xD;
&amp;lt;body&amp;gt;&#xD;
&amp;lt;!-- ... --&amp;gt;&#xD;
&#xD;
&amp;lt;div id="editorContainer" style="width: 600px;height: 600px;"&amp;gt;&amp;lt;/div&amp;gt;&#xD;
&#xD;
&amp;lt;!-- ... --&amp;gt;&#xD;
&#xD;
&amp;lt;script type="text/javascript"&amp;gt;&#xD;
// ...&#xD;
&#xD;
Wodo.createTextEditor('editorContainer', {&#xD;
    allFeaturesEnabled: true,&#xD;
    userData: {&#xD;
        fullName: "Tim Lee",&#xD;
        color:    "blue"&#xD;
    }&#xD;
}, function (err, editor) {&#xD;
    if (err) {&#xD;
        // something failed unexpectedly, deal with it (here just a simple alert)&#xD;
        alert(err);&#xD;
        return;&#xD;
    }&#xD;
    editor.openDocumentFromUrl("document.odt", function(err) {&#xD;
        if (err) {&#xD;
            // something failed unexpectedly, deal with it (here just a simple alert)&#xD;
            alert("There was an error on opening the document: " + err);&#xD;
        }&#xD;
    });&#xD;
});&#xD;
&#xD;
// ...&#xD;
&amp;lt;/script&amp;gt;&#xD;
&#xD;
&amp;lt;!-- ... --&amp;gt;&#xD;
&#xD;
&amp;lt;/body&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="http://www.nodejs.org/"&gt;Node.js&lt;/a&gt;용 프로젝트인 &lt;a href="http://etherpad.org/"&gt;Etherpad&lt;/a&gt;에서 제공하는 것과 같은 협업모드 편집은 웹소켓을 이용한 것으로 서버 컴포넌트가 필요하지만 서버-사이드의 소스코드는 공개되어 있지 않습니다. 단, "programs/editor/backend/pullbox"에 클라이언트-사이드에서 데이터 송/수신을 위한 구현한 코드가 포함했으니 참고하라고 하네요. 이 과정은100% 클라이언트(브라우저)에서 발생하며, 데이터를 서버로 전송하지는 않는다고 합니다.&lt;/p&gt;

			&lt;br&gt;&lt;br&gt;
			&lt;a href="https://firejune.com/1793#p1793"&gt;Comments(2)&lt;/a&gt; |
			&lt;a href="https://firejune.com/1793"&gt;Hits(651,561)&lt;/a&gt;&lt;img src="http://feeds.feedburner.com/~r/firejune/~4/fv3DtyAGjN4" height="1" width="1" alt=""/&gt;</content><feedburner:origLink>https://firejune.com/1793</feedburner:origLink></entry><entry><title type="text">자바스크립트 바이너리 데이터 스트럭쳐 - struct.js</title><link rel="alternate" type="text/html" href="http://feedproxy.google.com/~r/firejune/~3/V-KNo93VkPY/1792" /><category term="자료-웹개발" /><category term="Struct" /><category term="자바스크립트" /><category term="C/C++" /><category term="GitHub" /><category term="ArrayBuffer" /><category term="DataView" /><category term="HTML5" /><category term="프로젝트" /><category term="struct.js" /><category term="배포" /><author><name>파이어준</name></author><updated>2013-08-01T09:24:06-07:00</updated><id>https://firejune.com/1792</id><content type="html">&lt;p&gt;일반적으로 C언어에서 struct에 의해 구조화된 바이너리 데이터를 자바스크립트에서 사용할 수 있게 변환하고 이를 다시 조작하여 바이너리로 생성하는 과정이 엘레강스(?)하지가 않아서 C의 struct와 유사하게 자바스크립트에서도 구조체를 사용할 수 있도록 작은 유틸리티를 만들었습니다. 만들고 보니, 다른 곳에서도 유용하게 사용될 수 있을 것 같아 공개합니다.&lt;/p&gt;
&lt;p&gt;우선, 자바스크립트만으로 ArrayBuffer를 다루어 보겠습니다. 예제에 사용되는 바이너리 데이터는 0번째 번지에 Uint8 유형의 정수,  1번째 번지에 Int8 유형의 정수, 3번째 번지에는 Uint16 유형의 2바이트짜리 정수이며, 이를 쓰고 다시 읽어내는 것입니다:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;// define struct&#xD;
var struct = {&#xD;
  foo: 255,&#xD;
  bar: 127,&#xD;
  baz: {&#xD;
    qux: 65535&#xD;
  }&#xD;
};&#xD;
&#xD;
// write arraybuffer from javascript object&#xD;
var ab = new ArrayBuffer(4);&#xD;
var dv = new DataView(ab);&#xD;
dv.setUint8(0, struct.foo);&#xD;
dv.setInt8(1, struct.bar);&#xD;
dv.setUint16(2, struct.baz.qux, true);&#xD;
&#xD;
console.log(dv.buffer);&#xD;
// =&amp;gt; ArrayBuffer {byteLength: 4, slice: function}&#xD;
&#xD;
// read data from arraybuffer&#xD;
var dv2 = new DataView(dv.buffer);&#xD;
var data = {&#xD;
  foo: dv2.getUint8(0),&#xD;
  bar: dv2.getInt8(1),&#xD;
  baz: {&#xD;
    qux: dv2.getUint16(2, true)&#xD;
  }&#xD;
};&#xD;
&#xD;
console.log(data);&#xD;
// =&amp;gt; Obejct {foo: 255, bar: 127, baz: {qux: 65535}}}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;옵셋을 손으로 패딩해야하며 형식이 동일한 구조의 데이터를 읽고 생성하려 했지만 도저히 같다고는 느껴지지 않습니다. 그리고 버퍼의 크기가 크면 클수록 사용성이 떨어지는 문제도 있습니다. struct.js를 사용하면 다음과 같이 코드를 작성할 수 있습니다:&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;// define struct&#xD;
var struct = new Struct({&#xD;
  foo: ['uint8', 255],&#xD;
  bar: ['int8', 127], &#xD;
  baz: {&#xD;
    qux: ['uint16', 65535]&#xD;
  }&#xD;
}, 0, true);&#xD;
&#xD;
// write arraybuffer from javascript object&#xD;
var ab = struct.write();&#xD;
console.log(ab);&#xD;
// =&amp;gt; ArrayBuffer {byteLength: 4, slice: function}&#xD;
&#xD;
// read data from arraybuffer&#xD;
var data = struct.read(ab);&#xD;
console.log(data);&#xD;
// =&amp;gt; Obejct {foo: 255, bar: 127, baz: {qux: 65535}}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;옵셋을 자동으로 카운트하고, 자바스크립트 형식으로 작성한  데이터 구조체를 재활용하여 새로운 arraybuffer를 생성하거나 반대로 자바스립트에서 읽을 수 있는 데이터로 만들어 사용하기가 수월합니다. 이는 마치 C에서 생성하는 구조체를 사용하는 느낌입니다.&lt;/p&gt;
&lt;p&gt;속성(키)/[유형(타입), 값(밸류)]로 구조를 작성해야 하며 '속성/유형'만 지정하면 버퍼를 작성하는 경우 기본값이 할당됩니다. 즉, '밸류'는 &lt;code&gt;write&lt;/code&gt; 메서드를 이용하여 ArrayBuffer를 생성하는 곳에만 사용되며, 단순히 &lt;code&gt;read&lt;/code&gt; 메서드로 데이터를 읽기만 한다거나, 속성마다 특정한 값을 설정할 필요가 없는 경우라면 타입만 지정해도 된다는 의미입니다. 다음은 &lt;code&gt;read&lt;/code&gt; 메서드의 두 번째 인자에 사용자 지정 옵셋을 입력하여 동일한 형식의 데이터가 복수로 담긴 청크를 처리하는 모습입니다.&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;/**&#xD;
 * read multiple data with custom offset&#xD;
 */&#xD;
&#xD;
var struct = new Struct({&#xD;
  sig: 'uint8',&#xD;
  mimeType: 'uint8',&#xD;
  id: 'uint16',&#xD;
  byteLength: 'uint32'&#xD;
});&#xD;
&#xD;
...&#xD;
&#xD;
function parseBinary(chunk, count, callback) {&#xD;
  var offset = 0;&#xD;
  for (var index = 0; index &amp;lt; count; index++) {&#xD;
    var meta = struct.read(chunk, offset)&#xD;
      , buffer = chunk.slice(&#xD;
        offset += struct.byteLength,&#xD;
        offset += meta.byteLength&#xD;
      );&#xD;
&#xD;
    callback(meta, new Uint8Array(buffer));&#xD;
  }&#xD;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;write&lt;/code&gt; 메서드에 변경할 내용이 담긴 객체를 인자로 전달하여 복수의 값을 갱신할 수 있도 있습니다. 입력 객체는 하위 구조의 값까지 모두 비교하여 값을 할당하기 때문에 다음과 같이 작성해도 무방합니다.(jquery의 $.extend와는 개념이 다름)&lt;/p&gt;
&lt;pre class="javascript"&gt;&lt;code&gt;// define struct&#xD;
var struct = new Struct({&#xD;
  foo: ['uint8', 255],&#xD;
  bar: 'int8', &#xD;
  baz: {&#xD;
    qux: ['uint16', 65535],&#xD;
    quux: ['uint32', 0]&#xD;
  }&#xD;
}, 1, true);&#xD;
&#xD;
// update values and write arraybuffer&#xD;
var ab = struct.write({&#xD;
  foo: 0,&#xD;
  baz: {&#xD;
    quux: 4294967295&#xD;
  }&#xD;
});&#xD;
// write =&amp;gt; ArrayBuffer {byteLength: 8, slice: function}&#xD;
// read =&amp;gt; Obejct {foo: 0, bar: 1, baz: {qux: 65535, quux: 4294967295}}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;끝으로, 하나의 속성에 멀티-바이트 타입 배열을 지정할 수 있도록 했습니다. 각각의 번지마다 연속된 