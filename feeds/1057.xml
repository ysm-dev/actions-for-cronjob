<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>황교빈의 아카이브</title>
	<atom:link href="https://archive.htrucci.com/feed/" rel="self" type="application/rss+xml" />
	<link>https://archive.htrucci.com</link>
	<description>황트루치</description>
	<lastBuildDate>Wed, 13 Mar 2019 02:51:38 +0000</lastBuildDate>
	<language>ko-KR</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>

<image>
	<url>http://res.cloudinary.com/htrucci-archive/image/upload/h_32,w_32/v1511501686/cropped-developer-512-1_op5aty.png</url>
	<title>황교빈의 아카이브</title>
	<link>https://archive.htrucci.com</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>[Docker, SpringBoot, Maven] 스프링부트 도커 이미지로 메이븐 빌드하여 로컬 실행해보기</title>
		<link>https://archive.htrucci.com/22867/docker-springboot-maven-%ec%8a%a4%ed%94%84%eb%a7%81%eb%b6%80%ed%8a%b8-%eb%8f%84%ec%bb%a4-%ec%9d%b4%eb%af%b8%ec%a7%80%eb%a1%9c-%eb%a9%94%ec%9d%b4%eb%b8%90-%eb%b9%8c%eb%93%9c%ed%95%98%ec%97%ac/</link>
		<comments>https://archive.htrucci.com/22867/docker-springboot-maven-%ec%8a%a4%ed%94%84%eb%a7%81%eb%b6%80%ed%8a%b8-%eb%8f%84%ec%bb%a4-%ec%9d%b4%eb%af%b8%ec%a7%80%eb%a1%9c-%eb%a9%94%ec%9d%b4%eb%b8%90-%eb%b9%8c%eb%93%9c%ed%95%98%ec%97%ac/#respond</comments>
		<pubDate>Tue, 05 Mar 2019 02:42:26 +0000</pubDate>
		<dc:creator><![CDATA[htrucci]]></dc:creator>
				<category><![CDATA[IT/개발]]></category>
		<category><![CDATA[‣ 개발자 뇌 개발]]></category>
		<category><![CDATA[‣ 언어, 프레임워크]]></category>
		<category><![CDATA[springboot]]></category>
		<category><![CDATA[maven]]></category>
		<category><![CDATA[빌드]]></category>
		<category><![CDATA[도커]]></category>
		<category><![CDATA[docker]]></category>
		<category><![CDATA[메이븐]]></category>
		<category><![CDATA[스프링부트]]></category>
		<category><![CDATA[로컬]]></category>
		<category><![CDATA[localhost]]></category>

		<guid isPermaLink="false">https://archive.htrucci.com/?p=22867</guid>
		<description><![CDATA[메이븐에서 검색해보면 스포티파이에서 만든 인기있는 도커 클라이언트가 있다. https://mvnrepository.com/artifact/com.spotify/docker-client 스프링부트에 이걸 붙여서 로컬에서 메이븐 빌드하여 간단히 도커 이미지로 실행해보자. 1. 메이븐에 아래와 같이 붙여본다. [crayon-5cd977f392174356421314/] &#160; 리소스 설정 부분을 보면&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p>메이븐에서 검색해보면 스포티파이에서 만든 인기있는 도커 클라이언트가 있다.<br />
https://mvnrepository.com/artifact/com.spotify/docker-client</p>
<p>스프링부트에 이걸 붙여서 로컬에서 메이븐 빌드하여 간단히 도커 이미지로 실행해보자.</p>
<p>
1. 메이븐에 아래와 같이 붙여본다.</p>
<p></p><pre class="crayon-plain-tag">&lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;docker.image.prefix&gt;springboot&lt;/docker.image.prefix&gt;
    &lt;/properties&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;!-- Docker maven plugin --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;com.spotify&lt;/groupId&gt;
                &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.0.0&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;
                    &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt;
                    &lt;resources&gt;
                        &lt;resource&gt;
                            &lt;targetPath&gt;/&lt;/targetPath&gt;
                            &lt;directory&gt;${project.build.directory}&lt;/directory&gt;
                            &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;
                        &lt;/resource&gt;
                    &lt;/resources&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;!-- Docker maven plugin --&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;</pre><p></p>
<p>&nbsp;</p>
<ol>
<li>리소스 설정 부분을 보면 도커디렉토리를 src/main/docker로 명시한 것을 볼 수 있다. <br />
실제로 폴더를 만들고 Dockerfile을 생성해주었다.<br />
메이븐 구성에 따라 생성되는 jar의 이름을 아래 잘 바꿔 넣어줘야 한다.</li>
</ol>
<p></p><pre class="crayon-plain-tag">FROM openjdk:8-jdk-alpine
VOLUME /tmp
ADD htrucci-springboot-0.0.1-SNAPSHOT.jar app.jar
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/app.jar"]</pre><p></p>
<p>
3. 메이븐 빌드</p>
<p></p><pre class="crayon-plain-tag">clean package docker:build</pre><p></p>
<ul>
<li>당연히 도커가 설치되어있고 실행중이어야 오류가 안난다. *</li>
</ul>
<p>4. 빌드된 컨테이너 확인</p>
<p></p><pre class="crayon-plain-tag">$ docker container ls -a</pre><p></p>
<p>있다, 내가 빌드한 이미지가 추가되어있다. 위에서 설정은 이미지 네임으로. <br />
&lt;imageName&gt;${docker.image.prefix}/${project.artifactId}&lt;/imageName&gt;</p>
<p>5.<br />
테스트를 위해 도커내에서 간단히 스프링 부트를 구동시켜보자<br />
8080포트로 맵핑해줄거고 두 명령어의 차이는 백그라운드 모드로 실행할 것인지의 차이임.</p>
<p></p><pre class="crayon-plain-tag">$ docker run -p 8080:8080 이미지이름
$ docker run -d -p 8080:8080 이미지이름</pre><p></p>
<p>
간단히 로컬에서 올려보았지만, 몇몇 과정을 자동화하는 기대치를 만족시키기 위해 문서를 잘 살펴볼 필요가 있겠다.<br />
도커도 좀 더 봐야할 것 같구&#8230;</p>
]]></content:encoded>
			<wfw:commentRss>https://archive.htrucci.com/22867/docker-springboot-maven-%ec%8a%a4%ed%94%84%eb%a7%81%eb%b6%80%ed%8a%b8-%eb%8f%84%ec%bb%a4-%ec%9d%b4%eb%af%b8%ec%a7%80%eb%a1%9c-%eb%a9%94%ec%9d%b4%eb%b8%90-%eb%b9%8c%eb%93%9c%ed%95%98%ec%97%ac/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>[Maven] spotify docker client 빌드시 GET unix://localhost:80/version: 502, body: Bad response from Docker engine: HTTP 502 Bad Gateway</title>
		<link>https://archive.htrucci.com/22865/maven-spotify-docker-client-%eb%b9%8c%eb%93%9c%ec%8b%9c-get-unix-localhost80-version-502-body-bad-response-from-docker-engine-http-502-bad-gateway/</link>
		<comments>https://archive.htrucci.com/22865/maven-spotify-docker-client-%eb%b9%8c%eb%93%9c%ec%8b%9c-get-unix-localhost80-version-502-body-bad-response-from-docker-engine-http-502-bad-gateway/#respond</comments>
		<pubDate>Tue, 05 Mar 2019 02:06:18 +0000</pubDate>
		<dc:creator><![CDATA[htrucci]]></dc:creator>
				<category><![CDATA[IT/개발]]></category>
		<category><![CDATA[‣ 오늘의 삽질]]></category>
		<category><![CDATA[build]]></category>
		<category><![CDATA[maven]]></category>
		<category><![CDATA[빌드]]></category>
		<category><![CDATA[도커]]></category>
		<category><![CDATA[docker]]></category>
		<category><![CDATA[메이븐]]></category>

		<guid isPermaLink="false">https://archive.htrucci.com/?p=22865</guid>
		<description><![CDATA[[Maven] spotify docker client 빌드시 GET unix://localhost:80/version: 502, body: Bad response from Docker engine: HTTP 502 Bad Gateway [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.0.0:build (default-cli) on project htrucci-springboot: Exception caught:&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p class="p1">[Maven] spotify docker client 빌드시 GET unix://localhost:80/version: 502, body: Bad response from Docker engine: HTTP 502 Bad Gateway <br />
[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.0.0:build (default-cli) on project htrucci-springboot: Exception caught: Request error: GET unix://localhost:80/version: 502, body: Bad response from Docker engine: HTTP 502 Bad Gateway -&gt; [Help 1]</p>
<p>
터미널에 아래 명령 실행</p>
<div class="wpe-box wpe-box-note">
<p class="p1"><span class="s1">export DOCKER_HOST=unix:///var/run/docker.sock</span></p>
</div>
]]></content:encoded>
			<wfw:commentRss>https://archive.htrucci.com/22865/maven-spotify-docker-client-%eb%b9%8c%eb%93%9c%ec%8b%9c-get-unix-localhost80-version-502-body-bad-response-from-docker-engine-http-502-bad-gateway/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>하늘 _ 신해철&#038;N.EX.T, 싸이(Psy) _ 박노해 노동의 새벽 20주년 헌정공연</title>
		<link>https://archive.htrucci.com/22862/%ed%95%98%eb%8a%98-_-%ec%8b%a0%ed%95%b4%ec%b2%a0n-ex-t-%ec%8b%b8%ec%9d%b4psy-_-%eb%b0%95%eb%85%b8%ed%95%b4-%eb%85%b8%eb%8f%99%ec%9d%98-%ec%83%88%eb%b2%bd-20%ec%a3%bc%eb%85%84-%ed%97%8c%ec%a0%95/</link>
		<comments>https://archive.htrucci.com/22862/%ed%95%98%eb%8a%98-_-%ec%8b%a0%ed%95%b4%ec%b2%a0n-ex-t-%ec%8b%b8%ec%9d%b4psy-_-%eb%b0%95%eb%85%b8%ed%95%b4-%eb%85%b8%eb%8f%99%ec%9d%98-%ec%83%88%eb%b2%bd-20%ec%a3%bc%eb%85%84-%ed%97%8c%ec%a0%95/#respond</comments>
		<pubDate>Sat, 02 Feb 2019 16:15:49 +0000</pubDate>
		<dc:creator><![CDATA[htrucci]]></dc:creator>
				<category><![CDATA[음악]]></category>
		<category><![CDATA[신해철]]></category>
		<category><![CDATA[싸이]]></category>
		<category><![CDATA[노동의 새벽]]></category>
		<category><![CDATA[박노해]]></category>

		<guid isPermaLink="false">https://archive.htrucci.com/?p=22862</guid>
		<description><![CDATA[[곡 소개] 《노동의 새벽》을 여는 첫머리 시는 &#8216;하늘&#8217;이다. 이것은 의미 심장하다. &#8216;아 우리도 하늘이 되고 싶다&#8217;고 노동자들은 나직이 부르짖지만, 그러나 그 누구를 짓누르는 먹구름 하늘을 꿈꾸지 않는다. 서로를 받쳐주는, 우리&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p></p>
<p><iframe width="560" height="315" src="https://www.youtube.com/embed/zXRjKuWQGnk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen"></iframe></p>
<p>[곡 소개] 《노동의 새벽》을 여는 첫머리 시는 &#8216;하늘&#8217;이다. 이것은 의미 심장하다. &#8216;아 우리도 하늘이 되고 싶다&#8217;고 노동자들은 나직이 부르짖지만, 그러나 그 누구를 짓누르는 먹구름 하늘을 꿈꾸지 않는다. 서로를 받쳐주는, 우리 모두 서로가 서로에게 푸른 하늘이 되는 그런 세상을 꿈꾼다. 《노동의 새벽》의 이런 따뜻하나 혁명적인 반전, &#8216;하늘&#8217;을 노래로 만드는 일은 한국 대중음악계의 탈출구 싸이와 넥스트가 맡았다. 거침없이 때론 능청스러운 랩으로 불러 젖히는 싸이의 목소리와 신들린듯한 넥스트의 연주는 20000년대식 &#8216;하늘&#8217;이다. 마치 《노동의 새벽》을 다시 읽어보라는 주문처럼 들린다. 지금 우리의 삶이 딛고 선 존재의 발밑을 돌아보라고, 우리의 노동이 어떤 노동을 딛고 있으며 어떤 하늘을 꿈꾸고 있는지 돌아보며 전진하라는 주문 말이다.</p>
<p>[아티스트 소감] &#8220;박노해님의 시와 노래&#8230; 아니 그의 절규와 휴머니즘은 이렇게 먼 시절로부터 지금까지 각박한 삶과 노동살이로 식어진 우리네 심장을 어루만지며, 또한 지금도 역시 어딘가에 구석자리를 마련한 노동자들의 서러운 술자리를 위로합니다. 20년의 세월을 넘어서도 우리에게 위로와 힘을 토하며 다가오는 그를 새기로 전위 노동 운동가보다는 인간으로서의 그를 바라보며&#8230; 그 안의 정신을 위해 노래합니다.&#8221; _ N.EX.T &#8220;당시 하루하루 치열하게 사셨던 선배님들의 삶을 조금이 나마 느끼고 배우기 위해 노래를 부르게 되었다. 참으로 큰 영광이 아닐 수 없다.&#8221; _ 싸이</p>
]]></content:encoded>
			<wfw:commentRss>https://archive.htrucci.com/22862/%ed%95%98%eb%8a%98-_-%ec%8b%a0%ed%95%b4%ec%b2%a0n-ex-t-%ec%8b%b8%ec%9d%b4psy-_-%eb%b0%95%eb%85%b8%ed%95%b4-%eb%85%b8%eb%8f%99%ec%9d%98-%ec%83%88%eb%b2%bd-20%ec%a3%bc%eb%85%84-%ed%97%8c%ec%a0%95/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>[k8s] 쿠버네티스 튜토리얼 따라해보기</title>
		<link>https://archive.htrucci.com/22859/k8s-%ec%bf%a0%eb%b2%84%eb%84%a4%ed%8b%b0%ec%8a%a4-%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc-%eb%94%b0%eb%9d%bc%ed%95%b4%eb%b3%b4%ea%b8%b0/</link>
		<comments>https://archive.htrucci.com/22859/k8s-%ec%bf%a0%eb%b2%84%eb%84%a4%ed%8b%b0%ec%8a%a4-%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc-%eb%94%b0%eb%9d%bc%ed%95%b4%eb%b3%b4%ea%b8%b0/#respond</comments>
		<pubDate>Wed, 16 Jan 2019 01:45:44 +0000</pubDate>
		<dc:creator><![CDATA[htrucci]]></dc:creator>
				<category><![CDATA[‣ 개발자 뇌 개발]]></category>
		<category><![CDATA[‣ 개발도구, 프로젝트관리]]></category>
		<category><![CDATA[튜토리얼]]></category>
		<category><![CDATA[k8s]]></category>
		<category><![CDATA[쿠버네티스]]></category>

		<guid isPermaLink="false">https://archive.htrucci.com/?p=22859</guid>
		<description><![CDATA[minikube 설치 확인 $ minikube version 미니큐브가 설치되었으니 시작해보자 $ minikube start 설치되어있는 kubectl 버전을 확인 $ kubectl version 클러스터 마스터 정보 확인 및 노드 정보 확인 $ kubectl cluster-info&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p class="p1">minikube <span class="s1">설치</span> <span class="s1">확인</span></p>
<p class="p1">$ minikube version</p>
<p class="p3">미니큐브가 설치되었으니 시작해보자</p>
<p class="p1">$ minikube start</p>
<p class="p3">설치되어있는<span class="s2"> kubectl </span>버전을 확인</p>
<p class="p1">$ kubectl version</p>
<p class="p3">클러스터 마스터 정보 확인 및 노드 정보 확인</p>
<p class="p1">$ kubectl cluster-info</p>
<p class="p1">$ kubectl get nodes</p>
<p class="p3">디플로이먼트를 생성할 때<span class="s2">, </span>애플리케이션에 대한 컨테이너 이미지와 구동시키고자 하는 복제 수를 지정해야한다<span class="s2">.</span></p>
<p class="p3"><span class="s2">kubectl run</span>을 이용하여 디플로이먼트 생성하기<span class="s2"> (</span>도커허브의 이미지를 지정해주고<span class="s2">, </span>포트 파라미터를 전달했다<span class="s2">)</span></p>
<p class="p1">$ kubectl run kubernetes-bootcamp —image=<a href="http://gcr.io/google-samples/kubernetes-bootcamp:v1"><span class="s3">gcr.io/google-samples/kubernetes-bootcamp:v1</span></a> —port=8080</p>
<p class="p3">생성된 디플로이먼트를 확인해보자<span class="s2"> (1</span>개의 싱글 인스턴스가 노드의 도커 컨테이너에서 돌고있다<span class="s2">)</span></p>
<p class="p1">$ kubectl get deployments</p>
<p class="p3">프록시를 만듬<span class="s2"> (</span>프록시를 통해 앱을 노출시킬 수 있음<span class="s2">)</span></p>
<p class="p1">$ kubectl proxy</p>
<p class="p3"><span class="s2">Pod</span>이름을 가져오기</p>
<p class="p1">$ export POD_NAME=$(kubectl get pods -o go-template &#8211;template &#8216;{{range .items}}{{.metadata.name}}{{&#8220;\n&#8221;}}{{end}}&#8217;)</p>
<p class="p1">$ echo Name of the Pod: $POD_NAME</p>
<p class="p3"><span class="s2">$Pod</span>이름으로 애플리케이션의<span class="s2"> API</span>에 접근해보기</p>
<p class="p4"><span class="s4">curl <a href="http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/">http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/</a></span></p>
<p class="p3"><span class="s2">pods</span>정보 가져오기</p>
<p class="p1">$ kubectl get pods</p>
<p class="p3"><span class="s2">ip, port</span>를 포함한 파드의 상세 정보를 가져오기</p>
<p class="p1">$ kubectl describe pods</p>
<p class="p1">pod<span class="s1">의</span> STDOUT <span class="s1">로그</span> <span class="s1">확인해보기</span></p>
<p class="p1">$ kubectl logs $POD_NAME</p>
<p class="p3"><span class="s2">exec</span>커맨드를 통해 파드안에 커맨드를 날릴 수 있다<span class="s2">.</span></p>
<p class="p1">$ kubectl exec $POD_NAME env</p>
<p class="p3"><span class="s2">pod</span>컨테이너에<span class="s2"> bash</span>세션 시작하기</p>
<p class="p1">$ kubectl exec -ti $POD_NAME bash</p>
<p class="p3">정말 안에 있는지 확인하기 위해<span class="s2"> server.js</span>파일 보고<span class="s2">,, </span>로컬호스트에<span class="s2"> curl</span>도 날려보자</p>
<p class="p1">$ cat server.js</p>
<p class="p1">$ curl localhost:8080</p>
<p class="p1">$ exit</p>
<p class="p1">NodePort<span class="s1">를</span> <span class="s1">파라미터로</span> <span class="s1">주고</span> expose<span class="s1">해서</span> <span class="s1">외부로</span> <span class="s1">새로운</span> <span class="s1">서비스를</span> <span class="s1">노출하기</span>(30000-32767 <span class="s1">사이에서</span> <span class="s1">자동생성</span>)<br />
$ kubectl expose deployment/kubernetes-bootcamp &#8211;type=&#8221;NodePort&#8221; &#8211;port 8080</p>
<p class="p1">service/kubernetes-bootcamp exposed</p>
<p class="p1">kubernetes-bootcamp<span class="s1">의</span> <span class="s1">상세</span> <span class="s1">속성을</span> <span class="s1">보자</span></p>
<p class="p1">$ kubectl describe services/kubernetes-bootcamp</p>
<p class="p1">NODE_PORT <span class="s1">환경변수</span> <span class="s1">설정</span></p>
<p class="p1">$ export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}&#8217;)</p>
<p class="p1">$ echo NODE_PORT=$NODE_PORT</p>
<p class="p1"><span class="s1">노출된</span> <span class="s1">미니포트</span>IP<span class="s1">의</span> NODE_PORT<span class="s1">에</span> <span class="s1">접근해보자</span></p>
<p class="p1">$ curl $(minikube ip):$NODE_PORT</p>
<p class="p1">kubernetes-bootcamp<span class="s1">란</span> <span class="s1">이름으로</span> get pods</p>
<p class="p1">$ kubectl get pods -l run=kubernetes-bootcamp</p>
<p class="p1">kubernetes-bootcamp<span class="s1">란</span> <span class="s1">이름으로</span> get services</p>
<p class="p1">$ kubectl get services -l run=kubernetes-bootcamp</p>
<p class="p1">POD_NAME <span class="s1">환경변수</span> <span class="s1">생성</span></p>
<p class="p1">$ export POD_NAME=$(kubectl get pods -o go-template &#8211;template &#8216;{{range .items}}{{.metadata.name}}{{&#8220;\n&#8221;}}{{end}}&#8217;)</p>
<p class="p1">$ echo Name of the Pod: $POD_NAME</p>
<p class="p1">POD_NAME<span class="s1">에</span> app=v1<span class="s1">이라는</span> <span class="s1">라벨을</span> <span class="s1">붙여주자</span></p>
<p class="p1">$ kubectl label pod $POD_NAME app=v1</p>
<p class="p3">다시 정보를 출력해보면<span class="s2"> Labels</span>에<span class="s2"> app=v1</span>이 추가된걸 확인할 수 있다<span class="s2">.</span></p>
<p class="p1">$ kubectl describe pods $POD_NAME</p>
<p class="p1">app=v1<span class="s1">라벨이</span> <span class="s1">달린</span> pods<span class="s1">가져오기</span></p>
<p class="p1">$ kubectl get pods -l app=v1</p>
<p class="p1">run=kubernetes-bootcamp <span class="s1">라벨이</span> <span class="s1">붙은</span> <span class="s1">서비스를</span> <span class="s1">삭제해보자</span></p>
<p class="p1">$ kubectl delete service -l run=kubernetes-bootcamp</p>
<p class="p3">잘 날라갔다<span class="s2">.</span></p>
<p class="p1">$ kubectl get services</p>
<p class="p3">그래서<span class="s2"> curl</span>테스트도 실패한다<span class="s2">.</span></p>
<p class="p1">$ curl $(minikube ip):$NODE_PORT</p>
<p class="p3">그래도 팟 내부에서 실행하도록<span class="s2"> curl </span>테스트해보면 살아있는 걸 볼 수 있다<span class="s2">.</span></p>
<p class="p1">$ kubectl exec -ti $POD_NAME curl localhost:8080</p>
<p class="p1">kubectl scale<span class="s1">을</span> <span class="s1">이용하여</span> replicas<span class="s1">를</span> 4<span class="s1">개로</span> <span class="s1">설정해보자</span></p>
<p class="p1">$ kubectl scale deployments/kubernetes-bootcamp &#8211;replicas=4</p>
<p class="p3"><span class="s2">4</span>개의 인스턴스가 있음을 확인할 수 있다<span class="s2">.</span></p>
<p class="p1">$ kubectl get deployments</p>
<p class="p3">각각 풀어서 보기</p>
<p class="p1">$ kubectl get pods -o wide</p>
<p class="p3">엔드포인트 확인해본다</p>
<p class="p1">$ kubectl describe services/kubernetes-bootcamp</p>
<p class="p1">NODE_PORT <span class="s1">환경변수</span> <span class="s1">설정</span></p>
<p class="p1">$ export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}&#8217;)</p>
<p class="p1">$ echo NODE_PORT=$NODE_PORT</p>
<p class="p3"><span class="s2">pod</span>에<span class="s2"> curl</span>테스트를 날려보면 매번 다른<span class="s2"> pod</span>에 요청이 가는걸 확인할 수 있다<span class="s2">. (</span>로드밸런싱<span class="s2">)</span></p>
<p class="p1">$ curl $(minikube ip):$NODE_PORT</p>
<p class="p3">스케일다운 처리하기</p>
<p class="p1">$ kubectl scale deployments/kubernetes-bootcamp &#8211;replicas=2</p>
<p class="p3"><span class="s2">2</span>개로 잘 줄었나<span class="s2">?</span></p>
<p class="p1">$ kubectl get deployments</p>
<p class="p1">$ kubectl get pods -o wide</p>
<p class="p3">이미지를 새버전으로 업데이트해보자</p>
<p class="p1">$ kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</p>
<p class="p1">Describe</p>
<p class="p1">$ kubectl describe services/kubernetes-bootcamp</p>
<p class="p1">Export NODE_PORT</p>
<p class="p1">$ export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}&#8217;)</p>
<p class="p1">$ echo NODE_PORT=$NODE_PORT</p>
<p class="p1">curl<span class="s1">날려보면</span> <span class="s1">모두</span> v2 pods<span class="s1">에</span> <span class="s1">요청이</span> <span class="s1">감을</span> <span class="s1">확인할</span> <span class="s1">수</span> <span class="s1">있다</span>.</p>
<p class="p1">$ curl $(minikube ip):$NODE_PORT</p>
<p class="p1">rollout status<span class="s1">하면</span>,,, <span class="s1">이미지는</span> v2<span class="s1">로</span> <span class="s1">바뀌었다</span>.</p>
<p class="p1">$ kubectl rollout status deployments/kubernetes-bootcamp</p>
<p class="p1">$ kubectl get pods</p>
<p class="p1">$ kubectl describe pods</p>
<p class="p3">롤백해보기<span class="s2"> (</span>이미지를<span class="s2"> v10</span>으로 변경<span class="s2">)</span></p>
<p class="p1">$ kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=<a href="http://gcr.io/google-samples/kubernetes-bootcamp:v10"><span class="s3">gcr.io/google-samples/kubernetes-bootcamp:v10</span></a></p>
<p class="p3">정보를 가져와보니 이미지가<span class="s2"> v10</span>으로 안바뀌어있음</p>
<p class="p1">$ kubectl get deployments</p>
<p class="p1">$ kubectl get pods</p>
<p class="p1">$ kubectl describe pods</p>
<p class="p1">rollout undo<span class="s1">로</span> <span class="s1">롤백합시다</span>.</p>
<p class="p1">$ kubectl rollout undo deployments/kubernetes-bootcamp</p>
<p class="p3">정상임을 재확인</p>
<p class="p1">$ kubectl get pods</p>
<p class="p1">$ kubectl describe pods</p>
]]></content:encoded>
			<wfw:commentRss>https://archive.htrucci.com/22859/k8s-%ec%bf%a0%eb%b2%84%eb%84%a4%ed%8b%b0%ec%8a%a4-%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc-%eb%94%b0%eb%9d%bc%ed%95%b4%eb%b3%b4%ea%b8%b0/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>[Docker] 도커 튜토리얼 따라해보기</title>
		<link>https://archive.htrucci.com/22856/docker-%eb%8f%84%ec%bb%a4-%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc-%eb%94%b0%eb%9d%bc%ed%95%b4%eb%b3%b4%ea%b8%b0/</link>
		<comments>https://archive.htrucci.com/22856/docker-%eb%8f%84%ec%bb%a4-%ed%8a%9c%ed%86%a0%eb%a6%ac%ec%96%bc-%eb%94%b0%eb%9d%bc%ed%95%b4%eb%b3%b4%ea%b8%b0/#respond</comments>
		<pubDate>Wed, 16 Jan 2019 01:44:49 +0000</pubDate>
		<dc:creator><![CDATA[htrucci]]></dc:creator>
				<category><![CDATA[IT/개발]]></category>
		<category><![CDATA[‣ 개발자 뇌 개발]]></category>
		<category><![CDATA[‣ 개발도구, 프로젝트관리]]></category>
		<category><![CDATA[도커]]></category>
		<category><![CDATA[docker]]></category>
		<category><![CDATA[튜토리얼]]></category>

		<guid isPermaLink="false">https://archive.htrucci.com/?p=22856</guid>
		<description><![CDATA[도커 설치 https://docs.docker.com/docker-for-mac/install/ Docker.dmg 받아서 설치 잘설치되었는지 버전 확인해봤다 $ docker —version 아래 명령어는 더 상세히 보기. $ docker info hello-world 실행해봤다 $ docker run hello-world $ docker run &#8211;detach&#46;&#46;&#46;]]></description>
				<content:encoded><![CDATA[<p class="p1">도커 설치</p>
<p class="p2"><a href="https://docs.docker.com/docker-for-mac/install/">https://docs.docker.com/docker-for-mac/install/</a></p>
<p class="p4">Docker.dmg <span class="s2">받아서</span> <span class="s2">설치</span></p>
<p class="p1">잘설치되었는지 버전 확인해봤다</p>
<p class="p4">$ docker —version</p>
<p class="p1">아래 명령어는 더 상세히 보기<span class="s1">.</span></p>
<p class="p4">$ docker info</p>
<p class="p4">hello-world <span class="s2">실행해봤다</span></p>
<p class="p4">$ docker run hello-world</p>
<p class="p4">$ docker run &#8211;detach &#8211;publish=80:80 &#8211;name=webserver nginx</p>
<p class="p1">훌륭한<span class="s1"> nginx</span>페이지가 떴다<span class="s1">.</span></p>
<p class="p1">아래 명령어로 서버 러닝 상태를 확인 가능하다</p>
<p class="p4">$ docker container ls -a</p>
<p class="p1">또한 아래 명령어로 이미지<span class="s1"> stop </span>및 삭제가 가능</p>
<p class="p4">$ docker container ls</p>
<p class="p4">$ docker container stop webserver</p>
<p class="p4">$ docker container ls -a</p>
<p class="p4">$ docker container rm webserver</p>
<p class="p4">$ docker image ls</p>
<p class="p4">$ docker image rm nginx</p>
<p class="p1">도커<span class="s1"> for mac 18.06 </span>이상에서는 독립형 쿠버네티스가 포함되어 있으므로 쿠버네티스에서 도커 부하를 테스트할 수 있다<span class="s1">.</span></p>
<p class="p4"><span class="s2">없으면</span> <span class="s2">설치하도록</span> (<span class="s2">설정에서</span> Enable <span class="s2">및</span> Default <span class="s2">설정</span> <span class="s2">체크</span> <span class="s2">풀어준다</span>)</p>
<p id="ewAaiNJ"><img class="alignnone wp-image-22857" src="https://archive.htrucci.com/wp-content/uploads/2019/01/img_5c3e8c585f432.png" alt="" width="600" height="470" srcset="https://archive.htrucci.com/wp-content/uploads/2019/01/img_5c3e8c585f432.png 980w, https://archive.htrucci.com/wp-content/uploads/2019/01/img_5c3e8c585f432-300x235.png 300w, https://archive.htrucci.com/wp-content/uploads/2019/01/img_5c3e8c585f432-768x602.png 768w" sizes="(max-width: 600px) 100vw, 600px" /></p>
<p class="p4">$ brew install kubectl</p>
<p class="p4">docker-for-desktop <span class="s2">컨텍스트로</span> <span class="s2">전환한다</span>.</p>
<p class="p4">$ kubectl config get-contexts</p>
<p class="p4">$ kubectl config use-context docker-for-desktop</p>
<p class="p1">도커<span class="s1"> hub</span>에서 이미지 땡겨오기</p>
<p class="p4">$ docker image pull ${name}</p>
<p class="p4">$ docker image pull alpine</p>
<p class="p1"><span class="s1">ls -l</span>을 실행시키면서 도커<span class="s1"> alpine </span>컨테이너를 실행시켜라<span class="s1">~(</span>컨테이너 안에서 명령어 실행한거임<span class="s1">)</span></p>
<p class="p4">$ docker container run alpine ls -l</p>
<p class="p4">$ docker container run alpine echo “hello from alpine”</p>
<p class="p1">컨테이너안에서 좀 인터렉티브하게 실행할때 아래 명령어로 응용하면 ㅇㅋ</p>
<p class="p4">$ docker container run -it alpine /bin/sh</p>
<p class="p1">도커허브 계정 로그인하기</p>
<p class="p4">$ docker login</p>
<p class="p1">도커 태그붙이기</p>
<p class="p4">docker tag <span class="s2">이미지</span> <span class="s2">사용자이름</span>/<span class="s2">저장소</span>:<span class="s2">태그명</span></p>
<p class="p4">$ docker tag hello-world htrucci/hello-world:get-started</p>
<p class="p1">푸시 떄려버림 도커허브에 태그가 지정된 이미지 업로드 된다<span class="s1">.</span></p>
<p class="p4">$ docker push htrucci/hello-world:get-started</p>
<p class="p1">이제부터 원격에서 저장소 땡겨서 이미지 실행가능</p>
<p class="p4">$ docker run -p 4000:80 htrucci/hello-world:get-started</p>
<p class="p4">Dockerfile<span class="s2">로</span> <span class="s2">앱</span> <span class="s2">만들어보자</span>. https://docs.docker.com/get-started/part2/#apppy</p>
<p class="p1">아무 폴더나 생성해서 아래파일 세개 생성</p>
<p class="p4">Dockerfile app.py requirements.txt</p>
<p class="p1">아래 빌드 명령어를 돌리고 나면</p>
<p class="p4">$ docker build &#8211;tag=friendlyhello .</p>
<p class="p4">friendlyhello<span class="Apple-converted-space">  </span><span class="s2">이미지가</span> <span class="s2">생성된걸</span> <span class="s2">볼</span> <span class="s2">수</span> <span class="s2">있다</span>.</p>
<p class="p4">$ docker image ls</p>
<p class="p1">돌려보기</p>
<p class="p4">$ docker run -p 4000:80 friendlyhello</p>
<p class="p1">그런데 백그라운드 모드로 돌려줄 필요 있음<span class="s1">.</span></p>
<p class="p4">$ docker run -d -p 4000:80 friendlyhello</p>
<p class="p2"><a href="http://localhost:4000/">http://localhost:4000/</a> <span class="s4">접속해보면</span> <span class="s4">페이지</span> <span class="s4">확인</span> <span class="s4">가능</span></p>
<p class="p4">$ docker tag friendlyhello htrucci/get-started:part2</p>
<p class="p1">확인했으면 다시 죽이자</p>
<p class="p4">$ docker container stop gracious_liskov</p>
<p class="p1">일단 저장소 올릴거임</p>
<p class="p4">$ docker push htrucci/get-started:part2</p>
<p class="p4">docker-compose.yml <span class="s2">파일을</span> <span class="s2">만들거임</span>.</p>
<p class="p4">version: &#8220;3&#8221;</p>
<p class="p4">services:</p>
<p class="p4"><span class="Apple-converted-space">  </span>web:</p>
<p class="p4"><span class="Apple-converted-space">    </span># replace username/repo:tag with your name and image details</p>
<p class="p4"><span class="Apple-converted-space">    </span>image: htrucci/get-started:part2</p>
<p class="p4"><span class="Apple-converted-space">    </span>deploy:</p>
<p class="p4"><span class="Apple-converted-space">      </span>replicas: 5</p>
<p class="p4"><span class="Apple-converted-space">      </span>resources:</p>
<p class="p4"><span class="Apple-converted-space">        </span>limits:</p>
<p class="p4"><span class="Apple-converted-space">          </span>cpus: &#8220;0.1&#8221;</p>
<p class="p4"><span class="Apple-converted-space">          </span>memory: 50M</p>
<p class="p4"><span class="Apple-converted-space">      </span>restart_policy:</p>
<p class="p4"><span class="Apple-converted-space">        </span>condition: on-failure</p>
<p class="p4"><span class="Apple-converted-space">    </span>ports:</p>
<p class="p4"><span class="Apple-converted-space">      </span>&#8211; &#8220;4000:80&#8221;</p>
<p class="p4"><span class="Apple-converted-space">    </span>networks:</p>
<p class="p4"><span class="Apple-converted-space">      </span>&#8211; webnet</p>
<p class="p4">networks:</p>
<p class="p4"><span class="Apple-converted-space">  </span>webnet:</p>
<p class="p1">인스턴스<span class="s1"> 5</span>개를 호출하여 각 이미지가<span class="s1"> CPU</span>의 최대<span class="s1"> 10% </span>및<span class="s1"> RAM 50M</span>로 제한된 서비스 실행</p>
<p class="p1">서비스가 죽으면 즉시 다시시작할 것이며<span class="s1"> 4000</span>포트를<span class="s1"> 80</span>포트에 맵핑할거임</p>
<p class="p1"><span class="s1">webnet</span>으로 로드밸런싱을 사용하도록</p>
<p class="p1">로드밸런싱 실행하기 전</p>
<p class="p4">$ docker swarm init</p>
<p class="p4"><span class="s2">실행해보기</span>. getstartedlab<span class="s2">으로</span> <span class="s2">이름을</span> <span class="s2">지정해줬음</span></p>
<p class="p4">$ docker stack deploy -c docker-compose.yml getstartedlab</p>
<p class="p4">web:Pending <span class="s2">쫌</span> <span class="s2">오래걸리네</span>…</p>
<p class="p4">Htrucci-MBP-2018:Docker Htrucci$ docker stack deploy -c docker-compose.yml getstartedlab</p>
<p class="p4">top-level network &#8220;webnet&#8221; is ignored</p>
<p class="p4">service &#8220;web&#8221;: network &#8220;webnet&#8221; is ignored</p>
<p class="p4">Waiting for the stack to be stable and running&#8230;</p>
<p class="p4">web: Pending [pod status: 0/18 ready, 18/18 pending, 0/18 failed]</p>
<p class="p1">아래 명령어 치면 서비스<span class="s1">ID</span>를 얻을 수 있다는데 안나오는데<span class="s1">?</span></p>
<p class="p4">$ docker service ls</p>
<p class="p1">도커<span class="s1">&#8211;</span>쿠버네티스 설정에서 두번째<span class="s1"> Default</span>옵션 풀어서 해결했음<span class="s1">.</span></p>
<p class="p1"><span class="s1">5</span>개의 서비스 단일 컨테이너<span class="s1">(</span>태스크<span class="s1">) </span>확인해보기</p>
<p class="p4">$ docker service ps getstartedlab_web</p>
<p class="p1"><span class="s5"><a href="http://localhost:4000">http://localhost:4000</a></span> 접속해보면 로드밸런싱 되어 각 컨테이너<span class="s1">ID</span>가 라운드 로빈 방식으로 로드밸런싱 됨을 확인할 수 있다<span class="s1">.</span></p>
<p class="p1">이제 앱 죽이자</p>
<p class="p4">$ docker stack rm getstartedlab</p>
<p class="p4">swarm<span class="s2">도</span> leave<span class="s2">하자</span></p>
<p class="p4">$ docker swarm leave &#8211;force</p>
<p class="p1">스웜 클러스터로 묶이면 노드라고 불리운다<span class="s1">.</span></p>
<p class="p1"><span class="s1">[</span>스웜 클러스터 만들기<span class="s1">]</span></p>
<p class="p1">우선 버츄얼박스를 설치하시죠</p>
<p class="p2"><a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></p>
<p class="p4">vm 2<span class="s2">개</span> <span class="s2">생성</span></p>
<p class="p4">$ docker-machine create &#8211;driver virtualbox myvm1</p>
<p class="p4">$ docker-machine create &#8211;driver virtualbox myvm2</p>
<p class="p1"><span class="s1">VM </span>실행중인 리스트 한번 보자</p>
<p class="p4">$ docker-machine ls</p>
<p class="p4"><span class="s2">웜에</span> <span class="s2">가입시키기</span> <span class="s2">위해</span> Swarm init<span class="s2">하기</span></p>
<p class="p4">$ docker-machine ssh myvm1 &#8220;docker swarm init &#8211;advertise-addr &lt;myvm1 ip&gt;&#8221;</p>
<p class="p1">실행하면<span class="s1"> swarm</span>에<span class="s1"> join</span>하는 명령어를 만들어서 보여준다<span class="s1">. </span></p>
<p class="p4">$ docker-machine ssh myvm2 “<span class="s2">도커가</span> <span class="s2">만들어준</span> <span class="s2">명렁어</span>“</p>
<p class="p1">스웜의 노드 확인해보기</p>
<p class="p4">$ docker-machine ssh myvm1 &#8220;docker node ls&#8221;</p>
<p class="p1"><span class="s1">myvm1</span>의 환경 확인해보기</p>
<p class="p4">$ docker-machine env myvm1</p>
<p class="p4">myvm1<span class="s2">을</span> <span class="s2">명령</span> active <span class="s2">상태로</span> <span class="s2">만든다</span></p>
<p class="p4">$ eval $(docker-machine env myvm1)</p>
<p class="p4">Active<span class="s2">에</span> <span class="s2">별표있는지</span> <span class="s2">확인</span></p>
<p class="p4">$ docker-machine ls</p>
<p class="p4">myvm1<span class="s2">에</span> <span class="s2">앱배포</span></p>
<p class="p4">$ docker stack deploy -c docker-compose.yml getstartedlab</p>
<p class="p1">잘 올라갔는지 확인</p>
<p class="p4">$ docker stack ps getstartedlab</p>
<p class="p1"><span class="s1">vm</span>리스트에서 확인한<span class="s1"> ip</span>로 접속하면 위에서 띄운 앱이 들어가지겠지만<span class="s1">, </span>네트워크 포트 오픈 문제인지 들어가지지 않는다<span class="s1">.</span></p>
<p class="p4">$ docker-machine ls</p>
<p class="p1">어떻게하는진 알았으니 스웜에서 다시 떼어내자</p>
<p class="p4">$ docker stack rm getstartedlab</p>
<p class="p4">machine active<span class="s2">처리한것도</span> <span class="s2">다시</span> <span class="s2">해제하자</span></p>
<p class="p4">$ eval $(docker-machine env -u)</p>
<p class="p1">머신 시작시키는 명령어</p>
<p class="p4">$ docker-machine start &lt;machine-name&gt;</p>
<p class="p1">새 서비스를 추가시켜보기 위해</p>
<p class="p2"><span class="s3">yml </span><span class="s4">수정</span><span class="s3"> <a href="https://docs.docker.com/get-started/part5/#recap-optional">https://docs.docker.com/get-started/part5/#recap-optional</a> </span></p>
<p class="p1">머신 다시 러닝 및 활성화 시키고</p>
<p class="p4">$ eval $(docker-machine env myvm1)</p>
<p class="p1">다시 앱 배포</p>
<p class="p4">$ docker stack deploy -c docker-compose.yml getstartedlab</p>
<p class="p1">서비스 떠있는거 확인하고</p>
<p class="p4">$ docker service ls</p>
<p class="p4"><span class="s2">머신</span>ip:80/8080 <span class="s2">포트로</span> <span class="s2">들어가봤는데</span> <span class="s2">안떠</span></p>
<p class="p1">좋아 그럼 다시 해본다<span class="s1">.</span></p>
<p class="p2"><a href="https://stackoverflow.com/questions/53451285/connection-refused-on-docker-tutorial-get-started-part-4">https://stackoverflow.com/questions/53451285/connection-refused-on-docker-tutorial-get-started-part-4</a></p>
<p class="p1">아래 링크의<span class="s1"> iso</span>이미지를 받는다</p>
<p class="p2"><a href="https://github.com/boot2docker/boot2docker/releases/tag/v18.06.1-ce">https://github.com/boot2docker/boot2docker/releases/tag/v18.06.1-ce</a></p>
<p class="p1">우선 스택오버플로에 있는 이미지로 머신을 다시 생성해줬음<span class="s1"> (</span>영향이 있는지는 모르겠으나<span class="s1">)</span></p>
<p class="p4">$ docker-machine rm myvm1</p>
<p class="p4">$ docker-machine rm myvm2</p>
<p class="p4">$ docker-machine create &#8211;driver virtualbox &#8211;virtualbox-boot2docker-url ./boot2docker.iso myvm1</p>
<p class="p4">$ docker-machine create &#8211;driver virtualbox &#8211;virtualbox-boot2docker-url ./boot2docker.iso myvm2</p>
<p class="p1">생성된거 확인하고</p>
<p class="p4">$ docker-machine ls</p>
<p class="p1">