<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coderifleman&#39;s blog</title>
  
  <subtitle>frontend development stories.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.coderifleman.com/"/>
  <updated>2018-03-18T10:56:09.000Z</updated>
  <id>http://blog.coderifleman.com/</id>
  
  <author>
    <name>Coderifleman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>플럭스 아키텍처에서 스토어란 무엇인가?</title>
    <link href="http://blog.coderifleman.com/2018/03/18/what-is-store-in-flux-architecture/"/>
    <id>http://blog.coderifleman.com/2018/03/18/what-is-store-in-flux-architecture/</id>
    <published>2018-03-17T15:00:00.000Z</published>
    <updated>2018-03-18T10:56:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>플럭스 아키텍처를 이용해 애플리케이션을 개발할 때 가장 먼저 스토어를 설계한다. 그 이유는 스토어가 무엇보다 중요한 데이터를 관리하는 객체라고 해석하기 때문이다.</p><p>스토어는 모델이나 엔티티 등의 데이터를 관리하기 위한 공간이 아니다. 그저 표현을 위한 상태를 관리하는 객체일 뿐이다. 예를 들어 데이터를 필터링하기 위한 기준값이 있다고 하자. 이 값이 스토어에 존재한다고 해서 실제 필터링에 사용되지 않는다. 스토어에 존재하는 이유는 이 값을 어딘가에 표현해야 하기 때문이다.</p><p>표현 계층은 표현을 위한 상태가 필요하다. 그리고 애플리케이션 비즈니스는 필연적으로 도메인 데이터가 필요하다. 만약 두 가지의 책임을 스토어가 갖게 된다면 애플리케이션 내에서 무엇보다 중요한 거대한 객체가 탄생하게 된다.</p>        <figure title="스토어의 의존 관계">          <img src="/assets/img/2018/what-is-store-in-flux-architecture/what-is-store-in-flux-architecture.01.png" alt="스토어의 의존 관계" style="">          <figcaption>&lt;그림 1. 스토어의 의존 관계&gt;</figcaption>        </figure>    <p>첫 번째 다이어그램을 보자. 스토어에서 표현을 위한 상태와 도메인 데이터를 모두 관리하고 있다. 이 경우 표현 계층과 애플리케이션 비즈니스 계층 모두 스토어를 의존한다. 애플리케이션 비즈니스는 도메인 데이터에 접근할 수 있어야 하므로 스토어에 겟터(Getter) 메서드도 작성해야 한다.</p><p>반면 두 번째 다이어그램에서는 데이터의 관리 책임을 분리했다. 자연스럽게 의존 관계는 좌측에서 우측으로 이뤄진다. 스토어에서 겟터를 제공할 필요도 없다. 데이터를 관리하는 계층에서 적절한 수단을 제공하면 된다. 스토어는 상대적으로 단순하고 각 계층을 테스트하기도 쉽다.</p>        <figure title="플럭스 아키텍처 의존 관계">          <img src="/assets/img/2018/what-is-store-in-flux-architecture/what-is-store-in-flux-architecture.02.png" alt="플럭스 아키텍처 의존 관계" style="max-width:360px">          <figcaption>&lt;그림 2. 플럭스 아키텍처 의존 관계&gt;</figcaption>        </figure>    <p>필자는 스토어를 표현 계층의 한 요소로 해석한다. 스토어에서 도메인 데이터를 분리해야만 <a href="/2017/12/18/the-clean-architecture/">클린 아키텍처</a>에서 말하는 의존 규칙을 지킬 수 있다.</p><p>플럭스 아키텍처를 이용해 애플리케이션을 설계하더라도 모델 계층은 언제나 필요하다. 즉, 애플리케이션을 개발할 때 가장 먼저 시작해야 할 지점은 스토어가 아니라 바로 모델이다.</p>]]></content>
    
    <summary type="html">
    
      플럭스 아키텍처에서 스토어의 역할을 소개한다.
    
    </summary>
    
      <category term="Flux" scheme="http://blog.coderifleman.com/categories/Flux/"/>
    
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
      <category term="React" scheme="http://blog.coderifleman.com/tags/React/"/>
    
      <category term="Architecture" scheme="http://blog.coderifleman.com/tags/Architecture/"/>
    
      <category term="Flux" scheme="http://blog.coderifleman.com/tags/Flux/"/>
    
  </entry>
  
  <entry>
    <title>백엔드 개발자와 협업하는 두 가지 방법</title>
    <link href="http://blog.coderifleman.com/2018/03/03/two-ways-to-collaborate-with-backend-developer/"/>
    <id>http://blog.coderifleman.com/2018/03/03/two-ways-to-collaborate-with-backend-developer/</id>
    <published>2018-03-02T15:00:00.000Z</published>
    <updated>2018-03-03T14:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>보통 애플리케이션 개발은 외부 자원에 접근할 수 있는 API가 필요하다. 그리고 대개, API를 개발하는 백엔드 개발자와 애플리케이션 인터페이스를 개발하는 프런트엔드 개발자로 나눠 협업한다. 이때 두 직군 간 협업 과정에서 병목이 발생하기 쉽다.</p><p>프런트엔드 개발자는 동작하는 API를 기다리고 백엔드 개발자는 프런트엔드 요구에 맞춰 API, 또는 비즈니스 로직까지 변경해야 하는 일이 생긴다. 그러다 보니 교착 상태에 빠지거나 시간이 흐를수록 커뮤니케이션이 힘들어지기도 한다.</p><p>만약 당신이 이러한 문제를 겪고 있다면 지금부터 소개하는 두 가지 방법이 도움이 될 수 있다.</p><h2 id="API-인터페이스-협의"><a href="#API-인터페이스-협의" class="headerlink" title="API 인터페이스 협의"></a>API 인터페이스 협의</h2><p>가장 이상적인 방법은 API 인터페이스를 협의하는 과정을 갖는 것이다. 필요한 API는 요구사항 분석 과정에서 알 수 있다. 예를 들어 복수의 피드를 선택해 구독하는 기능을 떠올려보자. 자연스럽게 복수 피드에 대해 구독 요청을 할 수 있는 API가 필요함을 알 수 있다.</p><p>이어서 백엔드 개발자와 함께 구독 요청 API 인터페이스를 협의한다. API 인터페이스란 어떤 메서드와 URL로 요청 해야 하고 응답 형식은 무엇인가에 대한 약속이다. 이를 신뢰하고 각자 개발을 진행한다. 동작하는 API를 기다리지 않아도 된다.</p><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>에 익숙하다면 <a href="https://expressjs.com/" target="_blank" rel="noopener">Express</a>를 이용해 목서버를 만들 수 있다. 만약 테스트를 작성한다면 <a href="http://sinonjs.org/" target="_blank" rel="noopener">Sinon.JS</a>의 <a href="http://sinonjs.org/releases/v4.4.2/fake-xhr-and-server/" target="_blank" rel="noopener">Fake XHR</a>을 이용한다.</p><pre><code class="language-javascript">test('collect()', async () =&gt; {  // Given  server.respondWith('POST', /\/api\/feeds\/collect/, xhr =&gt; {    if (JSON.parse(xhr.requestBody).productIds !== '1,2,3') {      return false;    }    xhr.respond(200, {'Content-Type': 'application/json'}, JSON.stringify({collectId: 'ab8d7ee'}));  });  // When  const collectId = await feeds.collect([1, 2, 3]);  // Then  expect(collectId).to.equal('ab8d7ee');});</code></pre><p>또는, 목서버 없이 개발 환경에서만 <a href="http://sinonjs.org/releases/v4.4.2/fake-xhr-and-server/" target="_blank" rel="noopener">Fake XHR</a>을 애플리케이션 문맥에 불러올 수도 있다.</p><h2 id="팩토리를-이용한-개발"><a href="#팩토리를-이용한-개발" class="headerlink" title="팩토리를 이용한 개발"></a>팩토리를 이용한 개발</h2><p>어떠한 API가 필요하고 또, 구현 가능한지 불확실할 때는 협의 미팅이 도움 되지만, 구현할 기능이 단순하고 필요한 API에 관해 대략적인 정보를 공유하고 있다면 오히려 비용일 수 있다. 그렇지만 API 응답 형태를 모르는 상태에서 예측으로 코드를 작성하면 통합 단계에서 애플리케이션 전체의 코드 변경이 필요할 수 있다.</p><p>친구 목록을 가져와 출력해주는 기능을 상상해보자. 이 요구사항에서 모델을 디자인할 수 있다.</p><pre><code class="language-typescript">class FriendEntity {  public readonly id: number;  public readonly name: string;  public readonly tel: string;  constructor(data: Friend) {    this.id = data.id;    this.name = data.name;    this.tel = data.tel;  }}</code></pre><p>이 모델을 의존해 기능을 개발한다. API의 응답은 몰라도 된다. 이후 동작하는 API를 전달받았는데 응답 형태가 앞서 작성한 모델과 다르다고 가정해보자.</p><pre><code class="language-typescript">interface FriendPayload {  userNo: number;  name: string;  phoneNumber: string;}</code></pre><p>만약 모델을 바꾸면 애플리케이션에 영향이 생긴다. 그리고 외부 데이터가 모델의 변경을 유발한다는 것도 논리적이지 않다. 이때, 우리는 팩토리 객체를 이용할 수 있다.</p><pre><code class="language-typescript">class FriendFactory {  public static create(data: FriendPayload) {    return new FriendEntity({      id: data.userNo,      name: data.name,      tel: data.phoneNumber    });  }}me.friends().then((data: FriendPayload[]) =&gt; {  const friends = data.map(d =&gt; FriendFactory.create(d));  friendListView.render(friends);});</code></pre><p><code>friendListView</code>는 <code>FriendEntity</code>에 의존한다. API의 응답 형태로 인해 <code>friendListView</code>가 영향받지 않는다. 이처럼 모델에서 시작하고, 모델을 의존하면 API 없이 개발을 시작할 수 있다. API를 전달받으면 팩토리 객체를 이용해 변경을 최소화하고 통합하면 된다.</p><p>여기까지 백엔드 개발자와 협업하는 두 가지 방법을 간단히 소개했다. 어떠한 API가 필요하고 또, 구현 가능한지 불확실하다면 API 인터페이스 협의 과정을 갖길 바란다. 하지만 기능이 단순하고 필요한 API도 어느 정도 공유된 상황에서 협의 미팅은 피곤할 수 있다. 그땐 팩토리 객체를 이용하자. 애플리케이션의 변경을 최소화해 개발할 수 있다.</p>]]></content>
    
    <summary type="html">
    
      이 문서는 백엔드 개발자와 협업하는 두 가지 방법을 정리한 문서로 API 협의 과정 또는 그러한 과정없이 애플리케이션을 개발하는 방법을 소개한다.
    
    </summary>
    
      <category term="Development" scheme="http://blog.coderifleman.com/categories/Development/"/>
    
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
      <category term="Development" scheme="http://blog.coderifleman.com/tags/Development/"/>
    
      <category term="Sinon.js" scheme="http://blog.coderifleman.com/tags/Sinon-js/"/>
    
      <category term="TypeScript" scheme="http://blog.coderifleman.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>The Clean Architecture</title>
    <link href="http://blog.coderifleman.com/2017/12/18/the-clean-architecture/"/>
    <id>http://blog.coderifleman.com/2017/12/18/the-clean-architecture/</id>
    <published>2017-12-17T15:00:00.000Z</published>
    <updated>2017-12-20T02:14:54.000Z</updated>
    
    <content type="html"><![CDATA[        <div class="alert alert--info">            <div class="alert__inner">                                    <div class="alert__title">                        <strong>읽기전에...</strong>                    </div>                                <div class="alert__body">                    <p>이 문서는 일본어 「<a href="https://blog.tai2.net/the_clean_architecture.html" target="_blank" rel="noopener">クリーンアーキテクチャ(The Clean Architecture翻訳)</a>」을 중역한 글입니다. 원글은 「<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">The Clean Architecture</a>」로 번역 시 참고했습니다. 오역 감수는 프런트엔드 개발자 <a href="https://github.com/DuYongLee" target="_blank" rel="noopener">이두용</a>님께서 수고해주셨습니다.</p>                </div>            </div>        </div>    <p><a href="https://twitter.com/unclebobmartin" target="_blank" rel="noopener">로버트 C. 마틴(Robert Martin, a.k.a 엉클 아저씨)</a>이 공개한 「<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">The Clean Architecture</a>」를 번역한 글입니다. 관점이 비슷한 「<a href="https://blog.tai2.net/hexagonal_architexture.html" target="_blank" rel="noopener">Hexagonal Architecture</a>(일본어)」도 번역했으니 참고해주세요.</p><p>해당 글을 번역하겠다고 「<a href="https://8thlight.com/" target="_blank" rel="noopener">8th Light, inc</a>」에 이야기했으며 현재까지는 별다른 제재가 없었습니다.</p>        <figure title="The Clean Architecture의 다이어그램">          <img src="/assets/img/2017/the-clean-architecture/the-clean-architecture.jpg" alt="The Clean Architecture의 다이어그램" style="">          <figcaption>&lt;그림. The Clean Architecture의 다이어그램&gt;</figcaption>        </figure>    <p>지난 몇 년 동안 우리는 시스템 아키텍처에 대한 실로 다양한 아이디어를 봐왔다. 예를들어 다음과 같은 것이 포함된다.</p><ul><li>알리스테어 코번(Alistair Cockburn)의 <a href="http://alistair.cockburn.us/Hexagonal+architecture" target="_blank" rel="noopener">헥사고날 아키텍처(Hexagonal Architecture, a.k.a Ports and Adapters)</a>. 스티브 프리먼(Steve Freeman)과 냇 프라이스(Nat Pryce)의 훌륭한 책 <a href="http://www.yes24.com/24/goods/9008455?scode=032&amp;OzSrank=1" target="_blank" rel="noopener">테스트 주도 개발로 배우는 객체 지향 설계와 실천(Growing Object-Oriented Software)</a>에서 차용.</li><li>제프리 팔레모르(Jeffrey Palermo)의 <a href="http://jeffreypalermo.com/blog/the-onion-architecture-part-1/" target="_blank" rel="noopener">어니언 아키텍쳐(Onion Architecture)</a></li><li>작년, 블로그에 포스팅한 <a href="https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html" target="_blank" rel="noopener">스크리밍 아키텍쳐(Screaming Architecture)</a></li><li>트리그베 린스카그(Trygve Reenskaug)와 제임스 코플리엔(James Coplien)의 <a href="https://www.amazon.com/Lean-Architecture-Agile-Software-Development/dp/0470684208/" target="_blank" rel="noopener">DCI</a></li><li>이바르 제이콥슨(Ivar Jacobson)의 <a href="https://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350" target="_blank" rel="noopener">BCE</a>, 그의 저서 Object Oriented Software Engineering: A Use-Case Driven Approach에서.</li></ul><p>위 아키텍처의 세세한 부분은 모두 다르지만 매우 비슷하기도 하다. 이들은 모두 같은 목적을 갖고 있는데 바로 관심사의 분리다. 소프트웨어를 계층으로 나눔으로써 관심사를 분리한다. 그리고 모두 비즈니스 규칙을 위한 최소 하나 이상의 계층과 인터페이스를 위한 또 다른 계층을 두고 있다.</p><p>위 아키텍처 모두는 다음과 같은 시스템을 생성한다.</p><ol><li>프레임워크 독립적, 이들 아키텍처는 소프트웨어 라이브러리 존재 여부에 의존하지 않는다. 이는 시스템을 프레임워크의 한정된 제약에 억지로 집어넣는 대신 도구로써 사용하는 것을 가능하게 한다.</li><li>테스트 용이함, 비즈니스 규칙은 UI, 데이터베이스, 웹 서버, 기타 외부 요인없이 테스트 가능하다.</li><li>UI 독립적, 시스템의 나머지 부분을 변경할 필요 없이 UI를 쉽게 변경할 수 있다. 예를들면 웹 UI는 비즈니스 규칙 변경 없이 콘솔 UI와 치환된다.</li><li>데이터베이스 독립적, 오라클 또는 SQL Server를 몽고, 빅테이블, 카우치 DB 등으로 바꿀 수 있다. 비즈니스 규칙은 데이터베이스에 얽매이지 않는다.</li><li>외부 기능 독립적, 실제로 비즈니스 규칙은 외부 세계에 대해 아무것도 모른다.</li></ol><p>이 문서의 말머리에 소개한 그림은 이러한 아키텍처를 단일 개념으로 통합하고자 하는 시도다.</p><h2 id="의존-규칙"><a href="#의존-규칙" class="headerlink" title="의존 규칙"></a>의존 규칙</h2><p>이들 동심원은 소프트웨어의 각기 다른 영역을 나타내고 있다. 대개, 바깥쪽으로 향할수록 고수준의 소프트웨어가 된다. 바깥쪽의 원은 메커니즘(Mechanism)이고 안쪽의 원은 정책(Policy)이다.</p><p>이 아키텍처를 기능하게 하는 중요한 규칙이 바로 의존 규칙이다. 이 규칙에 의해서 소스 코드는 안쪽을 향해서만 의존할 수 있다. 안쪽의 원은 바깥쪽의 원에 대해 전혀 알지 못한다. 특히, 바깥쪽의 원에서 선언된 어떠한 이름을 안쪽 원에서 참조해서는 안된다. 이는 함수, 클래스, 변수 등 이름이 붙은 소프트웨어의 엔티티 모든 것에 해당한다.</p><p>마찬가지로 바깥쪽의 원에서 사용하고 있는 데이터 포맷을 안쪽의 원에서 사용하지 않아야 한다. 특히 그러한 포맷이 바깥쪽 원에서 프레임워크에 의해 생성되고 있다면 바깥쪽 원의 어떠한 것도 안쪽의 원에 영향을 줘선 안된다.</p><h2 id="엔티티"><a href="#엔티티" class="headerlink" title="엔티티"></a>엔티티</h2><p>엔티티는 대규모 프로젝트 레벨의 비즈니스 규칙을 캡슐화 한다. 엔티티는 메서드를 갖는 객체 일 수도 있지만 데이터 구조와 함수의 집합일 수도 있다. 엔티티가 대규모 프로젝트 내의 다양한 애플리케이션에서 사용된다고 하더라도 문제될 것은 없다.</p><p>대규모 프로젝트가 아닌 단지 하나의 애플리케이션을 작성할 뿐이라면 엔티티는 그 애플리케이션의 비즈니스 객체가 된다. 엔티티는 가장 일반적이면서 고수준의 규칙을 캡슐화한다. 그리고 바깥쪽에서 무엇이 변경되더라도 바뀌지 않는다. 예를들어 엔티티 객체는 페이지 내비게이션의 변경이나 보안 사항으로 부터 영향을 받지 않을 것을 기대할 수 있다. 애플리케이션의 동작에 관한 변경이 엔티티 계층에 영향을 주어선 안된다.</p><h2 id="유스케이스"><a href="#유스케이스" class="headerlink" title="유스케이스"></a>유스케이스</h2><p>이 계층의 소프트웨어는 애플리케이션 고유 비즈니스 규칙을 포함하며 시스템의 모든 유스케이스를 캡슐화하고 구현한다. 이들 유스케이스는 엔티티로 부터의 혹은 엔티티에서의 데이터 흐름을 조합한다. 그리고 엔티티 즉, 프로젝트 레벨의 비즈니스 규칙을 사용해 유스케이스의 목적을 달성하도록 지휘한다.</p><p>이 계층의 변경이 엔티티에 영향을 주지 않을 것을 기대하며 데이터베이스, UI 또는 공통의 프레임워크의 변경으로부터 영향 받지 않을 것도 기대한다. 이 계층은 그러한 관심에서 격리된다.</p><p>하지만, 애플리케이션의 조작에 대한 변경은 유스케이스에 영향이 있고 따라서 이 계층의 소프트웨어에 영향이 있을 것을 기대한다. 유스케이스의 상세가 바뀐다면 이 계층의 코드는 확실히 영향을 받는다.</p><h2 id="인터페이스-어댑터"><a href="#인터페이스-어댑터" class="headerlink" title="인터페이스 어댑터"></a>인터페이스 어댑터</h2><p>이 계층의 소프트웨어는 어댑터의 집합이다. 이는 유스케이스와 엔티티에 있어 용이한 형식으로부터 데이터베이스나 웹 등 외부의 기능에 용이한 형식으로 데이터를 변환한다. 예를들어 이 레이어는 GUI의 MVC 아키텍처를 완전히 내포한다. 프리젠터, 뷰, 컨트롤러는 모두 여기에 속한다. 모델은 컨트롤러에서 유스케이스로 전달되고 이어 유스케이스에서 프리젠터나 뷰로 되돌아가는 그저 단순한 데이터 구조일 가능성이 높다.</p><p>마찬가지로 이 계층에서 데이터는, 엔티티나 유스케이스에 용이한 형에서, 사용하고 있는 프레임워크에  용이한 형으로 변환된다. 예를들어 데이터베이스를 들 수 있다. 이 계층에 해당하는 원보다 안쪽에 존재하는 코드는 데이터베이스에 관해 아는 것이 없어야 한다. 만약 데이터베이스가 SQL 데이터베이스라면 어떤 SQL이든 이 계층에 제한돼야 하며 특히, 이 계층 내의 데이터베이스와 관련 있는 부분에 제한돼야 된다.</p><p>또, 이 계층에는 외부의 어떠한(외부 서비스) 형식에서 유스케이스와 엔티티에서 사용될 수 있는 내부 형식으로 데이터를 변환하기 위해 필요한 기타 모든 어댑터도 둘 수 있다.</p><h2 id="프레임워크와-드라이버"><a href="#프레임워크와-드라이버" class="headerlink" title="프레임워크와 드라이버"></a>프레임워크와 드라이버</h2><p>가장 바깥쪽의 계층은 데이터베이스나 웹 프레임워크 등 일반적으로 프레임워크나 도구로 구성된다. 대개, 이 계층에는 안쪽의 원과 통신할 연결 코드 이외에는 별다른 코드를 작성하지 않는다.</p><p>이 계층에는 상세한 정보가 무엇이든 여기에 둔다. 웹은 상세하다. 그리고 데이터베이스도 상세하다. 이러한 것으로 인해 악영향을 주지 않도록 밖에 유지한다.</p><h2 id="4개의-원이-아니면-안되는가"><a href="#4개의-원이-아니면-안되는가" class="headerlink" title="4개의 원이 아니면 안되는가"></a>4개의 원이 아니면 안되는가</h2><p>아니다. 이 원은 컨셉을 전하기 위한 수단이다. 이 4가지 이외에도 무엇인가 필요할 가능성이 있다. 정확히 4가지가 아니면 안된다는 규칙은 없다. 하지만 의존 규칙은 항상 적용된다. 소스 코드의 의존성은 항상 안쪽으로 향해야 한다. 안쪽으로 향해감에 따라 추상화 수준은 올라간다. 가장 바깥쪽의 원은 저수준의 구체적인 상세 정보를 담는다. 안쪽으로 이동해가면서 소프트웨어는 추상화 되고 고수준의 정책을 캡슐화한다. 가장 안쪽에 있는 원은 무엇보다 일반성이 있다.</p><h2 id="교차경계"><a href="#교차경계" class="headerlink" title="교차경계"></a>교차경계</h2><p>위 다이어그램의 오른쪽 아래의 그림은 어떤식으로 원의 경계가 교차하는지 보여주는 예다. 이것은 컨트롤러와 프리젠터가 다음 계층인 유스케이스와 어떻게 대화하는지 보여준다. 제어의 흐름에 주의하길 바란다. 컨트롤러에서 시작해 유스케이스를 거쳐 프리젠터에서 실행됨을 알 수 있다. 소스 코드의 의존성에도 주의한다. 모두 안쪽의 유스케이스를 향하고 있다.</p><p>우리는 이 분명한 모순을 <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener">의존 관계 역전의 원칙(Dependency Inversion Principle)</a>으로 해결하는 경우가 많다. 예를들어 Java와 같은 언어에서는 인터페이스와 상속 관계를 조합해 소스 코드의 의존성이 경계를 걸치고 있는 오른쪽 지점에서 제어 흐름이 반대하도록 한다.</p><p>다시 예를들어 유스케이스가 프리젠터를 호출할 필요가 있는 경우를 생각해보자. 하지만 이때의 호출은 직접 이뤄질 수 없다. 왜냐하면 <strong>“의존성 규칙 : 바깥쪽의 이름을 안쪽에서 언급할 수 없다”</strong>를 위반하기 때문이다. 때문에 유스케이스에는 안쪽 원에 있는 인터페이스(Use Case Output Port라고 적혀있는)를 호출한다. 그리고 원 바깥쪽의 프리젠터는 이 인터페이스를 구현한다.</p><p>이와 똑같은 테크닉이 아키텍처의 경계가 교차되는 곳에서 사용된다. 동적인 다형성의 이점을 이용해 소스 코드의 의존성이 제어 흐름의 반대가 되도록 한다. 이렇게 하면 제어의 흐름이 어떤 방향으로 진행되든지 상관없이 의존성 규칙을 지킬 수 있다.</p><h2 id="어떤-데이터가-경계를-교차하는가"><a href="#어떤-데이터가-경계를-교차하는가" class="headerlink" title="어떤 데이터가 경계를 교차하는가"></a>어떤 데이터가 경계를 교차하는가</h2><p>대개, 경계를 넘나드는 데이터는 단순한 구조의 데이터다. 기본적인 구조체나 단순한 데이터 전송 객체(Data Transter Object)를 취향에 맞게 사용할 수 있다. 혹은 데이터는 단순히 함수의 인수라 해도 좋다. 또는, 그것을 해시맵으로 해도 좋고 객체로 구성해도 좋다. 중요한 것은 격리된 단순한 구조의 데이터가 경계를 넘어간다는 점이다. 우리는 꾀를 부려 엔티티나 데이터베이스의 행을 전달하지 않는다. 데이터 구조가 의존성 규칙을 위반하는 모든 종류의 원인을 갖지 않길 바란다.</p><p>예를 들어 여러 데이터베이스 프레임워크는 쿼리에 응답하여 편리한 데이터 포맷을 반환한다. 이것을 행 구조(RowStructure)라고 부르자. 이 행 구조를, 경계를 넘어 안쪽으로 전달하지 않기를 원한다. 이는 의존성 규칙을 위반한다. 왜냐하면 바깥쪽 원에 관한 무언가를 안쪽의 원이 알도록 강제하기 때문이다.</p><p>때문에 경계를 넘어 데이터를 전달할 때엔 항상 안쪽의 원이 다루기 쉬운 데이터 형식이어야 한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이런 간단한 규칙을 따르는 것은 어렵지 않다. 그리고 머리가 아프지 않도록 도와 줄 것이다. 소프트웨어를 계층으로 나누고 의존성 규칙을 따름으로써 본질적으로 테스트하기 쉬운 시스템을 만들 수 있고 의존성 규칙이 가져오는 이점도 얻을 수 있다. 시스템의 외부 부품(데이터베이스나 웹 프레임워크 등)이 낡았다면 그러한 부분도 최소한의 노력으로 바꿀 수 있다.</p>]]></content>
    
    <summary type="html">
    
      이 문서는 로버트 C. 마틴의 The Clean Architecture를 한국어로 번역한 문서입니다. 그의 좋은 의도와 생각이 널리 전파되길 바랍니다
    
    </summary>
    
      <category term="Architecture" scheme="http://blog.coderifleman.com/categories/Architecture/"/>
    
    
      <category term="Architecture" scheme="http://blog.coderifleman.com/tags/Architecture/"/>
    
      <category term="MVC" scheme="http://blog.coderifleman.com/tags/MVC/"/>
    
  </entry>
  
  <entry>
    <title>Tabnabbing 공격과 rel=noopener 속성</title>
    <link href="http://blog.coderifleman.com/2017/05/30/tabnabbing_attack_and_noopener/"/>
    <id>http://blog.coderifleman.com/2017/05/30/tabnabbing_attack_and_noopener/</id>
    <published>2017-05-29T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Tabnabbing"><a href="#Tabnabbing" class="headerlink" title="Tabnabbing"></a>Tabnabbing</h2><p>Tabnabbing이란 HTML 문서 내에서 링크(target이 _blank인 Anchor 태그)를 클릭 했을 때 새롭게 열린 탭(또는 페이지)에서 기존의 문서의 location을 피싱 사이트로 변경해 정보를 탈취하는 공격 기술을 뜻한다. 이 공격은 메일이나 오픈 커뮤니티에서 쉽게 사용될 수 있다.</p>        <figure title="Tabnabbing 공격 흐름">          <img src="/assets/img/2017/tabnabbing_attack_and_noopener/tab-nabbing.01.svg" alt="Tabnabbing 공격 흐름" style="max-width:420px">          <figcaption>&lt;그림 1. Tabnabbing 공격 흐름(<a href="https://blog.jxck.io/entries/2016-06-12/noopener.html" target="_blank" rel="noopener">출처</a>)&gt;</figcaption>        </figure>    <p>공격 절차는 다음과 같다.</p><ol><li>사용자가 <code>cgm.example.com</code>에 접속한다.</li><li>해당 사이트에서 <code>happy.example.com</code>으로 갈 수 있는 외부 링크를 클릭한다.</li><li>새탭으로 <code>happy.example.com</code>가 열린다.<ul><li><code>happy.example.com</code>에는 <code>window.opener</code> 속성이 존재한다.</li><li>자바스크립트를 사용해 opener의 location을 피싱 목적의 <code>cgn.example.com/login</code> 으로 변경한다.</li></ul></li><li>사용자는 다시 본래의 탭으로 돌아온다.</li><li>로그인이 풀렸다고 생각하고 아이디와 비밀번호를 입력한다.<ul><li><code>cgn.example.com</code>은 사용자가 입력한 계정 정보를 탈취한 후 다시 본래의 사이트로 리다이렉트한다.</li></ul></li></ol><h2 id="NAVER-메일과-Gmail"><a href="#NAVER-메일과-Gmail" class="headerlink" title="NAVER 메일과 Gmail"></a>NAVER 메일과 Gmail</h2><p>시나리오를 하나 그려보자. 공격자가 네이버 계정을 탈취할 목적으로 여러분에게 바겐세일 정보를 담은 메일을 보냈다. 그 메일에는 [자세히 보기]라는 외부 링크가 포함돼 있다.</p><p>물론 이 바겐세일 정보는 가짜지만 공격자에겐 중요하지 않다. 메일을 읽는 사람이 유혹에 빠져 링크를 클릭하면 그만이다.</p>        <figure title="NAVER 메일을 이용한 Tabnabbing 데모">          <img src="/assets/img/2017/tabnabbing_attack_and_noopener/tab-nabbing.02.gif" alt="NAVER 메일을 이용한 Tabnabbing 데모" style="max-width:420px">          <figcaption>&lt;그림 2. NAVER 메일을 이용한 Tabnabbing 데모&gt;</figcaption>        </figure>    <p>국내에서 가장 유명한 포털 회사인 NAVER가 이러한 공격에 다소 미흡한 점은 못내 아쉽다. NAVER 뿐만 아니라 DAUM도 마찬가지이며 아마 카페 서비스도 동일하게 재현할 수 있지 않을까 생각한다.</p><p>하지만 Gmail은 이 공격이 통하지 않는다. Gmail은 이러한 공격을 막기 위해 Anchor 태그에 data-saferedirecturl 속성을 부여해 안전하게 리다이렉트 한다. Twitter도 동일한 방법으로 대응하고 있다.</p>        <figure title="Gmail의 소스 코드">          <img src="/assets/img/2017/tabnabbing_attack_and_noopener/tab-nabbing.03.png" alt="Gmail의 소스 코드" style="max-width:420px">          <figcaption>&lt;그림 3. Gmail의 소스 코드&gt;</figcaption>        </figure>    <h2 id="rel-noopener-속성"><a href="#rel-noopener-속성" class="headerlink" title="rel=noopener 속성"></a>rel=noopener 속성</h2><p>이러한 공격의 취약점을 극복하고자 noopener 속성이 추가 됐다.</p><p>rel=noopener 속성이 부여된 링크를 통해 열린 페이지는 location 변경과 같은 자바스크립트 요청을 거부한다. 정확히 말해서 <code>Uncaught TypeError</code> 에러를 발생시킨다(크롬 기준).</p>        <figure title="새탭의 콘솔 결과">          <img src="/assets/img/2017/tabnabbing_attack_and_noopener/tab-nabbing.04.png" alt="새탭의 콘솔 결과" style="max-width:420px">          <figcaption>&lt;그림 4. 새탭의 콘솔 결과&gt;</figcaption>        </figure>    <p>이 속성은 <a href="https://labs.jxck.io/noopener/" target="_blank" rel="noopener">Window Opener Demo</a> 페이지를 통해 테스트해볼 수 있다.</p><p>크롬은 버전 49, 파이어폭스 52부터 지원한다. 파이어폭스 52가 2017년 3월에 릴리즈 된 것을 감안하면 이 속성 만으로 안심하긴 힘들 것 같다. 자세한 지원 여부는 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types" target="_blank" rel="noopener">Link types</a>를 참고한다.</p><p>따라서 이러한 공격이 우려스러운 서비스(메일, 커뮤니티, 댓글 시스템 등)라면 <a href="https://danielstjules.github.io/blankshield/" target="_blank" rel="noopener">blankshield</a>와 같은 라이브러리를 사용하자.</p><p>noopener 속성은 보안적 측면 외에도 성능 상의 이점도 취할 수 있다.</p><p>_blank 속성으로 열린 탭(페이지)는 언제든지 opener를 참조할 수 있다. 그래서 부모 탭과 같은 스레드에서 페이지가 동작한다. 이때 새탭의 페이지가 리소스를 많이 사용한다면 덩달아 부모 탭도 함께 느려진다.</p><p>noopener 속성을 사용해 열린 탭은 부모를 호출할 일이 없다. 따라서 같은 스레드 일 필요 없으며 새로운 페이지가 느리다고 부모 탭까지 느려질 일도 없다.</p>        <div class="alert alert--info">            <div class="alert__inner">                                <div class="alert__body">                    <p>rel=&quot;noopener&quot; prevents window.opener, so there&#39;s no cross-window access. Chromium browsers optimise for this and open the new page in its own process.</p>                </div>            </div>        </div>    <p>자세한 내용은 <a href="https://jakearchibald.com/2016/performance-benefits-of-rel-noopener/" target="_blank" rel="noopener">The performance benefits of rel=noopener</a>을 참고하자.</p><h2 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h2><ul><li><a href="http://www.azarask.in/blog/post/a-new-type-of-phishing-attack/" target="_blank" rel="noopener">Tabnabbing: A New Type of Phishing Attack</a></li><li><a href="https://www.jitbit.com/alexblog/256-targetblank---the-most-underestimated-vulnerability-ever/" target="_blank" rel="noopener">Target=”_blank” - the most underestimated vulnerability ever</a></li><li><a href="https://blog.jxck.io/entries/2016-06-12/noopener.html" target="_blank" rel="noopener">링크에 rel=noopener를 부여해 Tabnabbing을 대비</a>(일본어)</li><li><a href="https://jakearchibald.com/2016/performance-benefits-of-rel-noopener/" target="_blank" rel="noopener">The performance benefits of rel=noopener</a></li></ul>]]></content>
    
    <summary type="html">
    
      이 문서는 Tabnabbing 공격과 이를 막을 수 있는 rel=noopener 속성에 대해 소개합니다.
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
      <category term="Attack" scheme="http://blog.coderifleman.com/tags/Attack/"/>
    
      <category term="Security" scheme="http://blog.coderifleman.com/tags/Security/"/>
    
      <category term="Hacking" scheme="http://blog.coderifleman.com/tags/Hacking/"/>
    
  </entry>
  
  <entry>
    <title>프런트엔드 엔지니어를 위한 베지에 곡선(Bézier Curves) - 3편</title>
    <link href="http://blog.coderifleman.com/2017/03/19/bezier-curves-for-frontend-engineer-3/"/>
    <id>http://blog.coderifleman.com/2017/03/19/bezier-curves-for-frontend-engineer-3/</id>
    <published>2017-03-18T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>「<a href="/2017/01/03/bezier-curves-for-frontend-engineer-2/">프런트엔드 엔지니어를 위한 베지에 곡선(Bézier Curves) - 2편</a>」을 포스팅한 후 시간이 꽤 지났다. 어디까지 이야기했더라? 기억도 가물가물하다. 최근에 강의를 시작하면서 여유가 없었다는 핑계를 대보지만, 뭐가 됐든 게을러서 그렇다. 3편을 기다리신 분이 있었다면 죄송할 따름이다.</p><p>글과 관련 없는 얘기는 이쯤 하자. 2편에서는 <a href="/2017/01/03/bezier-curves-for-frontend-engineer-2/#에버리징과-블렌딩">에버리징과 블렌딩</a> 그리고 인터폴레이션(Interpolation)이라고 부르는 <a href="/2017/01/03/bezier-curves-for-frontend-engineer-2/#보간">보간</a>을 소개했다. 베지에 곡선을 이해하기 위한 기초 지식이었으며 이 개념만 이해하고 있으면 나머지는 쉽게 이해할 수 있다.</p><h2 id="1차-베지에-곡선"><a href="#1차-베지에-곡선" class="headerlink" title="1차 베지에 곡선"></a>1차 베지에 곡선</h2><p>우리는 이미 1차 베지에 곡선(Linear Bezier Cuvers)을 경험했다. 2편의 <a href="/2017/01/03/bezier-curves-for-frontend-engineer-2/#복합-데이터-블렌딩">복합 데이터 블렌딩</a>과 <a href="/2017/01/03/bezier-curves-for-frontend-engineer-2/#보간">보간</a> 절에서 보여준 예제가 바로 1차 베지에 곡선이다. 차이점이 있다면 단순히 평면상에서 곡선을 그리는 게 아니라 <a href="https://ko.wikipedia.org/wiki/%EC%A7%81%EA%B5%90_%EC%A2%8C%ED%91%9C%EA%B3%84" target="_blank" rel="noopener">직교좌표계</a> 상에서 그린다는 것이다.</p>        <figure title="1차 베지에 곡선">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.01.png" alt="1차 베지에 곡선" style="max-width:340px">          <figcaption>&lt;그림 1. 1차 베지에 곡선&gt;</figcaption>        </figure>    <p>1차 베지에 곡선은 조절점(Control point) 두 개로 그린다. 아주 간단하지만, 굴곡이 없는 <a href="https://ko.wikipedia.org/wiki/%EC%84%A0%ED%98%95%EC%84%B1" target="_blank" rel="noopener">선형</a>이다(직선도 곡선에 포함된다는 사실을 잊지 말자). </p><h2 id="2차-베지에-곡선"><a href="#2차-베지에-곡선" class="headerlink" title="2차 베지에 곡선"></a>2차 베지에 곡선</h2><p>그럼 2차 베지에 곡선(Quadratic Bézier Curves)을 그려보자. 2차 베지에 곡선은 조절점 3개를 이용해 그린 곡선을 말한다.</p>        <figure title="2차 베지에 곡선">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.02.png" alt="2차 베지에 곡선" style="max-width:340px">          <figcaption>&lt;그림 2. 2차 베지에 곡선&gt;</figcaption>        </figure>    <p>3개의 조절점 A, B, C를 이용해 그린 두 개의 직선 즉, 두 개의 1차 베지에 곡선이 있다. 그리고 이 곡선에서 보간되는 점 E와 F도 있다. 이때 점 E와 F를 이용해 또 다른 직선을 그릴 수 있고 이 직선에서 보간되는 점 P도 추가할 수 있다. 이제 점 E와 F 그리고 P를 보간하면 P의 행적이 곡선을 만들어 낸다(이해가 되지 않는다면 「<a href="/2016/12/30/bezier-curves/">중학생도 알 수 있는 베지에 곡선</a>」을 참고한다).</p><p>그럼 이제 2차 베지에 곡선을 직접 그려보도록 하자. 선분에서 블렌딩 되는 점 P를 구하는 공식은 다음과 같다(자세한 내용은 「<a href="/2017/01/03/bezier-curves-for-frontend-engineer-2/">프런트엔드 엔지니어를 위한 베지에 곡선(Bézier Curves) - 2편</a>」을 참고). 이때 <code>s = 1 - t</code>다.</p><pre><code class="language-text">P = (s * A) + (t * B)</code></pre><p>그림 2를 보면 알 수 있듯이 2차 베지에 곡선을 그리기 위해서는 점 E와 F 그리고 P를 보간해야 한다. 점 E는 조절점 A와 B를 이용해 구할 수 있고, 점 F는 조절점 B와 C를 이용해 구할 수 있다. 그리고 점 P는 다시 점 E와 F를 이용해 구할 수 있다.</p><pre><code class="language-text">E = (s * A) + (t * B)F = (s * B) + (t * C)P = (s * E) + (t * F)</code></pre><p>이 공식을 자바스크립트 코드로 옮겨보자. 여기에서는 구현에 있어 몇 가지 중요한 함수만 소개한다. 전체 코드는 코드펜(CodePen)에 작성해 놓은 <a href="http://codepen.io/uyeong/pen/qrpYwj" target="_blank" rel="noopener">예제</a>를 참고한다.</p><p>먼저 blender()는 점 A와 점 B 그리고 가중치 t를 전달받아 블랜딩한 결괏값을 반환하는 함수다.</p><pre><code class="language-js">function blender(A, B, t) {  if (t === 0) {    return A;  }  if (t === 1) {    return B;  }  return ((1 - t) * A) + (t * B); // or A + t * (B - A)}</code></pre><p>이때 blender()는 좌표 하나에 대한 연산만 책임지므로 x, y 좌표를 연산하기 위해 blend()를 작성한다.</p><pre><code class="language-js">function blend(x1, x2, y1, y2, t) {  const x = blender(x1, x2, t);  const y = blender(y1, y2, t);  return {x, y};}</code></pre><p>다음으로 blend()를 이용해 점 A와 점 B의 좌표를 전달해 점 E의 좌푯값을 구하고 점 B와 점 C의 좌표를 전달해 점 F의 좌표를 구한다. 그리고 다시 점 E와 점 F의 좌표를 전달해 점 P의 좌표를 구하는 방식으로 공식을 구현한다.</p><pre><code class="language-js">interpolateBtn.addEventListener('click', function() {  // Start the interpolation.  raf(function(t) {    const posE = blend(posA.x, posB.x, posA.y, posB.y, t);    const posF = blend(posB.x, posC.x, posB.y, posC.y, t);    const posP = blend(posE.x, posF.x, posE.y, posF.y, t);    ...  }, 1000);});</code></pre><p>아래 데모를 실행해 보자. 점 P가 보간되면서 그려진 곡선을 2차 베지에 곡선이라고 한다.</p>        <p data-height="300" data-theme-id="0" data-slug-hash="qrpYwj" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="qrpYwj" class="codepen">            See the Pen <a href="http://codepen.io/uyeong/pen/qrpYwj/" target="_blank" rel="noopener">qrpYwj</a> by Uyeong Ju (<a href="http://codepen.io/uyeong" target="_blank" rel="noopener">@uyeong</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.        </p>    <h3 id="수식-정리"><a href="#수식-정리" class="headerlink" title="수식 정리"></a>수식 정리</h3><p>우리가 2차 베지에 곡선을 위해 사용한 수식은 다음과 같다.</p><pre><code class="language-text">E = (s * A) + (t * B)F = (s * B) + (t * C)P = (s * E) + (t * F)</code></pre><p>하지만 이 수식은 조금 장황하며 자바스크립트 코드상에서도 함수 호출이 빈번한 상태다. 이 수식을 방정식으로  좀더 간결하고 효율적으로 표현할 수 있다. 일단 연산식에 있는 괄호를 없애고 좀더 간략하게 수식을 표현한다.</p><pre><code class="language-text">E(t) = sA + tBF(t) = sB + tCP(t) = sE(t) + tF(t)</code></pre><p>이번엔 중학생 때 배워본 몇 가지 <a href="https://ko.wikipedia.org/wiki/%EA%B3%B1%EC%85%88_%EA%B3%B5%EC%8B%9D" target="_blank" rel="noopener">곱셈 공식</a> 사용하여 세 줄로 표현한 수식을 한 줄로 작성하고 이차방정식으로 정리한다.</p><pre><code class="language-text">P(t) = s(sA + tB) + t(sB + tC)P(t) = (s²)A + (st)B + (st)B + (t²)CP(t) = (s²)A + 2(st)B + (t²)C</code></pre><p>자, 몇 가지 규칙을 더 추가하자. t가 0이라면 P는 항상 A와 같으며 다음과 같이 증명할 수 있다.</p><pre><code class="language-text">P(t) = (s²)A + 2(st)B + (t²)CP(t) = (1²)A + 2(1 * 0)B + (0²)CP(t) = (1)A + 2(0)B + (0)CP(t) = (1)AP(t) = A</code></pre><p>다시 t가 1이라면 P는 항상 C와 같으며 다음과 같이 증명할 수 있다.</p><pre><code class="language-text">P(t) = (s²)A + 2(st)B + (t²)CP(t) = (0²)A + 2(0 * 1)B + (1²)CP(t) = (0)A + 2(0)B + (1)CP(t) = (1)CP(t) = C</code></pre><p>이제 정리한 수식을 자바스크립트로 작성해보자. 함수명은 <code>quadBezier</code>로 짓고 2차 베지에 곡선임을 나타낸다.</p><pre><code class="language-js">function quadBezier(A, B, C, t) {  if (t === 0) {    return A;  }    if (t === 1) {    return C;  }    const s = 1 - t;    // (s²)A + 2(st)B + (t²)C  return Math.pow(s, 2) * A + 2 * (s * t) * B + Math.pow(t, 2) * C;}</code></pre><p>이렇게 작성한 함수는 다음과 같이 사용할 수 있다.</p><pre><code class="language-js">interpolateBtn.addEventListener('click', function() {  // Start the interpolation.  raf(function(t) {    const x = quadBezier(posA.x, posB.x, posC.x, t);    const y = quadBezier(posA.y, posB.y, posC.y, t);    ...  }, 1000);});</code></pre><h2 id="3차-베지에-곡선"><a href="#3차-베지에-곡선" class="headerlink" title="3차 베지에 곡선"></a>3차 베지에 곡선</h2><p>이제 3차 베지에 곡선(Cubic Bézier Curves)을 그려보자. 2차 베지에 곡선은 3개의 조절점을 이용해 그린 곡선을 말하듯 3차 베지에 곡선은 4개의 조절점을 이용해 그린 곡선을 말한다. 더 정확히는 두 개의 2차 베지에 곡선을 이용해 그린 곡선을 말한다.</p>        <figure title="3차 베지에 곡선">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.03.png" alt="3차 베지에 곡선" style="max-width:340px">          <figcaption>&lt;그림 3. 3차 베지에 곡선&gt;</figcaption>        </figure>    <p>조절점 A, B, C를 이용해 그린 2차 베지에 곡선과 조절점 B, C, D를 이용해 그린 2차 베지에 곡선이 있다. 그리고 각 2차 베지에 곡선에서 보간되는 점 Q와 R이 있다. 이때 점 Q와 R를 이용해 또 다른 직선을 그릴 수 있고 이 직선에서 보간되는 점 P도 추가할 수 있다. 이제 점 Q와 R 그리고 P를 보간하면 P의 행적이 곡선을 만들어 낸다.</p><p>이제 3차 베지에 곡선을 직접 그려보자. 3차 베지에 곡선을 그리기 위해서는 보간되는 점 Q와 R 그리고 P를 구해야 한다. 점 Q는 다음과 같이 구할 수 있다.</p><pre><code class="language-text">E = (s * A) + (t * B)F = (s * B) + (t * C)Q = (s * E) + (t * F)</code></pre><p>다시 점 R은 다음과 같이 구할 수 있다.</p><pre><code class="language-text">F = (s * B) + (t * C)G = (s * C) + (t * D)R = (s * F) + (t * G)</code></pre><p>이제 점 Q와 R을 이용해 점 P를 구할 수 있다.</p><pre><code class="language-text">P = (s * Q) + (t * R)</code></pre><p>이제 2차 베지에 곡선을 그릴 때 작성한 blend, blender 함수를 활용해 3차 베지에 곡선을 그려보자. 간단하게 새로운 점을 추가한 후 위에서 설명한 것처럼 점 Q, R, P를 구해 보간하면 된다.</p><p>아래 데모를 실행해 보자. 점 P가 보간되면서 그려진 곡선을 3차 베지에 곡선이라고 한다.</p>        <p data-height="300" data-theme-id="0" data-slug-hash="EmOPJr" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="EmOPJr" class="codepen">            See the Pen <a href="http://codepen.io/uyeong/pen/EmOPJr/" target="_blank" rel="noopener">EmOPJr</a> by Uyeong Ju (<a href="http://codepen.io/uyeong" target="_blank" rel="noopener">@uyeong</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.        </p>    <h3 id="수식정리"><a href="#수식정리" class="headerlink" title="수식정리"></a>수식정리</h3><p>점 Q와 P는 각각 2차 베지에 곡선에서 구해지는 점이므로 2차 베지에 곡선의 수식으로 표현할 수 있다.</p><pre><code class="language-text">Q(t) = (s²)A + 2(st)B + (t²)CR(t) = (s²)B + 2(st)C + (t²)DP(t) = sQ(t) + tR(t)</code></pre><p>위 수식을 조금 더 풀어서 다음과 같이 정리할 수 있다.</p><pre><code class="language-text">P(t) = s((s²)A + 2(st)B + (t²)C) + t((s²)B + 2(st)C + (t²)D)P(t) = s³A + 2(s²t)B + st²C + s²tB + 2(st²)C + t³DP(t) = s³A + 3(s²t)B + 3(st²)C + t³D</code></pre><p>이제 정리한 수식을 자바스크립트로 작성해보자. 함수명은 <code>cubicBezier</code>로 짓고 3차 베지에 곡선임을 나타낸다.</p><pre><code class="language-js">function cubicBezier(A, B, C, D, t) {  if (t === 0) {    return A;  }    if( t === 1) {    return D;  }    const s = 1 - t;    // P = s³A + 3(s²t)B + 3(st²)C + t³D    return (    Math.pow(s, 3) * A +     3 * (Math.pow(s, 2) * t) * B +     3 * (s * Math.pow(t, 2)) * C +     Math.pow(t, 3) * D  );}</code></pre><p>이렇게 작성한 함수는 다음과 같이 사용할 수 있다.</p><pre><code class="language-js">interpolateBtn.addEventListener('click', function() {  // Start the interpolation.  raf(function(t) {    const x = cubicBezier(posA.x, posB.x, posC.x, posD.x, t);    const y = cubicBezier(posA.y, posB.y, posC.y, posD.y, t);    ...  }, 1000);});</code></pre><h3 id="애니메이션"><a href="#애니메이션" class="headerlink" title="애니메이션"></a>애니메이션</h3><p>실제 동작하는 데모에서 <code>requestAnimationFrame()</code>을 사용해 일정한 시간마다 점을 찍는 것으로 3차 베지에 곡선을 그리고 있다. 그런데 곡선의 각 점이 찍히는 구간 즉, 보폭이 일정하지 않다.</p>        <figure title="3차 베지에 곡선의 보폭">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.04.png" alt="3차 베지에 곡선의 보폭" style="max-width:340px">          <figcaption>&lt;그림 4. 3차 베지에 곡선의 보폭&gt;</figcaption>        </figure>    <p>이러한 특징을 애니메이션 처리에 활용할 수 있다. 보폭이 크면 시간이 빠르게 흐르고 보폭이 작으면 시간이 천천히 흐르도록 표현하여 객체의 움직임에 역동성을 부여할 수 있다.</p>        <figure title="Easing Functions 치트시트">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-3/bezier-for-frontend.05.png" alt="Easing Functions 치트시트" style="max-width:340px">          <figcaption>&lt;그림 5. Easing Functions 치트시트&gt;</figcaption>        </figure>    <p>이제 CSS의 <code>transition-timing-function</code>의 <code>cubic-bezier(Bx, By, Cx, Cy)</code>가 의미하는 바가 무엇인지 또 어떻게 객체의 움직임에 활력을 불어넣을 수 있게 되는지도 이해할 수 있을 것이다.</p><h2 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로"></a>끝으로</h2><p>여기까지 베지에 곡선에 대한 연재 글을 모두 마친다. 처음엔 필자 역시 단순 호기심으로 시작했지만, 점점 원리를 알아가는 과정에서 상당한 재미를 느꼈다. 연재 글을 읽는 독자분들 역시 재미있는 경험이었길 바란다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="http://fei.edu.br/~psergio/CG_arquivos/IntroSplines.pdf" target="_blank" rel="noopener">An Introduction to Bezier Curves, B-Splines, and Tensor<br>Product Surfaces with History and Applications</a></li><li><a href="http://www.essentialmath.com/GDC2012/GDC12_Eiserloh_Squirrel_Interpolation-and-Splines.ppt" target="_blank" rel="noopener">GDC12 Eiserloh Squirrel Interpolation and Splines</a></li><li><a href="https://www.tsplines.com/resources/class_notes/Bezier_curves.pdf" target="_blank" rel="noopener">BEZIER CURVES</a></li></ul>]]></content>
    
    <summary type="html">
    
      이 문서는 프런트개발에 있어서 유용하게 사용되는 베지에 곡선(Bézier Curves)의 원리를 수학적으로 자세히 소개하는 글의 세 번째 편입니다.
    
    </summary>
    
      <category term="Algorithm" scheme="http://blog.coderifleman.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://blog.coderifleman.com/tags/Algorithm/"/>
    
      <category term="BezierCurves" scheme="http://blog.coderifleman.com/tags/BezierCurves/"/>
    
      <category term="Spline" scheme="http://blog.coderifleman.com/tags/Spline/"/>
    
      <category term="Animation" scheme="http://blog.coderifleman.com/tags/Animation/"/>
    
      <category term="Math" scheme="http://blog.coderifleman.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>프런트엔드 엔지니어를 위한 베지에 곡선(Bézier Curves) - 2편</title>
    <link href="http://blog.coderifleman.com/2017/01/03/bezier-curves-for-frontend-engineer-2/"/>
    <id>http://blog.coderifleman.com/2017/01/03/bezier-curves-for-frontend-engineer-2/</id>
    <published>2017-01-02T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>베지에 곡선과 관련된 수학적 증명 방법과 알고리즘은 1959년 프랑스의 자동차 업체 <a href="http://www.citroen.com/en" target="_blank" rel="noopener">시트로엥(citroen)</a>에서 근무하던 물리학자이자 수학자인 <a href="https://en.wikipedia.org/wiki/Paul_de_Casteljau" target="_blank" rel="noopener">파울 드 카스텔조(Paul de Casteljau)</a>가 최초 고안했다. 다른 말로 카스텔조 곡선(Casteljau curve)이라고 부른다.</p><p>하지만 시트로엥의 정책으로 인해 카스텔조가 얻은 성과가 1974년까지 발표되지 못했고 1962년에 프랑스 자동차 회사 르노(<a href="https://group.renault.com/" target="_blank" rel="noopener">Renault</a>)에서 근무하던 엔지니어 피에르 베지에(<a href="https://en.wikipedia.org/wiki/Pierre_B%C3%A9zier" target="_blank" rel="noopener">Pierre Bézier</a>)가 자동차를 디자인하는 과정에서 이 곡선을 독자적으로 개발해 사용하면서 그의 이름으로 널리 알려지게 된다.</p><h2 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h2><p>베지에 곡선은 간단히 말해 복수의 조절점(<a href="https://en.wikipedia.org/wiki/Control_point_&#40;mathematics&#41;" target="_blank" rel="noopener">Control point</a>)을 이용해 매끄러운 곡선을 그릴 수 있는 가장 일반적인 매개 변수 곡선(<a href="https://en.wikipedia.org/wiki/Parametric_equation" target="_blank" rel="noopener">Parametric curve</a>) 이다. 매개 변수 곡선이란 매개 변수를 사용해 함수를 일반화하여 곡선을 그려내는 방법을 말한다.</p>        <figure title="베지에 곡선의 조절점과 가이드 포인트">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.01.png" alt="베지에 곡선의 조절점과 가이드 포인트" style="max-width:340px">          <figcaption>&lt;그림 1. 베지에 곡선의 조절점과 가이드 포인트&gt;</figcaption>        </figure>    <p>조절점이란 곡선의 모양을 결정하는 데 사용되는 점의 집합 또는 구성원을 뜻하며 가이드 포인트는 곡선의 모양을 변경시킬 수 있는 조절 가능한 점을 뜻한다. 그림 1의 점을 왼쪽부터 차례대로 P0, P1, P2, P3라고 할 때 보통 P0와 P3는 고정해두고 P1과 P2를 조절해 곡선을 변형한다. 이때 이 P1과 P2를 가이드 포인트라 한다.</p><p>베지에 곡선엔 차수가 붙는데 이 차수는 조절점의 개수에 따라 정해진다. 간단히 말해 N 개의 조절점으로 그려진 곡선을 N - 1차 베지에 곡선이라 한다. 예를 들어 그림 1은 조절점이 4개이므로 4 - 1 즉, 3차 베지에 곡선이다.</p><p>베지에 곡선이 그려지는 개괄적인 원리는 이전에 포스팅했던 「<a href="http://blog.coderifleman.com/2016/12/30/bezier-curves/">중학생도 알 수 있는 베지에 곡선(Bézier Curves)</a>」을 참고하자. GIF 애니메이션을 이용해 이해하기 쉽게 설명돼 있다.</p><p>이번 편에서는 블렌딩(Blending)과 보간(Interpolcation)을 소개한다. 이 지식만 습득하면 나머지 n 차 베지에 곡선은 자연스럽게 이해할 수 있다.</p><h2 id="에버리징과-블렌딩"><a href="#에버리징과-블렌딩" class="headerlink" title="에버리징과 블렌딩"></a>에버리징과 블렌딩</h2>        <figure title="점 A와 점 B의 중앙">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.02.png" alt="점 A와 점 B의 중앙" style="">          <figcaption>&lt;그림 2. 점 A와 점 B의 중앙&gt;</figcaption>        </figure>    <p>자, 위 그림 2와 같이 서로 떨어져 있는 점 A와 점 B가 있다고 해보자. 이때 점 P를 이 두 점 사이의 평균 즉,  <a href="http://dic.daum.net/word/view.do?wordid=kkw000140374&amp;supid=kku000175471" target="_blank" rel="noopener">선분</a>의 중앙에 두고 싶다면 어떻게 해야 할까?</p><pre><code class="language-text">P = (A + B) / 2</code></pre><p>위처럼 간단히 평균을 구해 중앙에 둘 수 있다. 이 수식을 조금 다르게 전개해보자.</p><pre><code class="language-text">P = (A + B) / 2  = (A + B) * ½  = ½A + ½B  = .5A + .5B  = (.5 * A) + (.5 * B)</code></pre><p>위 수식을 이용한 연산을 블렌딩(Blending)이라고 표현한다. 지정된 각각의 비율에 맞춰 적절히 혼합하는 것이다. 자, 이제 같은 값이 아닌 가중치(Weights)를 줘서 블렌딩해보자.</p>        <figure title="점 A와 점 B의 블렌딩 비율 조절">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.03.png" alt="점 A와 점 B의 블렌딩 비율 조절" style="">          <figcaption>&lt;그림 3. 점 A와 점 B의 블렌딩 비율 조절&gt;</figcaption>        </figure>    <pre><code class="language-text">P = (.35 * A) + (.65 * B)</code></pre><p>이번엔 A는 0.35(35%), B는 0.65(65%)로 비율을 조정해 블렌딩했다. 이때 두 비율의 합은 당연하겠지만 1(100%)이 돼야 한다. 이것은 반드시 지켜져야 할 필수 조건이다. 이어서 비율 값을 다음과 같이 일반화해보자.</p><pre><code class="language-text">P = (s * A) + (t * B)</code></pre><p>s는 A의 비율을, t는 B의 비율을 나타낸다. 만약 s가 높으면 t는 낮아지고 반대로 t가 높으면 s는 낮아질 것이다. 잠깐, s와 t는 서로 영향을 주며 두 수의 합은 항상 1이 돼야 한다. 그렇다면 s는 <code>1 - t</code>와 같다고 할 수 있다.</p><pre><code class="language-text">P = ((1-t) * A) + (t * B)</code></pre><p>이제 변수 t 하나만으로 비율을 조정해 블렌딩할 수 있다. 이 수식은 다음과 같이 표현될 수 있다.</p><pre><code class="language-text">P = ((1 - t) * A) + (t * B)  = (1 - t) * A + t * B  = A - tA + tB  = A + t(-A + B)  = A + t(B - A)</code></pre><p>이 글에서는 수식 <code>P = (s * A) + (t * B)</code>를 사용해 설명을 이어가겠다. 다시 한번 말하지만 <code>s = 1 - t</code>다. 여기에 몇 가지 규칙이 추가된다. 만약 변수 t가 0이라면 P는 항상 A와 같으므로 다음과 같이 표현될 수 있다.</p><pre><code class="language-text">P = ((1 - t) * A) + (t * B)  = ((1 - 0) * A) + (0 * B)  = (1 * A) + (0 * B)  = A</code></pre><p>또 변수 t가 1이라면 P는 항상 B와 같으므로 다음과 같이 표현될 수 있다.</p><pre><code class="language-text">P = ((1 - t) * A) + (t * B)  = ((1 - 1) * A) + (1 * B)  = (0 * A) + (1 * B)  = A + B - A  = B</code></pre><p>이제 수식과 몇 가지 규칙을 참고하여 블렌딩하는 자바스크립트 함수를 작성해보자.</p><pre><code class="language-js">const A = 20;const B = 198;function blender(A, B, t) {    if (t === 0) {        return A;    }    if (t === 1) {        return B;    }    return ((1 - t) * A) + (t * B); // or A + t * (B - A)}const blend = blender.bind(null, A, B);console.log(blend(.0)); // 20console.log(blend(.2)); // 55.6console.log(blend(.4)); // 91.2console.log(blend(.6)); // 126.8console.log(blend(.8)); // 162.4console.log(blend(1));  // 198</code></pre>        <p data-height="300" data-theme-id="0" data-slug-hash="qRBdvb" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="qRBdvb" class="codepen">            See the Pen <a href="http://codepen.io/uyeong/pen/qRBdvb/" target="_blank" rel="noopener">qRBdvb</a> by Uyeong Ju (<a href="http://codepen.io/uyeong" target="_blank" rel="noopener">@uyeong</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.        </p>    <h2 id="복합-데이터-블렌딩"><a href="#복합-데이터-블렌딩" class="headerlink" title="복합 데이터 블렌딩"></a>복합 데이터 블렌딩</h2><p>이번에는 「에버리징과 블렌딩」 절에서 이해한 수식을 이용해 복합 데이터(Compound data)를 블렌딩해보자. 블렌딩 수식만 잘 활용하면 2차원 또는 3차원 같은 복합적인 데이터도 쉽게 블렌딩할 수 있다.</p><pre><code class="language-text">Px = (s * Ax) + (t * Bx)Py = (s * Ay) + (t * By)Pz = (s * Az) + (t * Bz)</code></pre><p>3차원인 경우 위처럼 개별적으로 블렌딩한 후 연산된 값을 조합해 사용한다.</p>        <figure title="2차원에서 점 A와 점 B의 중앙">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.04.png" alt="2차원에서 점 A와 점 B의 중앙" style="">          <figcaption>&lt;그림 4. 2차원에서 점 A와 점 B의 중앙&gt;</figcaption>        </figure>    <p>전 절에서는 점 A와 점 B가 동일 선상에 놓여있는 1차원적 상황이었지만 이번엔 그림 4 처럼 2차원 상황에서 P를 구해보자. 2차원에서는 x와 y 좌표로 점의 위치가 결정된다. 따라서 x와 y를 개별적으로 블렌딩한 후 구해진 값을 조합하면 P의 위치를 구할 수 있다.</p>        <figure title="2차원에서 점 P의 위치 구하기">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-2/bezier-for-frontend.05.png" alt="2차원에서 점 P의 위치 구하기" style="">          <figcaption>&lt;그림 5. 2차원에서 점 P의 위치 구하기&gt;</figcaption>        </figure>    <pre><code class="language-text">Px = (s * Ax) + (t * Bx)Py = (s * Ay) + (t * By)P = {Px, Py}</code></pre><p>위 수식은 자바스크립트 코드로 다음과 같이 표현할 수 있다.</p><pre><code class="language-js">const Ax = 20;const Ay = 144;const Bx = 198;const By = 72;const blendX = blender.bind(null, Ax, Bx);const blendY = blender.bind(null, Ay, By);// t = .5// P = { blendX(t), blendY(t) }</code></pre>        <p data-height="300" data-theme-id="0" data-slug-hash="EZxVVV" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="EZxVVV" class="codepen">            See the Pen <a href="http://codepen.io/uyeong/pen/EZxVVV/" target="_blank" rel="noopener">EZxVVV</a> by Uyeong Ju (<a href="http://codepen.io/uyeong" target="_blank" rel="noopener">@uyeong</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.        </p>    <h2 id="보간"><a href="#보간" class="headerlink" title="보간"></a>보간</h2><p>마지막으로 보간(Interpolation)의 개념을 짤막하게 소개한다. 러핑(Lerping)이라고도 부르는 보간은 <strong>시간이 지남에 따라 블랜드 가중치를 변경하여 블렌딩을 수행하는 것</strong>을 말한다. 시간은 멈춰있지 않고 지속해서 흐르는 특징이 있으며 블랜드 가중치는 이 흐르는 시간에 의해 결정된다.</p><p>쉽게 말해 특정 값으로 블렌딩하는 게 아닌 지속해서 흐르는 시간에 근거해 블렌딩 하는 것이다. 이러한 과정은 대개 update()로 표현된다. 아래 자바스크립트 코드를 보자.</p><pre><code class="language-js">function interpolator(Ax, Bx, Ay, By, duration) {  return function(update) {   // x, y 블랜드 함수 준비    const blendX = blender.bind(null, Ax, Bx);    const blendY = blender.bind(null, Ay, By);        ... 중략 ...        function step(timestamp) {            ... 중략 ...            // 현재 시간에 해당하는 진행 값 즉, t 값 연산      const pastTime = timestamp - startTime;      let progress = pastTime / duration;   // t 값을 이용해 블렌딩하고 update 콜백 함수 호출      update(blendX(progress), blendY(progress)); // Blending...      ... 중략 ...            requestAnimationFrame(step);    }        requestAnimationFrame(step);  }}const interpolate = interpolator(Ax, Bx, Ay, By, 1000);interpolate(function(nx, ny) {// 1초간 Interpolating.// P = {nx, ny}});</code></pre><p>우선 requestAnimationFrame()를 사용해 지정한 시간 만큼 흐르게 한다. 그리고 현재 시각에 해당하는 진행 값 즉, t를 구한 후 이 값을 근거해 블렌딩한다.</p>        <p data-height="300" data-theme-id="0" data-slug-hash="dNbgQp" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="dNbgQp" class="codepen">            See the Pen <a href="http://codepen.io/uyeong/pen/dNbgQp/" target="_blank" rel="noopener">dNbgQp</a> by Uyeong Ju (<a href="http://codepen.io/uyeong" target="_blank" rel="noopener">@uyeong</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.        </p>    <p>보간은 페이드인, 아웃 같은 애니메이션 처리나 3D 게임에서의 객체 움직임 그리고 오디오 크로스페이드 처리 등에 유용하게 사용된다.</p><p>여기까지 2편을 마치고, 다음 편에서 이 지식을 바탕으로 1, 2차 베지에 곡선을 소개하겠다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://www.desmos.com/calculator/cahqdxeshd" target="_blank" rel="noopener">Interpolation and Splines</a></li><li><a href="https://www.w3.org/TR/2001/REC-smil-animation-20010904/" target="_blank" rel="noopener">SMIL Animation</a></li><li><a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank" rel="noopener">Bézier curve - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Paul_de_Casteljau" target="_blank" rel="noopener">Paul de Casteljau - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Pierre_B%C3%A9zier" target="_blank" rel="noopener">Pierre Bézier - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Control_point_&#40;mathematics&#41;" target="_blank" rel="noopener">Control point - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Parametric_equation" target="_blank" rel="noopener">Parametric curve - Wikipedia</a></li></ul>]]></content>
    
    <summary type="html">
    
      이 문서는 프런트개발에 있어서 유용하게 사용되는 베지에 곡선(Bézier Curves)의 원리를 수학적으로 자세히 소개하는 글의 두 번째 편입니다.
    
    </summary>
    
      <category term="Algorithm" scheme="http://blog.coderifleman.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://blog.coderifleman.com/tags/Algorithm/"/>
    
      <category term="BezierCurves" scheme="http://blog.coderifleman.com/tags/BezierCurves/"/>
    
      <category term="Spline" scheme="http://blog.coderifleman.com/tags/Spline/"/>
    
      <category term="Animation" scheme="http://blog.coderifleman.com/tags/Animation/"/>
    
      <category term="Math" scheme="http://blog.coderifleman.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>프런트엔드 엔지니어를 위한 베지에 곡선(Bézier Curves) - 1편</title>
    <link href="http://blog.coderifleman.com/2017/01/02/bezier-curves-for-frontend-engineer-1/"/>
    <id>http://blog.coderifleman.com/2017/01/02/bezier-curves-for-frontend-engineer-1/</id>
    <published>2017-01-01T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>퇴근 후 여느 때와 마찬가지로 PlayStation 4 전원에 손이 향하는 순간, 오랫동안 관리하지 못한 <a href="https://github.com/uyeong/react-preloader-icon" target="_blank" rel="noopener">react-preloader-icon</a> 컴포넌트가 돌연 떠올랐다. react-preloader-icon은 <a href="http://samherbert.net/svg-loaders/" target="_blank" rel="noopener">SVG Loaders</a>의 아이콘을 React 컴포넌트로 옮기고 있는 작은 사이즈의 프로젝트다.</p><p>SVG Loaders에 디자인된 아이콘은 12개밖에 안되지만 게으른 나머지 아직 2개밖에 옮기지 못했다. 그래서 게임은 잠시 제쳐두고 Spinning과 Puff 아이콘을 한번 React 컴포넌트로 옮겨보기로 했다.</p>        <figure title="Spinning과 Puff">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-1/bezier-for-frontend.01.gif" alt="Spinning과 Puff" style="max-width:340px">          <figcaption>&lt;그림 1. Spinning과 Puff&gt;</figcaption>        </figure>    <h2 id="SVG와-3차-베지에-곡선"><a href="#SVG와-3차-베지에-곡선" class="headerlink" title="SVG와 3차 베지에 곡선"></a>SVG와 3차 베지에 곡선</h2><p>Spinning 아이콘은 손쉽게 옮겼지만, Puff 아이콘은 좀 달랐다. 이전에 옮긴 아이콘 모두 애니메이션이 선형적(linear) 이기 때문에 신경 쓸 게 없었다. 하지만 Puff 아이콘의 SVG는 조금 다른 방식으로 만들어져 있다.</p><pre><code class="language-html">&lt;svg width="44" height="44" viewBox="0 0 44 44" xmlns="http://www.w3.org/2000/svg" stroke="#fff"&gt;    &lt;g fill="none" fill-rule="evenodd" stroke-width="2"&gt;        &lt;circle cx="22" cy="22" r="1"&gt;            &lt;animate attributeName="r"                begin="0s" dur="1.8s"                calcMode="spline"                values="1; 20"                keyTimes="0; 1"                keySplines="0.165, 0.84, 0.44, 1"                repeatCount="indefinite" /&gt;                ... 중략 ...        &lt;/circle&gt;    &lt;/g&gt;&lt;/svg&gt;</code></pre><p>위 코드에서 <code>animate</code> 엘리먼트를 살펴보자. 이 엘리먼트는 <code>calcMode</code>, <code>values</code>, <code>keyTimes</code>, <code>keySplines</code> 속성을 갖고 있다. 일단 이 속성에 관한 지식이 전혀 없기 때문에 우선 <a href="https://www.w3.org/TR/2001/REC-smil-animation-20010904/" target="_blank" rel="noopener">SMIL</a> 스펙 문서를 살펴봤다.</p><p>스펙 문서를 통해 <code>calcMode</code>는 <strong>값의 타이밍을 제어할 함수</strong>를 선택하는 속성임을 알 수 있다. 속성 값으로 “discrete”, “linear”, “paced”, “spline” 중 하나를 지정할 수 있다.</p><p>위 코드의 <code>calcMode</code> 속성에는 “spline”이 지정돼 있는데 “spline”으로 지정하면 <code>values</code>, <code>keyTimes</code>, <code>keySplines</code> 속성과 함께 “<strong>3차 베지에 곡선</strong>“으로 값을 제어할 수 있다.</p><p>잠깐, “3차 베지에 곡선”이라고? 다들 CSS로 애니메이션을 처리할 때 cubic-bezier라는 애니메이션 타이밍 함수를 한 번쯤 사용해본 적이 있을 것이다. cubic-bezier… 그렇다. 3차 베지에라는 뜻이다.</p><h2 id="CSS와-3차-베지에-곡선"><a href="#CSS와-3차-베지에-곡선" class="headerlink" title="CSS와 3차 베지에 곡선"></a>CSS와 3차 베지에 곡선</h2><p>cubic-bezier 애니메이션 타이밍 함수는 x, y, x`, y` 즉, 4개의 값을 인자로 전달받아 에니메이션의 타이밍을 조절한다. x, y는 첫 번째 가이드 포인트(Guide Point)의 좌표, x`, y`은 두 번째 가이드 포인트의 좌표다. 가이드 포인트란 곡선의 형태에 영향을 주는 조절 가능한 점을 뜻한다.</p>        <figure title="3차 베지에 곡선의 가이드 포인트">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-1/bezier-for-frontend.02.png" alt="3차 베지에 곡선의 가이드 포인트" style="max-width:340px">          <figcaption>&lt;그림 2. 3차 베지에 곡선의 가이드 포인트&gt;</figcaption>        </figure>    <p>3차 베지에 곡선이란 이 두 가이드 포인트의 위치에 따라 그려지는 곡선을 말한다. cubic-bezier는 이 곡선을 이용해 에니메이션의 타이밍을 조절한다(이 속성은 <a href="http://cubic-bezier.com/" target="_blank" rel="noopener">cubic-bezier.com</a>, <a href="http://www.css3beziercurve.net/" target="_blank" rel="noopener">CSS3 Bezier Curve Tester</a>, <a href="https://www.desmos.com/calculator/cahqdxeshd" target="_blank" rel="noopener">desmos</a>에서 간단히 테스트해 볼 수 있다).</p>        <figure title="cubic-bezier를 이용해 선언한 Easing 함수 셋">          <img src="/assets/img/2017/bezier-curves-for-frontend-engineer-1/bezier-for-frontend.03.png" alt="cubic-bezier를 이용해 선언한 Easing 함수 셋" style="max-width:340px">          <figcaption>&lt;그림 3. cubic-bezier를 이용해 선언한 Easing 함수 셋&gt;</figcaption>        </figure>    <p>우리가 알고 있는 easeInSine, easeInQuad 등과 같은 Easing 함수(<a href="http://easings.net/ko#" target="_blank" rel="noopener">참고</a>)는 모두 이 베지에 곡선을 이용해 미리 만든 일종의 셋이다.</p><h2 id="한걸음-더…"><a href="#한걸음-더…" class="headerlink" title="한걸음 더…"></a>한걸음 더…</h2><p>자, 본래 이야기로 다시 돌아와서… </p><p>SVG의 <code>calcMode=&quot;spline&quot;</code>의 의미를 살펴봤으니 <a href="https://www.npmjs.com/package/bezier-easing" target="_blank" rel="noopener">bezier-easing</a>같은 npm 모듈을 사용해 Puff 아이콘을 React 컴포넌트로 옮기면 된다. 하지만 커밋을 완료하고 따듯한 이불 속에서 편안한 마음으로 잠자리에 들기엔 모르는 것이 너무나 많다. </p><p>왜 베지에 곡선이라 부를까? 무엇을 근거로 1차, 2차, 3차라고 나눌까? 또, 곡선이 그려지는 원리와 공식은 무엇일까? 몇 가지 물음이 잠 못 이루게 했고 결국 이 주제로 글을 작성하게 됐다. </p><p>그럼 다음 편부터 본격적으로 베지에 곡선에 관해서 연재하도록 하겠다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="http://qiita.com/volkuwabara/items/64d1ac2c3d8e8a3110f5" target="_blank" rel="noopener">SCSS에서 사용할 cubic-bezier 값을 저장해두자(일본어)</a></li></ul>]]></content>
    
    <summary type="html">
    
      이 문서는 프런트개발에 있어서 유용하게 사용되는 베지에 곡선(Bézier Curves)의 원리를 수학적으로 자세히 소개하는 글의 첫 번째 편입니다.
    
    </summary>
    
      <category term="Algorithm" scheme="http://blog.coderifleman.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://blog.coderifleman.com/tags/Algorithm/"/>
    
      <category term="BezierCurves" scheme="http://blog.coderifleman.com/tags/BezierCurves/"/>
    
      <category term="Spline" scheme="http://blog.coderifleman.com/tags/Spline/"/>
    
      <category term="Animation" scheme="http://blog.coderifleman.com/tags/Animation/"/>
    
      <category term="Math" scheme="http://blog.coderifleman.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>중학생도 알 수 있는 베지에 곡선(Bézier Curves)</title>
    <link href="http://blog.coderifleman.com/2016/12/30/bezier-curves/"/>
    <id>http://blog.coderifleman.com/2016/12/30/bezier-curves/</id>
    <published>2016-12-29T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[        <div class="alert alert--info">            <div class="alert__inner">                                    <div class="alert__title">                        <strong>읽기전에...</strong>                    </div>                                <div class="alert__body">                    <p>이 문서는 일본어  「<a href="http://blog.sigbus.info/2011/10/bezier.html" target="_blank" rel="noopener">中学生でもわかるベジェ曲線</a>」를 번역한 글입니다.</p>                </div>            </div>        </div>    <p>“베지에 곡선”을 이용해 렌더링하게 되면 꽤 재미있고 편안하게 그림을 그릴 수 있다. 오늘은 이를 사용하는 누구라도 그 원리를 이해할 수 있도록 설명하고자 한다.</p><p>“베지에 곡선”이라는 것은 매끄러운 곡선을 그리기 위한 것이지만 설명은 우선 단순한 직선부터 시작하겠다. 아래 그림 1 처럼 직선에서의 점의 움직임이 모든 “베지에 곡선”의 기본이 되기 때문이다.</p>        <figure title="1차 베지에 곡선">          <img src="/assets/img/2016/bezier-curves/bezier-curve.01.gif" alt="1차 베지에 곡선" style="max-width:300px">          <figcaption>&lt;그림 1. 1차 베지에 곡선&gt;</figcaption>        </figure>    <p>하나의 직선이 있고 그 위를 점 <code>M</code>이 일정 속도로 이동하고 있다. 이 점 <code>M</code>의 궤적은 당연하지만 단순한 직선으로 그려진다. 좋다. <code>t</code>는 <a href="http://dic.daum.net/word/view.do?wordid=kkw000140374&amp;supid=kku000175471" target="_blank" rel="noopener">선분</a> 위를 비율적으로 얼마나 나아갔는지를 나타내는 수치다.</p><p>여기에 선을 하나 더 추가하고 그 위에 <code>M</code>처럼 이동하는 점을 놓아보자. 그리고 원래의 점 <code>M</code>을 <code>M0</code>로, 새로운 점을 <code>M1</code>으로 부르자. <code>M0</code>와 <code>M1</code>이 움직이는 규칙은 이전과 같다. <code>M1</code>이라는 점이 하나 더 늘었다 하더라도 특별히 복잡해질 것은 없다.</p>        <figure title="2차 베지에 곡선">          <img src="/assets/img/2016/bezier-curves/bezier-curve.02.gif" alt="2차 베지에 곡선" style="max-width:300px">          <figcaption>&lt;그림 2. 2차 베지에 곡선&gt;</figcaption>        </figure>    <p>자, 여기에서 <code>M0</code>와 <code>M1</code>을 잇는 선을 하나 더 그을 수 있다. 그 선은 <code>M0</code>와 <code>M1</code>이 이동하면 자연스럽게 함께 움직이게 된다. 이제 그 선에 주목해보자. 그 선 위에 <code>M0</code>나 <code>M1</code>처럼 일정 속도로 이동하는 점을 놓을 수 있다. 그 점을 <code>B</code>라고 하자. 그리고 점 <code>B</code>가 그리는 궤적을 살펴보자. 그렇다. 점 <code>B</code>가 그리는 궤적을 <strong>2차 베지에 곡선(Quadratic Bezier Curve)</strong>이라고 한다.</p><p>점 <code>P0</code>, <code>P1</code> 등 을 조절점(Control Point)이라고 한다. 이제 조절점을 하나 더 늘린 “베지에 곡선”을 상상해보자.</p><p>아래 그림 3을 보면 새로운 점 <code>P3</code>가 추가돼 있고 <code>P2</code>와 <code>P3</code>를 선으로 잇고 있다. 그리고 <code>M0</code>나 <code>M1</code>과 같이 그 선 위를 이동하는 점을 생각해 볼 수 있다. 그 점의 이름은 <code>M2</code>라 하자.</p>        <figure title="3차 베지에 곡선">          <img src="/assets/img/2016/bezier-curves/bezier-curve.03.gif" alt="3차 베지에 곡선" style="max-width:300px">          <figcaption>&lt;그림 3. 3차 베지에 곡선&gt;</figcaption>        </figure>    <p>자, 2차 베이제 곡선에서는 <code>P0</code>, <code>P1</code>, <code>P2</code>의 조합으로 점 <code>B</code>의 위치를 정할 수 있었다. 그렇다면 마찬가지로 <code>P1</code>, <code>P2</code>, <code>P3</code>의 조합으로도 비슷하게 점의 위치를 정할 수 있을 것이다.</p><p>이전에 부르던 점 <code>B</code>를 <code>B0</code>라고 부르기로 하고 <code>P1</code>, <code>P2</code>, <code>P3</code>의 조합으로 정해지는 새로운 점을 <code>B1</code>이라고 부르기로 하자. 그렇게 하면 이전과 마찬가지로 점 <code>B0</code>와 점 <code>B1</code>을 잇는 선과 그 선 위를 일정한 속도로 움직이는 점을 다시 생각해 볼 수 있는데 이때 그 점이 그리는 궤적을 <strong>3차 베지에 곡선(Cubic Bezier Curve)</strong>이라고 한다.</p><p>여기에서 끝이 아니다. 조절점을 한 개 더 늘려 <code>P0</code>, <code>P1</code>, <code>P2</code>, <code>P3</code> 조합과 <code>P1</code>, <code>P2</code>, <code>P3</code>, <code>P4</code> 조합으로 결정되는 선과 그 선을 일정 속도로 이동하는 점 <code>B2</code>를 추가하고 <code>B1</code>과 <code>B2</code>를 잇는 선을 놓고 그 위를 지나가는 또 다른 점을 추가한 후 그 점이 그리는 궤적을 살펴볼 수 있다. 이런 식으로 곡선은 얼마든지 복잡하고 다양하게 만들 수 있다. <code>P0</code>부터 <code>P4</code>로 정해지는 곡선은 <strong>4차 베지에 곡선(Quartic Bezier Curve)</strong>이라고 부른다. 하지만 조절점을 5개 이상 늘려도 실용적인 측면에서 특별한 이점이 없으므로 일반적으로 3차 베지에 곡선까지 사용된다.</p><p>여기까지 간단하게 “베지에 곡선”에 관해 이야기했다. 한마디로 “베지에 곡선”이란 선분 위를 일정 속도로 움직이는 점과 그러한 점과 점을 잇는 또 다른 선분, 그리고 그 위를 일정 속도로 이동하는 또 다른 점 등을 조합해 최종적으로 특정 점이 그리는 궤적을 이용해 곡선을 그려내는 방법을 뜻한다. 이해하는 데 도움이 됐으리라 기대한다.</p>]]></content>
    
    <summary type="html">
    
      이 문서는 일본어 문서 「中学生でもわかるベジェ曲線」을 번역한 것으로 곡선을 그리거나 애니메이션 처리에 근간이 되는 베지에 곡선(Bézier Curves)의 원리에 관해서 쉽고 간단하게 소개합니다.
    
    </summary>
    
      <category term="Algorithm" scheme="http://blog.coderifleman.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://blog.coderifleman.com/tags/Algorithm/"/>
    
      <category term="BezierCurves" scheme="http://blog.coderifleman.com/tags/BezierCurves/"/>
    
      <category term="Spline" scheme="http://blog.coderifleman.com/tags/Spline/"/>
    
      <category term="Animation" scheme="http://blog.coderifleman.com/tags/Animation/"/>
    
      <category term="Math" scheme="http://blog.coderifleman.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>requestAnimationFrame을 어떻게 테스트 할 수 있을까?</title>
    <link href="http://blog.coderifleman.com/2016/12/02/request-animation-frame-test/"/>
    <id>http://blog.coderifleman.com/2016/12/02/request-animation-frame-test/</id>
    <published>2016-12-01T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>얼마전에 기능 개발을 하다가 애니메이션을 다룰 일이 생겼다. 처음엔 CSS를 이용했지만, IE8을 지원하고자 “<a href="https://github.com/chrisdickinson/raf" target="_blank" rel="noopener">raf</a>“라는 폴리필 라이브러리를 이용해 <code>requestAnimationFrame</code>(이하 raf)으로 개발했다. raf의 대략적인 형태는 다음과 같다(API의 자세한 설명은 <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener">MDN의 window.requestAnimationFrame()</a>을 참고).</p><pre><code class="language-js">var start = null;function step(timestamp) {  if (!start) {    start = timestamp;  }  var progress = timestamp - start;  // Use progress to do something.  if (progress &lt; 1500) {    window.requestAnimationFrame(step);  }}window.requestAnimationFrame(step);</code></pre><p>코드를 보면 알겠지만 그렇게 직관적인 편은 아니다. raf를 쓸 때마다 이런 식으로 코드를 작성하긴 싫었다. 그래서 사용하기 편하게 raf를 랩핑한 객체 하나를 만들었다(여기서 시작한 작은 프로젝트가 있다 - <a href="https://github.com/UYEONG/stepperjs" target="_blank" rel="noopener">StepperJS</a>).</p><pre><code class="language-js">class Stepper {  start(options) {    const {      duration = 0,      easing = linear, // is easing function.      step = () =&gt; {}    } = options;    let startTime = 0;    const stepping = (timestamp) =&gt; {      if (!startTime) {        startTime = timestamp;      }      const pastTime = timestamp - startTime;      const progress = pastTime / duration;      if (pastTime &gt;= duration) {        step(1);        return;      }      step(easing(progress));      window.requestAnimationFrame(stepping);    };    window.requestAnimationFrame(stepping);  }}</code></pre><p>이렇게 작성한 Stepper 객체는 다음과 같이 사용할 수 있다.</p><pre><code class="language-js">const stepper = new Stepper();stepper.start({  duration: 1500,  step: (n) =&gt; {    element.style.left = `${150 * n}px`  }});</code></pre>        <p data-height="300" data-theme-id="0" data-slug-hash="yVpNLo" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="yVpNLo" class="codepen">            See the Pen <a href="http://codepen.io/uyeong/pen/yVpNLo/" target="_blank" rel="noopener">yVpNLo</a> by Uyeong Ju (<a href="http://codepen.io/uyeong" target="_blank" rel="noopener">@uyeong</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.        </p>    <p>개인적으로 생각했을 때 raf를 곧바로 사용하는 것보다 더 직관적이고 편해 보인다(물론 다른 의견을 가진 사람이 있을 수도 있다). 이제 Stepper 객체를 어떻게 테스트할 수 있을지 살펴보자.</p><p>Stepper는 지정한 <code>duration</code>과 <code>easing</code>에 따라 현재 시점에 해당하는 n 즉, progress 값을 콜백 함수에 전달하는 단순한 역할을 담당한다. 그렇다면 다음과 같이 테스트 케이스를 작성할 수 있을 것 같다.</p><blockquote><p>should call step callback with the current progress by duration and easing.</p></blockquote><p>음, 확실히 유닛 테스트로써는 손색없지만 필자는 사용자 관점에서 서술하는 걸 좋아하니 이렇게 고쳐보자.</p><blockquote><p>The user should be able to know the current progress through the start method of Stepper</p></blockquote><p>이를 어떻게 검증할 수 있을까? 필요한 값을 설정하고 start 메서드를 호출한 후 특정 시간으로 옮긴(tick) 다음 “n”이 기대하는 값과 일치하는지 확인하면 될 것 같다. 한번 테스트 코드로 옮겨보자.</p><pre><code class="language-js">test('The user should be able to know the current progress through the start method of Stepper', (assert) =&gt; {  // Given  const stepper = new Stepper();  const duration = 300;  const easing = linear;  let progress;    // When  stepper.start({    duration,    easing,    step: (n) =&gt; progress = n  });    // Then  assert(progress === ???);});</code></pre><p>다른 조건들은 어려울 게 없지만, 특정 시간으로 옮기는 행위는 그렇지 않다. 함수를 호출하는 순간 시간은 흘러 버리므로 특정 시간에 해당하는 progress 값을 비교할 수 없다.</p><p>이처럼 테스트 환경에서 시간을 조작하고 싶을 때 사용할 수 있는 테스트 더블 라이브러리가 있다. 바로 “<a href="http://sinonjs.org/docs/" target="_blank" rel="noopener">sinon</a>“이다. <a href="http://sinonjs.org/docs/#clock" target="_blank" rel="noopener">sinon의 FakeTimer</a>는 <code>setTimeout</code>과 <code>Date</code> 객체 등을 덮어써서 동기적으로 시간을 조작할 수 있는 수단을 제공한다. 이것을 사용해보자.</p><pre><code class="language-js">const clock = sinon.useFakeTimers();test('The user should be able to know the current progress through the start method of Stepper', (assert) =&gt; {    // Given    const stepper = new Stepper();    const duration = 300;    const easing = linear;    const step = sinon.spy();    // When    stepper.start({        duration,        easing,        step    });    clock.tick(0);    clock.tick(250);    // Then    assert(step.args[1][0].toFixed(2) === linear(250 / 300).toFixed(2));});</code></pre>        <p data-height="300" data-theme-id="0" data-slug-hash="PbEaMp" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="PbEaMp" class="codepen">            See the Pen <a href="http://codepen.io/uyeong/pen/PbEaMp/" target="_blank" rel="noopener">PbEaMp</a> by Uyeong Ju (<a href="http://codepen.io/uyeong" target="_blank" rel="noopener">@uyeong</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.        </p>    <p>당연한 얘기겠지만 <code>TypeError</code>가 발생한다. raf는 시간이 아닌 <code>repaint</code> 시점을 기준으로 호출되며 독자적으로 타임스템프를 계산해 콜백에 전달하므로 sinon의 FakeTimer로 조작할 수 없다. 따라서 동기적으로 호출한 <code>args</code> 프로퍼티에 쌓인 값이 없으므로 에러가 발생하는 것이다.</p><p>그렇다면 어떻게 해야 할까. 고맙게도 누군가 raf를 Stub한 “<a href="https://github.com/alexreardon/raf-stub" target="_blank" rel="noopener">raf-stub</a>“을 개발해 배포해놨다. 이 Stub을 사용해 테스트를 다시 작성해보자.</p><pre><code class="language-js">const stub = createStub();sinon.stub(window, 'requestAnimationFrame', stub.add);test('The user should be able to know the current progress through the start method of Stepper', (assert) =&gt; {    // Given    const stepper = new Stepper();    const duration = 300;    const easing = linear;    const step = sinon.spy();    // When    stepper.start({        duration,        easing,        step    });    stub.step(1, 0);    stub.step(1, 250);    // Then    assert(step.args[1][0].toFixed(2) === linear(250 / 300).toFixed(2));});</code></pre>        <p data-height="300" data-theme-id="0" data-slug-hash="LbeJZz" data-default-tab="result" data-user="uyeong" data-embed-version="2" data-pen-title="LbeJZz" class="codepen">            See the Pen <a href="http://codepen.io/uyeong/pen/LbeJZz/" target="_blank" rel="noopener">LbeJZz</a> by Uyeong Ju (<a href="http://codepen.io/uyeong" target="_blank" rel="noopener">@uyeong</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.        </p>    <p>테스트가 통과한다. raf를 사용해 작성한 코드를 테스트하려고 할 때 다소 막막할 수 있다. 하지만 sinon과 Stub을 적절히 사용한다면 손쉽게 테스트할 수 있다.</p><p>여기까지 raf를 테스트하는 방법을 소개했다. 비슷한 고민을 하는 사람에게 작은 팁으로나마 도움이 되길 바라며 예제 코드는 <a href="https://github.com/UYEONG/request-animation-frame-test" target="_blank" rel="noopener">UYEONG/request-animation-frame-test</a>에 올려놓았으니 참고하길 바란다.</p>]]></content>
    
    <summary type="html">
    
      requestAnimationFrame을 사용해 작성한 코드를 어떻게 유닛 테스트(Unit Test)할 수 있는지 단계별로 자세히 소개합니다.
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
      <category term="Test" scheme="http://blog.coderifleman.com/categories/JavaScript/Test/"/>
    
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
      <category term="Animation" scheme="http://blog.coderifleman.com/tags/Animation/"/>
    
      <category term="Test" scheme="http://blog.coderifleman.com/tags/Test/"/>
    
      <category term="requestAnimationFrame" scheme="http://blog.coderifleman.com/tags/requestAnimationFrame/"/>
    
      <category term="UnitTest" scheme="http://blog.coderifleman.com/tags/UnitTest/"/>
    
  </entry>
  
  <entry>
    <title>history 객체의 scrollRestoration 속성</title>
    <link href="http://blog.coderifleman.com/2016/11/28/scroll-restoration-property-of-history/"/>
    <id>http://blog.coderifleman.com/2016/11/28/scroll-restoration-property-of-history/</id>
    <published>2016-11-27T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>특정 목록 페이지에 접근할 때 사용자가 마지막으로 클릭했던 아이템이 보이도록 자동 스크롤링 해달라는 요청이 들어왔다. 개인적으로 <code>onload</code> 타임에 특정 목록으로 자동 스크롤링하는 기능은 지양해 왔기 때문에 웹이 가진 한계점을 설명하면서 간단히 프로토타이핑해본 후 판단하자고 의견을 냈다.</p><p>그런데 프로토타이핑하던 도중 예전엔 경험하지 못했던 이상한 현상이 발견됐다. 아래는 사용자가 마지막으로 클릭한 아이템이 “product30” 이라고 보고 해당하는 엘리먼트의 위치로 스크롤링하는 간단한 코드다.</p><pre><code class="language-js">window.addEventListener('load', () =&gt; {    console.log('onloaded');    const product30 = document.getElementsByClassName('product-item')[29];    const top = product30.getBoundingClientRect().top;    console.log(`scroll to ${top}(product30)`);    window.scrollTo(0, top);});</code></pre><p>생각한 대로라면 지정한 위치로 스크롤링 되어야 하지만 동작하지 않았다. 아래 “그림 1”을 보면 분명히 <code>9970.875</code> 즉, “product30”의 위치로 스크롤링을 지시했음에도 문서는 여전히 최상단에 있음을 알 수 있다.</p>        <figure title="동작하지 않는 scrollTo()">          <img src="/assets/img/2016/scroll-restoration-property-of-history/scroll.01.png" alt="동작하지 않는 scrollTo()" style="">          <figcaption>&lt;그림 1. 동작하지 않는 scrollTo()&gt;</figcaption>        </figure>    <p>간단한 코드로 재현하긴 힘들지만, 실제 서비스 페이지에서는 <code>setTimeout(() =&gt; ..., 0)</code>으로 지정해도 금세 원래의 위치로 크롬이 재보정한다.</p><p> 이렇게 동작하는 이유는 크롬이 사용자가 보고 있던 스크롤 위치를 저장하고 있다가 해당 페이지에 다시 접근하면 브라우저 레벨에서 자동으로 스크롤링하기 때문인데 어떻게 해야 이를 회피할 수 있을지 고민됐다. 이때 <a href="http://sculove.github.io/blog/" target="_blank" rel="noopener">찬욱</a>님에게 여쭤보니 아래와 같은 코드로 이를 무력화할 수 있다는 답변을 받았다.</p><pre><code class="language-js">if ('scrollRestoration' in history) {    // Back off, browser, I got this...    history.scrollRestoration = 'manual';}</code></pre><p>위 코드를 삽입하고 다시 페이지에 접근하니 정확히 의도한 대로 동작했다.</p>        <figure title="제대로 동작하는 scrollTo()">          <img src="/assets/img/2016/scroll-restoration-property-of-history/scroll.02.png" alt="제대로 동작하는 scrollTo()" style="">          <figcaption>&lt;그림 2. 제대로 동작하는 scrollTo()&gt;</figcaption>        </figure>    <p>프로토타이핑은 무사히 완료했고 의사 결정하는데 큰 역할을 했다. 하지만 이렇게 이야기를 마무리하기엔 찜찜하다. <code>scrollRestoration</code> 속성을 좀 이해하고 넘어가야 할 것 같다.</p><p>필자는 이번에 <code>scrollRestoration</code>이라는 속성을 처음 봤다. 그도 그럴 것이 <code>scrollRestoration</code>은 실험적(Experimental) API 에다가 아직 MDN에 페이지도 없고(<a href="https://developer.mozilla.org/ko/docs/Web/API/History/scrollRestoration" target="_blank" rel="noopener">참고</a>), 2015년 10월에 배포된 크롬 46에서야 추가된 API다.</p><p><code>scrollRestoration</code>은 히스토리 네비게이션의 스크롤 복원 기능을 명시적으로 지정할 수 있는 속성이다. 속성값은 ‘auto’와 ‘manual’이 전부. SPA 환경과 관련이 있어 보인다. 이 글을 읽는 사람 중 대다수는 목록 페이지에서 특정 아이템을 클릭해 엔드 페이지로 갔다가 다시 되돌아오면 스크롤을 처음부터 다시 해야 하는 경험을 한 적 있을 것 같다. 그래서 스크롤 포지션 값을 <code>LocalStorage</code>에 저장했다가 다시 목록 페이지에 접근하면 억지로 스크롤 위치를 잡아주는 기능을 구현한다.</p><p>대표적으로 네이버 주식 모바일 웹이 그런 방식으로 구현돼 있는데 토론 목록 페이지에서 토론 페이지로 접근하면 <code>scrollY</code> 값을 기억해 뒀다가,  뒤로 가기 하여 토론 목록 페이지로 되돌아오면 이 값을 이용해 스크롤 위치를 조절한다.</p>        <figure title="보던 목록으로 스크롤링하기 위해 scrollY 값을 기억한다">          <img src="/assets/img/2016/scroll-restoration-property-of-history/scroll.03.png" alt="보던 목록으로 스크롤링하기 위해 scrollY 값을 기억한다" style="">          <figcaption>&lt;그림 3. 사용자가 보던 곳으로 보정하기 위해 scrollY 값 저장&gt;</figcaption>        </figure>    <p>위와 같은 구현 방식은 사용자가 정확히 어느 경로를 통해 목록 페이지로 접근하는지 알기 어려워 자칫 잘못된 경험을 제공(검색을 통해 접근했는데 스크롤 위치를 조절하는 등)하기도 하는데 <code>scrollRestoration</code>은 history navigation을 기반으로 동작하기 때문에 이러한 부분을 해소할 수 있을 것으로 보인다. 하지만 처음에 이야기한 것처럼 자동 스크롤링 기능이 오히려 특정 기능 구현에 방해가 될 수도 있는데 세심하게 개발자에게 조절할 수 있도록 속성을 열어줘서 고마울 따름.</p><p>테스트 코드는 <a href="https://github.com/UYEONG/scroll-restoration-test" target="_blank" rel="noopener">UYEONG/scroll-restoration-test</a>에 올려놓았으니 참고하길 바란다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/History" target="_blank" rel="noopener">History - Web APIs</a></li><li><a href="https://developers.google.com/web/updates/2015/09/history-api-scroll-restoration" target="_blank" rel="noopener">History API: Scroll Restoration</a></li><li><a href="https://majido.github.io/scroll-restoration-proposal/history-based-api.html" target="_blank" rel="noopener">Custom Scroll Restoration - History-based API</a></li></ul>]]></content>
    
    <summary type="html">
    
      onload 타임에 특정 위치에 자동 스크롤링 되는 기능을 프로토타이핑 하면서 마주한 문제와 history 객체의 scrollRestoration 속성으로 해결한 과정을 소개합니다.
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
      <category term="Etc" scheme="http://blog.coderifleman.com/categories/JavaScript/Etc/"/>
    
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
      <category term="history" scheme="http://blog.coderifleman.com/tags/history/"/>
    
      <category term="scrollRestoration" scheme="http://blog.coderifleman.com/tags/scrollRestoration/"/>
    
  </entry>
  
  <entry>
    <title>첫 인상이 좋은 E2E 테스트 프레임워크, TestCafe</title>
    <link href="http://blog.coderifleman.com/2016/10/31/good-first-impression-testcafe/"/>
    <id>http://blog.coderifleman.com/2016/10/31/good-first-impression-testcafe/</id>
    <published>2016-10-30T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>인생을 살다 보면 괴롭지만 꼭 해야만 하는 일을 만나게 된다. 프런트엔드개발자에겐 그런 일 중 하나가 바로 UI 테스트가 아닐까 싶은데, 이 고통스러운 일을 조금이나마 덜어줄 잘 만들어진 도구나 프레임워크를 찾지만 쉽지 않다. 처음엔 좋아 보여도 실제 테스트를 작성하다 보면 금세 그 도구가 가진 한계점을 만나게 된다. 그래서 그런지 다른 일보다도 더욱 도구에 의존하게 되고 개선된 또 다른 도구를 찾게 되는 것 같다.</p><p><a href="http://devexpress.github.io/testcafe/" target="_blank" rel="noopener">TestCafe</a>는 자바스크립트 소식을 매주 정리해 공유하는 사이트인 <a href="https://jser.info" target="_blank" rel="noopener">JSer.info</a>의 <a href="https://jser.info/2016/10/24/npm-4.0.0-node.js-v6.9.0-lts-webpack2/" target="_blank" rel="noopener">2016년 10월 24일 자 소식</a>을 통해 알게 됐다. 해당 문서에 링크된 <a href="http://efcl.info/2016/10/23/testcafe/" target="_blank" rel="noopener">TestCafe로 브라우저 자동 테스트(일본어)</a>를 읽어보았는데 생각보다 느낌이 좋아서 한번 리뷰해보자는 결론을 내렸다.</p><h2 id="TestCafe-소개"><a href="#TestCafe-소개" class="headerlink" title="TestCafe 소개"></a>TestCafe 소개</h2><p>TestCafe는 <a href="https://www.devexpress.com/" target="_blank" rel="noopener">DevExpress</a>가 개발한 E2E 테스트 프레임워크다. InfoQ에 TestCafe와 관련된 인터뷰 글(<a href="https://www.infoq.com/news/2013/08/testcafe" target="_blank" rel="noopener"><br>TestCafe with Smart Script Injection, Traffic and Markup Analysis Tools</a>)이 있으니 관심 있는 사람은 참고하길 바란다. 같은 이름의 <a href="https://testcafe.devexpress.com/" target="_blank" rel="noopener">웹 서비스 및 클라이언트 앱</a>도 서비스 중인데 이 서비스는 셀레니움 IDE 처럼 GUI로 조작하고 행위를 기록하여 재생할 수 있다.</p><p>TestCafe는 <a href="http://webdriver.io/" target="_blank" rel="noopener">webdriber.io</a>나 <a href="http://nightwatchjs.org/" target="_blank" rel="noopener">나이트왓치</a>와는 다르게 테스트 관련 스크립트를 주입해 동작하는 셀레니움 RC(Selenium RC)와 흡사한 방식으로 개발됐다. 사실 셀레니움 RC가 가진 한계를 극복하고자 셀레니움 웹드라이버(Selenium WebDriver)를 개발했는데 다시 셀레니움 RC와 비슷한 구조로 테스트 프레임워크를 만들었다고 해서 “그렇다면 과거에 경험했던 한계를 그대로 답습하는 게 아닌가?”하고 조금 의아했다. </p><p>TestCafe의 개발자 <a href="https://github.com/inikulin" target="_blank" rel="noopener">이반 니쿨린(Ivan Nikulin)</a>은 <a href="https://testcafe-discuss.devexpress.com/t/why-not-use-selenium/47" target="_blank" rel="noopener">Why not use Selenium?</a>에서 그 이유를 밝혔는데 간단히 말해서 테스트 환경에 대한 복잡한 설정 없이 실행할 수 있고, 모바일 기기에서도 원격 접속해 테스트할 수 있는 도구를 만들고 싶어 했던 거 같다. 또, 웹드라이버의 호환성 문제를 회피하기 위한 목적도 있는 것 같다.</p><p>셀레니움은 분명 훌륭한 도구지만 설정이 복잡하고 웹드라이버 자체의 버그로 인해 테스트 작성에 종종 걸림돌이 되는 경우가 있다. 또 테스트 코드 자체를 디버깅하기가 까다로워 복잡한 테스트 케이스를 작성하는데 어려운 면도 가지고 있다. 과거 셀레니움 RC 방식에 한계가 있어 셀레니움을 만들었지만 새로운 문제들이 나타났다. 이러한 상황에서 TestCafe의 지향점이 좋은 해결책이 될 수 있을까?</p><h2 id="좋은-인상"><a href="#좋은-인상" class="headerlink" title="좋은 인상"></a>좋은 인상</h2><p>필자는 유료 웹툰을 서비스하고 있는 <a href="http://www.lezhin.com" target="_blank" rel="noopener">레진(Lezhin)</a>을 이용해 로그인 테스트를 작성해 봤다. 예제 코드는 저장소 <a href="https://github.com/UYEONG/demo-testcafe" target="_blank" rel="noopener">UYEONG/demo-testcafe</a>를 참고한다. 이번 절에서는 이 예제를 이용해 필자가 받은 몇 가지 좋은 인상을 소개하겠다.</p><pre><code class="language-js">test('사용자는 GNB 메뉴에서 로그인할 수 있다.', async (t) =&gt; {    // Given    const popupAttendanceLogin = new PopupAttendanceLogin(t);    if (await popupAttendanceLogin.exist()) {        await popupAttendanceLogin.close();    }    await t        .click('#main-menu-toggle')        .typeText('#login-email', ACCOUNT.USER_NAME)        .typeText('#login-password', ACCOUNT.PASSWORD);    // When    await t        .click('form.login-form button[type=submit]')        .wait(1000);    // Then    await t.click('#main-menu-toggle');    const email = await getElement('sidenav-email');    assert(email.visible);    assert(email.innerText === ACCOUNT.USER_NAME);});</code></pre><p>위는 레진에서 GNB 메뉴를 이용해 로그인이 정상적으로 이뤄지는지 테스트하는 코드다. 그리고 이 코드는 <code>await/async</code>를 이용해 비동기적 절차를 동기적으로 표현하고 있다. TestCafe는 바벨(Babel)을 내장하고 있어 별도의 설정 없이 최신 사양을 이용할 수 있다. 최신 사양으로 코드를 작성하고자 할 때 복잡한 세팅을 해줘야 하는 기존의 테스트 프레임워크와는 다른 부분이다. </p>        <figure title="TestCafe에서 디버깅하기">          <img src="/assets/img/2016/good-first-impression-testcafe/testcafe.01.gif" alt="TestCafe에서 디버깅하기" style="">          <figcaption>&lt;그림 1. TestCafe에서 디버깅하기&gt;</figcaption>        </figure>    <p>또, <code>await/async</code> 방식으로 테스트 코드를 작성하면 디버깅이 쉽다는 장점이 있는데 체이닝을 펼치기 쉬우므로 각 액션을 단계별로 관찰할 수 있다. 나이트왓치는 파이프라인 방식으로 디자인돼 있어 디버깅이 다소 까다롭다.</p><p>그럼 이제 실행을 해보자. 해당 저장소를 클론하고 다음 명령어를 입력하면 바로 테스트할 수 있다.</p><pre><code class="language-bash">$ git clone git@github.com:UYEONG/demo-testcafe.git$ npm install$ npm run test</code></pre><p><code>npm scripts</code>에 등록한 <code>test</code> 명령은 다음과 같다. </p><pre><code class="language-bash">$ testcafe chrome tests/</code></pre><p>뭔가 추가적인 설정이 없으니 오히려 불안하다. 하지만 그 안락함에 금방 익숙해진다. 이것저것 세팅해줘야 했던 셀레니움 기반 프레임워크(<a href="http://blog.coderifleman.com/2016/06/17/e2e-test-and-nightwatch/#%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0">참고</a>)와는 사뭇 다른 경험이다.</p>        <figure title="로그인 테스트 실행 결과">          <img src="/assets/img/2016/good-first-impression-testcafe/testcafe.02.gif" alt="로그인 테스트 실행 결과" style="">          <figcaption>&lt;그림 2. 로그인 테스트 실행 결과&gt;</figcaption>        </figure>    <p>그림 2는 로그인 테스트가 진행되는 모습이다. 이 테스트의 진행 절차는 다음과 같다.</p><ol><li>www.lezhin.com 페이지에 접근한다. </li><li>최초에 출력된 팝업이 있다면 닫는다.</li><li>우측 상단의 메뉴 버튼을 클릭한다.</li><li>이메일 / 패스워드를 입력하고 로그인 버튼을 선택한다.</li><li>페이지가 갱신되면 다시 우측 상단의 메뉴 버튼을 클릭한다.</li><li>로그인이 정상적으로 완료 됐는지 확인한다.</li></ol><p>특정 절차에서 다음 절차로 넘어가기 위해선 지연 시간(Delay time)이 필요하다. 예를 들어 최초 페이지에 접근할 때는 콘텐츠가 모두 출력되는 시점을 기다려야 하고 팝업을 닫을 때는 애니메이션(FadeOut)이 종료되는 시간을 기다려야 한다. 나이트왓치에서는 이런 지연 시간을 직접 명시해줘야 한다.</p><pre><code class="language-js">// 페이지에 최초 접근 시 body 엘리먼트가 보일 때까지 5000ms 기다린다.this._header    .navigate()    .waitForElementVisible('body', 5000);    // 팝업을 닫을때 애니메이션 시간을 고려해 500ms 기다린다.this.click('@close');this.api.pause(500);</code></pre><p>하지만 TestCafe를 이용할 땐 지연 시간을 직접 입력할 일이 상대적으로 적다. TestCafe는 지연 시간을 직접 계산하고 관리한다. 실제로 위 로그인 테스트 코드를 보면 지연 시간을 명시한 지점은 로그인 버튼을 클릭한 시점 즉, 폼을 서브밋하고 갱신되기를 기다리는 딱 한 곳뿐이다.</p><pre><code class="language-js">await t    .click('form.login-form button[type=submit]')    .wait(1000);</code></pre><p>지연 시간이라고 해도 거의 대충 시간을 짐작해 입력하는 일에 불과하다. 물론 비기능적 요구사항도 테스트에 포함돼야 하지만 애니메이션 종료 시점까지 일일이 명시해야 한다는 것은 분명 귀찮은 일이다. </p><p>그리고 이벤트 지점을 커서로 표현해주거나 실제 타이핑을 하는 느낌을 살려 텍스트를 입력하는 부분도 인상적이다. 셀레니움 기반 테스트 프레임워크는 이런 자연스러운 느낌이 상대적으로 적다.</p>        <figure title="TestCafe의 에러 리포팅">          <img src="/assets/img/2016/good-first-impression-testcafe/testcafe.03.png" alt="TestCafe의 에러 리포팅" style="">          <figcaption>&lt;그림 3. TestCafe의 에러 리포팅&gt;</figcaption>        </figure>    <p>마지막으로 에러 리포팅도 상당히 깔끔한 편인데 어느 지점에서 어떠한 에러가 낫는지 알기 쉽게 출력해준다. 그림 3을 보면 24번째 행의 코드에 문제가 있음을 쉽게 알 수 있다.</p><p>구구절절 설명했지만 TestCafe를 리뷰하면서 좋은 인상을 받은 점을 간단히 정리하면 다음과 같다.</p><ul><li>바벨을 내장하고 있어서 특별한 설정 없이 ES6+ 사양을 사용할 수 있다.</li><li>테스트 코드 디버깅이 상대적으로 쉽다.</li><li>특별한 설정 없이 커멘드 라인 명령으로 바로 테스트할 수 있다.</li><li>특정 조작에 대한 지연 시간을 자동으로 관리한다.</li><li>테스트 실패 및 에러 리포팅이 깔끔한 편이다.</li></ul><h2 id="아쉬운-점"><a href="#아쉬운-점" class="headerlink" title="아쉬운 점"></a>아쉬운 점</h2><p>분명 기존의 E2E 테스트 프레임워크보다 몇 가지 좋은 인상을 가지고 있는건 분명하다. 하지만 아쉬운 점도 있다. 일단 다양한 상황을 테스트하기엔 액션 셋과 API가 부족하다. </p>        <figure title="TestCafe와 그 외 프레임워크의 API 목록">          <img src="/assets/img/2016/good-first-impression-testcafe/testcafe.04.png" alt="TestCafe와 그 외 프레임워크의 API 목록" style="">          <figcaption>&lt;그림 4. TestCafe와 그 외 프레임워크의 API 목록&gt;</figcaption>        </figure>    <p>왼쪽 부터 차례대로 TestCafe, 나이트왓치, webdriver.io 가 제공하고 있는 액션 및 API 목록이다. 기본적인 액션은 제공하지만, 모바일에 특화된 액션이나 스크립트 권한 밖의 액션 등은 이용하기 힘들다. 시간이 지나면서 제공될 수 있는 API도 있지만 TestCafe가 가지고 있는 구조적 한계로 인해 아예 불가능한 API도 있다.</p><p>또, E2E 테스트를 할 때 좋은 패턴들이 있는데 그중 하나가 <code>PageObject</code>다. 테스트에 필요한 반복적인 행위나 엘리먼트 셀렉터 등을 밖으로 노출 시키지 않고 페이지 단위(혹은 컴포넌트 단위)로 추상화해 제공할 수 있다(<a href="http://nightwatchjs.org/guide#page-objects" target="_blank" rel="noopener">참고</a>). <code>PageObject</code>는 테스트 코드의 가독성이나 유지 보수 측면에서 훌륭한 패턴이지만 TestCafe에서는 제공하지 않는다. </p><pre><code class="language-js">// page-objects/popup-attendance-login.jsimport {Selector} from 'testcafe'; const querySelector = Selector(q =&gt; document.querySelector(q)); class PopupAttendanceLogin {    elements = {        wrapper: '#popup-attendance-login',        closeBtn: '#popup-attendance-login .attlogin__close'    };    constructor(testController) {        this.t = testController;    }    async exist() {        const wrapper = await querySelector(this.elements.wrapper);        return wrapper.visible;    }    async close() {        const closeBtn = await querySelector(this.elements.closeBtn);        await this.t.click(closeBtn);    }} export default PopupAttendanceLogin;// tests/signin-test.jsimport PopupAttendanceLogin from '../page-objects/popup-attendance-login';test('사용자는 GNB 메뉴에서 로그인할 수 있다.', async (t) =&gt; {    // Given    const popupAttendanceLogin = new PopupAttendanceLogin(t);    if (await popupAttendanceLogin.exist()) {        await popupAttendanceLogin.close();    }    // ... 생략 ...</code></pre><p>그래서 필자는 위 코드처럼 직접 <code>PageObject</code>와 비슷한 객체를 직접 만들고 테스트 코드를 작성했다. 만약 프레임워크 자체에서 이 개념을 제공한다면 조금 더 편리하게 코드를 작성할 수 있을 것 같다.</p><h2 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로"></a>끝으로</h2><p>여기까지 TestCafe를 소개하고 필자가 느낀 좋은 인상과 아쉬운 점을 함께 이야기했다. 이 도구가 우리의 UI 테스트 환경의 답이 돼 줄 것이라 생각하지 않는다. 분명 실제로 테스트를 작성하기 시작하면 온갖 버그와 미흡한 점을 만나게 될 것이다. 하지만 아직 시작된 지 얼마 안 된 프로젝트라는 점을 미루어 볼 때 차차 개선될 것이라고 긍정적으로 생각할 수 있다. </p><p>중요한 건 그들이 어떤 문제를 해결하고 싶어 하고 어디에 지향점을 두고 있느냐다. 그것이 내 앞에 놓인 문제 혹은 환경과 맞아떨어진다면 더할 나위 없는 좋은 도구가 될 것이다.</p>]]></content>
    
    <summary type="html">
    
      E2E 테스트 프레임워크의 한 종류인 TestCafe를 소개하고 사용 방법과 또 다른 E2E 테스트 프레임워크인 나이트왓치와의 차이점을 간략하게 살펴본다
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
      <category term="Test" scheme="http://blog.coderifleman.com/categories/JavaScript/Test/"/>
    
    
      <category term="Test" scheme="http://blog.coderifleman.com/tags/Test/"/>
    
      <category term="E2E" scheme="http://blog.coderifleman.com/tags/E2E/"/>
    
      <category term="E2E Test" scheme="http://blog.coderifleman.com/tags/E2E-Test/"/>
    
      <category term="TestCafe" scheme="http://blog.coderifleman.com/tags/TestCafe/"/>
    
  </entry>
  
  <entry>
    <title>공학기술과 사회를 읽고</title>
    <link href="http://blog.coderifleman.com/2016/10/11/read-the-engineering-technology-and-society/"/>
    <id>http://blog.coderifleman.com/2016/10/11/read-the-engineering-technology-and-society/</id>
    <published>2016-10-10T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>나는 소프트웨어 엔지니어다. 이 일로 돈을 벌고 가족을 책임지지만 여전히 엔지니어링 즉, 공학이란 무엇이냐는 단순한 질문에도 쉽게 대답하지 못한다. 나뿐만 아니다. 세상에는(적어도 내가 만난 엔지니어 중에는) 과학이나 수학의 세계를 공학과 혼동하는 사람도 있고 과학과 수학이 공학보다 더 우위에 있다고 말하는 사람도 있다. 모두 공학을 잘 이해하지 못해 일어나는 일이다.</p><p>공학의 본질적 목표는 무엇이며, 엔지니어가 정확히 무슨 일을 하는 사람을 일컫는지 알지 못하면서 소프트웨어 공학 관련 직업에 종사하고 있다는 사실이 아이러니하게 느껴지기도 한다. 그래서 그런지 요샌 스킬-업보단 공학이란 무엇인가에 좀 더 관심을 두고 「<a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9791185628141&amp;orderClick=LAG&amp;Kc=" target="_blank" rel="noopener">공학 학교에서 배운 101가지</a>」나 「<a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788925559315&amp;orderClick=LAG&amp;Kc=http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788925559315&amp;orderClick=LAG&amp;Kc=" target="_blank" rel="noopener">맨발의 엔지니어들</a>」 같은 조금은 덜 전문적이지만 딱딱하지 않은 책을 읽는데 시간을 내고 있다.</p><p>이번에(사실 포스팅으로는 처음) 소개할 책은 「<a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;mallGb=KOR&amp;barcode=9788959090112&amp;orderClick=LAH&amp;Kc=" target="_blank" rel="noopener">공학기술과 사회</a>」다. 공학에 대한 여러 가지 잡생각을 하며 퇴근하던 중 강남 <a href="http://www.ypbooks.co.kr/m_main.yp" target="_blank" rel="noopener">영풍문고</a>에 들르게 됐는데, 진열장에 꽂혀 있는 이 책이 나의 눈길을 사로잡았다.</p>        <figure title="공학 기술과 사회 책표지">          <img src="/assets/img/2016/read-the-engineering-technology-and-society/engineering.01.jpg" alt="공학 기술과 사회 책표지" style="">          <figcaption>&lt;그림 1. 공학 기술과 사회&gt;</figcaption>        </figure>    <p>책 표지나 내용 전개 방식을 보면 다소 대학 교재 같은 느낌이 난다. 실제로 한국공학교육센터에서 공학소양 교과목 DB구축사업의 목적으로 연구비를 받아 집필됐다고 한다. 교재 같은 점만 제외하면 책 내용 자체는 제법 훌륭한 편이다. </p><blockquote><p>엔지니어가 전공을 통하여 사회에 공헌하기 위해서는 자기가 하는 일이 사회와 어떤 관계가 있으며, 기술이 전반적으로 사회와 서로 어떤 영향을 주고 받는지 이해할 필요가 있다.</p></blockquote><p>소프트웨어 엔지니어는 현재에 집중하여 좀 더 나은 미래를 만들기 위해 살아가지만, 사회에 있어 의미 있는 무엇인가를 만들기 위해선 사회와 기술의 관계를 이해할 필요가 있다. 눈앞에 놓여있는 기술적 문제 해결에만 집중하기보단 조금 더 넓은 시야를 가지고 다양한 사회적 문제를 어떻게 해결할 수 있을지, 사회 속에 엔지니어와 기술의 책임은 무엇일지 고민해야만 엔지니어로서 가장 만족할 수 있는 성과를 달성할 수 있지 않을까.</p><p>이때 이 책이 그러한 시작점으로써 좋은 지적 재료가 될 수 있다. 공학의 정의부터 엔지니어적 가치, 기술의 역사, 기술결정론이나 기술 사회적 구성론 같은 기술사회론도 일반인이 이해하고 받아드리기 쉽게 작성돼 있다. </p><p>앞으로도 공학의 본질적인 측면과 사회와의 관계를 이해하고 엔지니어로서의 책임 범위와 중요한 덕목을 갖춘 그런 훌륭한 엔지니어가 되기 위해 끊임없이 정진해야 할 것 같다. 먼 훗날 한 사람의 엔지니어로서 훌륭한 인생을 살았다고 스스로 자신 있게 말할 수 있도록 말이다.</p><p>그나저나 모두 베이컨을 아는가? 먹는 베이컨이 아니라 “아는 것이 힘이다”라고 말한 철학자 <a href="https://namu.wiki/w/%ED%94%84%EB%9E%9C%EC%8B%9C%EC%8A%A4%20%EB%B2%A0%EC%9D%B4%EC%BB%A8" target="_blank" rel="noopener">프랜시스 베이컨(Francis Bacon)</a> 말이다(최근에 FRP 라이브러리로도 등장했다 -<a href="http://baconjs.github.io/" target="_blank" rel="noopener">Bacon.js</a>-). 이 책을 통해서 알게 된 사실인데 베이컨은 공학적 측면에서도 상당히 멋진 분인 걸 알 수 있었다.</p><blockquote><p>근데 초 서양에서 기술의 가치를 높게 평가하고 기술 진보를 인류의 역사에서 매우 중요한 과제로 제시함으로써 플라톤과 아리스토텔레스 이후 지속돼왔던 “기술에 대한 천대”를 종식시키려 노력했던 대표적 인물이 바로 프랜시스 베이컨(Francis Bacon)이다. … 중략 … 베이컨은 발명을 통한 기술적 진보가 사회 발전에 필수적인 요소임을 강조함으로서 과학은 고상하지만 기술은 비천하다는 편견을 없애려 했다.</p></blockquote><p>우리 모두 자부심을 가지고 유용한 제품을 만들어내는 훌륭한 공학자의 인생을 살아나가자. 기술은 절대 천하지 않고 공학은 위대하다! 끝.</p>]]></content>
    
    <summary type="html">
    
      지호출판사에서 발행한 「공학기술과 사회」라는 책을 읽고 개인적인 느낌과 감평을 작성한 문서입니다.
    
    </summary>
    
      <category term="Book" scheme="http://blog.coderifleman.com/categories/Book/"/>
    
    
      <category term="Engineering" scheme="http://blog.coderifleman.com/tags/Engineering/"/>
    
      <category term="Technology" scheme="http://blog.coderifleman.com/tags/Technology/"/>
    
      <category term="Society" scheme="http://blog.coderifleman.com/tags/Society/"/>
    
      <category term="Review" scheme="http://blog.coderifleman.com/tags/Review/"/>
    
  </entry>
  
  <entry>
    <title>E2E 테스트와 나이트왓치</title>
    <link href="http://blog.coderifleman.com/2016/06/17/e2e-test-and-nightwatch/"/>
    <id>http://blog.coderifleman.com/2016/06/17/e2e-test-and-nightwatch/</id>
    <published>2016-06-16T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>나이트왓치를 소개하기 전에 E2E 테스트의 정의부터 셀레니움 웹드라이버 등 기본 개념부터 간단히 소개하겠다.</p><h2 id="E2E-테스트"><a href="#E2E-테스트" class="headerlink" title="E2E 테스트"></a>E2E 테스트</h2><h3 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h3><p>소프트웨어 테스트는 <a href="https://en.wikipedia.org/wiki/Software_testing##Testing_levels" target="_blank" rel="noopener">테스트의 규모(레벨)</a>에 따라 유닛 테스트, 통합 테스트, 시스템 테스트, 인수 테스트 이렇게 4가지로 분류한다. 여기에서 E2E 테스트는 시스템 테스트에 속한다. </p><p>E2E(End-to-End) 테스트는 전체 시스템이 제대로 작동하는지 확인 하기 위한 테스트로 시나리오 테스트, 기능 테스트, 통합 테스트, GUI 테스트를 하는데 사용한다. API와의 연동도 테스트 항목에 포함되기 때문에 일반적으로 목(Mock)이나 스텁(Stub)과 같은 테스트 더블을 사용하지 않으며 최대한 실제 시스템을 사용하는 사용자 관점에서 시뮬레이션 한다. 그래서 테스트 속도가 서비스 규모에 따라 상당히 느릴 수 있기 때문에 유닛 테스트나 기능 테스트를 위한 일반적인 테스트 자동화와 시스템 테스트를 위한 E2E 테스트 자동화를 함께 구성한다.</p><h3 id="E2E-테스트-프레임워크"><a href="#E2E-테스트-프레임워크" class="headerlink" title="E2E 테스트 프레임워크"></a>E2E 테스트 프레임워크</h3><p>E2E 테스트 프레임워크는 다양한 종류가 있는데, 크게 헤드리스 브라우저를 의존하는 것과 셀레니움 웹드라이버를 의존하는 것으로 나눌 수 있다. 셀레니움 웹드라이버는 다음 절에서 자세히 설명한다.</p><p>헤드리스 브라우저는 커맨드 라인 명령어로 조작할 수 있는 화면이 없는 브라우저로 Jsdom 기반의 좀비(Zombie.js), 웹킷 엔진 기반의 팬텀(Pantom.js), 겟코 엔진 기반의 슬리머(Slimer.js) 등이 있다. 잘 알려진 캐스퍼(Casper.js)는 팬텀과 슬리머를 조금 더 사용하기 쉽게 만들어 놓은 유틸리티 도구다. 헤드리스 브라우저는 기본적으로 크로스 브라우징 테스트가 불가능하며 어썰트(Assert)도 내장하고 있지 않기 때문에 필요하다면 추가를 해야한다.</p><p>셀레니움 웹드라이버를 의존하는 프레임워크로는 <a href="http://webdriver.io/" target="_blank" rel="noopener">webdriver.io</a>, <a href="https://github.com/cucumber/cucumber-js" target="_blank" rel="noopener">큐컴버(Cucumber.js)</a>, <a href="https://github.com/angular/protractor" target="_blank" rel="noopener">프로트랙터</a>, <a href="http://nightwatchjs.org" target="_blank" rel="noopener">나이트왓치</a> 등이 있다. 이들은 크로스 브라우징 테스트가 가능하고 어썰트도 내장하고 있다. 단, 각 프레임워크 마다 내장하고 있는 어썰트 라이브러리는 다르다.</p><h3 id="셀레니움-웹드라이버"><a href="#셀레니움-웹드라이버" class="headerlink" title="셀레니움 웹드라이버"></a>셀레니움 웹드라이버</h3><p>나이트왓치는 셀레니움 웹드라이버(Selenium WebDriver) API를 사용해 개발된 E2E 테스트 프레임워크이기 때문에 본격적으로 사용해보기 전에 셀레니움과 웹드라이버를 먼저 이해할 필요가 있다.</p><p>셀레니움 웹드라이버의 원래 이름은 셀레니움(또는 셀레니움 1.0)이었다. 셀레니움은 웹 브라우저를 사용하여 웹 애플리케이션을 테스트하는 오픈 소스 도구다. 이때 사람의 손으로 직접 웹 브라우저를 조작하는 것이 아니라 작성된 스크립트에 따라 자동으로 조작한다. 이러한 방법을 브라우저 자동화(Browser Automation)라고 표현한다.</p><p>셀레니움은 시카고에 위치한 <a href="https://www.thoughtworks.com" target="_blank" rel="noopener">소트워크스(ThoughtWorks)</a> 사에서 개발을 시작했다. 소트워크스는 마틴 파울러(Martin Fowler)가 속한 그룹으로 유명하다.</p><p>웹드라이버는 셀레니움의 단점을 보완하고자 구글의 엔지니어들이 개발하고 사용한 브라우저 자동 테스트 도구이다. 2006년 경 구글에서 근무 중이던 <a href="https://www.linkedin.com/in/sistewart" target="_blank" rel="noopener">시몬 스튜어트(Simon Stewart)</a>가 주도해 프로젝트를 시작하고 2009년에 처음으로 공식 발표했다.</p>        <figure title="Selenium Projects">          <img src="/assets/img/2016/e2e-test-and-nightwatch/e2e_and_nightwatch.01.png" alt="Selenium Projects" style="">          <figcaption>&lt;그림 1. 셀레니움 프로젝트의 흐름&gt;</figcaption>        </figure>    <p>과거 셀레니움은 자체 엔진인 셀레니움 RC(Remote Control)를 이용해 브라우저와 통신했다.</p><p>셀레니움 RC는 자바나 파이썬 등의 언어로 스크립트를 작성하면 그 스크립트를 기반으로 브라우저를 조작하는 자바스크립트를 생성하고 해당 페이지에 삽입 후 브라우저를 조작하는 간단한 구조였다. 이러한 구조는 브라우저의 보안 제약이나 자바스크립트의 한계로 인해 실효성이 떨어지는 단점이 있었다. 이 단점이 시몬 스튜어트가 웹드라이버를 만들게 된 이유이기도 하다.</p><p>그에 반해 웹드라이버는 브라우저의 확장 기능과 OS의 기본 기능 등을 이용하여 브라우저를 조작하는 구조였다. 이는 셀레니움 RC의 단점을 충족해줄 수 있는 방식이었다.</p>        <figure title="Selenium webdriver high level block diagram">          <img src="/assets/img/2016/e2e-test-and-nightwatch/e2e_and_nightwatch.02.png" alt="Selenium webdriver high level block diagram" style="">          <figcaption>&lt;그림 1. 셀레니움 웹드라이버 다이어그램&gt;</figcaption>        </figure>    <p>이 방식이 성공하여 셀레니움 RC와 웹드라이버 통합이 이루어졌고 2011년 7월에 셀레니움 웹드라이버(또는 셀레니움 2.0)를 릴리즈하게 된다. 즉, 현재 우리가 알고있는 셀레니움은 웹드라이버와 통합한 버전이다.</p><p>그림 2를 보면 알 수 있듯이 웹드라이버는 다양한 브라우저와 환경을 대응해야하는데, 브라우저마다 이를 위한 API가 다를 경우 또 다른 문제가 발생할 수 있기 때문에 현재 표준화를 제정(<a href="https://www.w3.org/TR/webdriver/" target="_blank" rel="noopener">W3C WebDriver</a>) 중이다.</p><p>현재 셀레니움 웹드라이버는 파이썬, 루비, 자바, C## 그리고 Node.js를 이용해 웹브라우저는 조작할 수 있도록 다양한 API를 제공하고 있다. 하지만 셀레니움 서버와 자바스크립트의 궁합이 좋지 않고, 돔을 조작 하거나 셀렉팅하는데 한계가 있어 셀레니움 웹드라이버와 노드를 바인딩하여 다양한 기능을 제공하는 여러가지 형태의 프로젝트가 생겨났다. 그 중 유명한 프로젝트가 바로 webdriver.io와 나이트왓치 그리고 앵귤러 프로젝트를 위한 프로트랙터다.</p><p>이들 도구는 웹드라이버 API를 사용할 때 생기는 다양한 패턴을 추상화한 API와 신택스 슈가 등을 제공해 셀레니움 2.0 보더 더 편리하고 다양한 경험을 제공한다.</p><h2 id="나이트왓치"><a href="#나이트왓치" class="headerlink" title="나이트왓치"></a>나이트왓치</h2><p>나이트왓치는 노드 기반의 E2E 테스트 프레임워크다. 셀레니움 웹드라이버를 중개하여 각종 브라우저를 조작하고 동작이 기대한 것과 일치하는지 테스트하는데 사용한다. CSS 셀렉터로 엘리먼트를 셀렉팅하여 테스트를 작성할 수 있도록 하는 기능과 신텍스 슈가 그리고 단순하고 간결한 문법을 제공한다. 또한 테스트 러너를 포함하고 있으므로 독자적으로 그룹화한 테스트를 한번에 실행할 수 있으며 지속적인 통합의 파이프 라인과 합칠 수 있다는 특징을 가지고 있다.</p><p>나이트왓치를 알게 된건 나보다 먼저 E2E 테스트를 리서치하고 관련 도구를 찾고있던 훈민이형(개발왕 김코딩, <a href="http://huns.me/" target="_blank" rel="noopener">블로그</a>) 덕분이었다. 미리 삽질을 하고 계셨기 때문에 다른 도구를 선택하기 보다 같이 삽질하는 편이 고민할 시간도 적어서 큰 고민 없이 사용했다.</p><h3 id="설치하기"><a href="#설치하기" class="headerlink" title="설치하기"></a>설치하기</h3><p>나이트왓치 설치는 개발자 가이드 <a href="http://nightwatchjs.org/guide##installation" target="_blank" rel="noopener">Getting Started</a> 절에 잘 설명돼 있다. 이 문서에는 간단하게 요약해 설치 과정을 설명한다. 우선 NPM을 이용해 설치한다.</p><pre><code class="language-base">$ npm install --save-dev nightwatch</code></pre><p>웹드라이버로 브라우저와 통신하기 위해서는 셀레니움 서버를 실행시켜야한다. <a href="http://selenium-release.storage.googleapis.com/index.html" target="_blank" rel="noopener">셀레니움 서버 다운로드 사이트</a>에서 파일을 다운 받고 아래와 같이 서버를 실행한다. 이 글을 작성하는 현재 기준 가장 최신 버전은 2.53.0 이다.</p><p>프로젝트 디렉터리에서 nightwatch.json을 생성하고 다음과 같이 작성한다. 옵션의 자세한 설명은 개발자 가이드 <a href="http://nightwatchjs.org/guide##settings-file" target="_blank" rel="noopener">Configuration</a> 절을 참고한다.</p><pre><code class="language-js">{  "src_folders" : ["tests"], // 테스트할 디렉터리, 배열로 지정  "output_folder" : "tests/reports", // JUnit XML 리포트 파일이 저장될 위치  "custom_commands_path" : "", // 불러올 커스텀 커맨드가 있는 위치  "custom_assertions_path" : "", // 불러올 커스텀 어썰트가 있는 위치  "page_objects_path" : "", // 불러올 페이지 객체가 있는 위치  "globals_path" : "", // 불러올 외부 글로벌 모듈이 있는 위치  "selenium" : {   // 셀레니움 서버 환경 설정    "start_process" : true, // 테스트 시작시 셀레니움 프로세스를 자동으로 실행할 것 인지 여부    "server_path" : "./selenium-server-standalone-2.53.0.jar", // 셀레니움 서버 jar 파일의 경로, start_process가 false면 지정하지 않아도 된다.    "log_path" : "tests/logs", // 셀레니움의 output.log 파일이 저장될 경로    "host" : "127.0.0.1", // 셀레니움 서버의 listen ip    "port" : 4444, // 셀레니움 서버의 listen port    "cli_args" : { // 셀레니움 프로세스로 넘겨질 cli 인자 목록      "webdriver.chrome.driver" : "",      "webdriver.ie.driver" : ""    }  },  "test_settings" : { // 테스트 브라우저 별 환경 설정    "default" : { // 모든 브라우저에 적용 될 공통 설정      "launch_url" : "http://localhost",      "selenium_port"  : 4444,      "selenium_host"  : "localhost",      "silent": true, // 셀레니움의 로그를 숨길지 여부      "screenshots": { // 테스트가 실패 했을 때 촬영 될 스크린샷 설정        "enabled" : true,        "on_failure" : true,        "on_error" : false,        "path" : "tests/screenshots"      },      "desiredCapabilities": { // 셀레니움 웹드라이버로 전달할 브라우저 이름과 기능 지정        "browserName": "firefox",        "javascriptEnabled": true,        "acceptSslCerts": true      }    }  }}</code></pre><p>tests 디렉터리 하위에 demo.js를 생성하고 간단한 테스트 코드를 한다.</p><pre><code class="language-js">module.exports = {    '사용자는 검색어를 입력 후 검색어가 포함된 자동 완성 리스트를 볼 수 있다.' : function (browser) {        browser            .url('http://www.google.com')            .waitForElementVisible('body', 1000)            .setValue('input[type=text]', 'nightwatch')            .pause(1000)            .assert.containsText('##sbtc', 'nightwatch')            .end();    }};</code></pre><p>이어서 아래 명령어로 간단한 E2E 테스트를 실행할 수 있다.</p><pre><code class="language-bash">$ ./node_modules/nightwatch/bin/nightwatch</code></pre><p>하지만 현재 파이어폭스 버전 47에 문제가 있어 테스트가 실행되지 않을것이다. 파이어폭스에서 테스트 하고 싶다면 예전 버전(<a href="https://support.mozilla.org/en-US/kb/install-older-version-of-firefox" target="_blank" rel="noopener">Install an older version of Firefox</a>)으로 다운그레이드 하거나 GeckoDriver를 사용해야한다(<a href="https://developer.mozilla.org/en-US/docs/Mozilla/QA/Marionette/WebDriver##Setting_up_the_Marionette_executable" target="_blank" rel="noopener">Setting up the Marionette executable</a>). 여기에서는 GeckoDriver를 이용하는 방법을 소개(OSX 기준)하겠다.</p><p>먼저 <a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">mozilla/geckodriver</a>에서  GeckoDriver를 다운로드한다.</p><pre><code class="language-bash">$ cd ~/Downloads$ wget https://github.com/mozilla/geckodriver/releases/download/v0.8.0/geckodriver-0.8.0-OSX.gz</code></pre><p>다운로드한 파일을 압축 해제하고 적당한 위치로 옮긴 후 실행가능한 파일로 변경한다.</p><pre><code class="language-bash">$ gunzip geckodriver-0.8.0-OSX.gz$ mkdir executable && mv geckodriver-0.8.0-OSX executable/wires$ chmod 755 executable/wires</code></pre><p>이제 .bash_profile(또는 .zshrc)에서 PATH를 지정한다.</p><pre><code class="language-bash">$ vim ~/.zshrcGECKO_DRIVER=$HOME/Downloads/executableexport PATH=$HOME/bin:/usr/local/bin:/usr/local/sbin:$GECKO_DRIVER:$PATH## rc파일을 다시 불러온다.$ source ~/.zshrc</code></pre><p>마지막으로 nightwatch.json파일에서 desiredCapabilities 속성을 다음과 같이 변경한다.</p><pre><code class="language-js">"desiredCapabilities": {  "browserName": "firefox",  "marionette": true, // 추가  "javascriptEnabled": true,  "acceptSslCerts": true}</code></pre><p>이제 다시 실행해보면 파이어폭스 브라우저에서 정상적으로 테스트가 진행될 것이다.</p>        <figure title="데모 테스트 실행 결과">          <img src="/assets/img/2016/e2e-test-and-nightwatch/e2e_and_nightwatch.03.png" alt="데모 테스트 실행 결과" style="">          <figcaption>&lt;그림 3. 데모 테스트 실행 결과&gt;</figcaption>        </figure>    <h3 id="여러-브라우저에서-동시에-테스트하기"><a href="#여러-브라우저에서-동시에-테스트하기" class="headerlink" title="여러 브라우저에서 동시에 테스트하기"></a>여러 브라우저에서 동시에 테스트하기</h3><p>현재 작성한 설정 파일로 나이트왓치를 실행하면 파이어폭스에서만 테스트가 진행된다. 이번엔 크롬 브라우저에서도 테스트가 진행되도록 설정을 변경하겠다. 크롬 브라우저는 셀레니움과 통신할 웹드라이버를 별도로 설치해야하는데 웹드라이버 매니저를 사용하면 쉽게 설치할 수 있다. 아래 명령어로 웹드라이버 매니저를 설치한다.</p><pre><code class="language-bash">$ npm install --save-dev webdriver-manager # 크롬 웹드라이버와 앞 절에서 다운로드 받았던 셀레니움 서버가 함께 설치된다.$ ./node_modules/.bin/webdriver-manager update # 또는 아래 명령어 처럼 인자를 전달해 별도로 설치할 수도 있다.# ./node_modules/.bin/webdriver-manager update --chrome</code></pre><p>이제 nightwatch.json에 셀레니움 서버 경로와 크롬 웹드라이버 서버 경로를 수정한다.</p><pre><code class="language-js">"selenium": {  "start_process": true,  "server_path": "./selenium-server-standalone-2.53.0.jar",  "log_path": "tests/logs",  "host": "127.0.0.1",  "port": 4444,  "cli_args": {    "webdriver.chrome.driver" : "node_modules/webdriver-manager/selenium/chromedriver_2.21", // 추가    "webdriver.ie.driver": ""  }},</code></pre><p>다음으로 default 속성에 작성했던 파이어폭스 브라우저 설정을 test_settings 속성 하위로 옮기고 크롬 브라우저 설정도 함께 추가 작성한다.</p><pre><code class="language-js">{  // ... 생략 ...  "test_settings": {    "default": {      "launch_url": "http://localhost",      "selenium_port": 4444,      "selenium_host": "localhost",      "silent": true,      "screenshots": {        "enabled" : true,        "on_failure" : true,        "on_error" : false,        "path" : "tests/screenshots"      }    },    "firefox": {      "desiredCapabilities": {        "browserName": "firefox",        "marionette": true,        "javascriptEnabled": true,        "acceptSslCerts": true      }    },    "chrome": {      "desiredCapabilities": {        "browserName": "chrome",        "javascriptEnabled": true,        "acceptSslCerts": true      }    }  }}</code></pre><p>이제 아래 명령어로 실행하면 두 브라우저에서 동시에 테스트가 실행된다.</p><pre><code class="language-base">$ ./node_modules/nightwatch/bin/nightwatch --env firefox,chrome</code></pre><p>사파리 브라우저에서 테스트하고자 한다면 사파리 웹드라이버를 확장 기능으로 설치해야한다. 자세한 내용은 나이트왓치 위치의 <a href="https://github.com/nightwatchjs/nightwatch/wiki/Running-tests-in-Safari" target="_blank" rel="noopener">Running tests in Safari</a> 문서를 참고한다.</p>        <figure title="사파리의 웹드라이버 확장프로그램">          <img src="/assets/img/2016/e2e-test-and-nightwatch/e2e_and_nightwatch.04.png" alt="사파리의 웹드라이버 확장프로그램" style="">          <figcaption>&lt;그림 4. 사파리의 웹드라이버 확장프로그램&gt;</figcaption>        </figure>    <h3 id="모카-사용하기"><a href="#모카-사용하기" class="headerlink" title="모카 사용하기"></a>모카 사용하기</h3><p>이번엔 테스트 코드를 모카 기반으로 작성할 수 있는 환경을 만들어보겠다. 나이트왓치는 어썰트로 챠이(chai)를 내장하고 있지만 모카는 별도로 설정해 사용해야한다. 모카를 설정하는 자세한 내용은 개발자 가이드 <a href="http://nightwatchjs.org/guide##using-mocha" target="_blank" rel="noopener">Using Mocha</a> 절을 참고한다. 모카를 굳이 사용하려는 이유는 JUnit XML로 리포팅 하는 기본 러너와는 달리 다양하고 보기 쉬운 리포팅을 지원하기 때문이다.</p><p>먼저 nightwatch.json 파일에 다음과 같이 test_runner 속성을 추가한다. 옵션에 관한 자세한 설명은 모카 위키의 <a href="https://github.com/mochajs/mocha/wiki/Using-mocha-programmatically##set-options" target="_blank" rel="noopener">Set options</a> 절을 참고한다.</p><pre><code class="language-js">{  "test_runner" : {    "type" : "mocha",    "options" : {      "ui": "bdd",      "reporter": "spec"    }  },  // ... 생략 ...}</code></pre><p>테스트 코드를 모카 기반으로 재작성한다.</p><pre><code class="language-js">describe('구글 메인 페이지', function() {     before(function(client, done) {        done();    });     after(function(client, done) {        done();    });     describe('##사용자는 검색할 수 있다.', function() {        it('사용자는 검색어를 입력 후 자동 완성된 리스트를 볼 수 있다.', function(client, done) {            client                .url('http://www.google.com')                .waitForElementVisible('body', 1000)                .setValue('input[type=text]', 'nightwatch')                .pause(1000)                .assert.containsText('##sbtc', 'nightwatch')                .end(done);        });    });});</code></pre><p>다시 실행해 보면 모카 기반으로 테스트 코드가 동작하는 것을 볼 수 있다.</p>        <figure title="모카 테스트 실행 결과">          <img src="/assets/img/2016/e2e-test-and-nightwatch/e2e_and_nightwatch.05.png" alt="모카 테스트 실행 결과" style="">          <figcaption>&lt;그림 5. 모카 테스트 실행 결과&gt;</figcaption>        </figure>    <h3 id="브라우저-스택"><a href="#브라우저-스택" class="headerlink" title="브라우저 스택"></a>브라우저 스택</h3><p>크로스 브라우징 테스트를 할 수 있도록 해주는 웹 서비스인 브라우저 스택은 다양한 플랫폼과 웹 브라우저를 지원한다. 또한, 셀레니움 서버도 제공하고 있는데 이를 이용하면 나이트왓치와 연동해 테스트를 자동화할 수 있다.</p><p>먼저 browserstack.json 파일을 작성한다.</p><pre><code class="language-js">{  // ... 생략 ...  "selenium": {    "start_process": false  },  "test_settings": {    "default" : {      "launch_url" : "http://hub.browserstack.com",      "selenium_host" : "hub.browserstack.com",      "selenium_port" : 80,      "silent" : true,      "screenshots" : {        "enabled" : true,        "on_failure" : true,        "on_error" : false,        "path" : "tests/screenshots"      },      "desiredCapabilities": {        "platform": "xp",        "browserName": "firefox",        "javascriptEnabled": true,        "acceptSslCerts": true,        "browserstack.user" : "user_id", // 브라우저 스택 아이디        "browserstack.key" : "user_key" // 브라우저 스택 키      }    }  }}</code></pre><p>platform 속성엔 XP를 browserName 속성엔 파이어폭스를 지정했고 로컬 환경에서 셀레니움 서버를 실행시킬 필요가 없기 때문에 start_process은 false로 지정했다. 이제 브라우저 스택은 윈도우즈 XP 환경의 파이어폭스 브라우저에서 테스트를 진행할 것이다. 브라우저 스택에서 지원하는 플랫폼과 브라우저는 공식 홈페이지의 <a href="https://www.browserstack.com/automate/capabilities" target="_blank" rel="noopener">Capabilities</a> 페이지를 참고하면 알 수 있다.</p><p>아래 명령어를 참고해 실행해본다.</p><pre><code class="language-js">$ ./node_modules/nightwatch/bin/nightwatch --config browserstack.json</code></pre><p>다양한 플랫폼과 브라우저에서 E2E 테스트를 할 수 있다는 점은 큰 장점이지만 통신이나 테스트를 구동하는 속도가 아주 느리다. 따라서 테스트 배치 혹은 정기 배포 전에만 사용하기 적합해 보인다.</p><h3 id="웹스톰-디버깅"><a href="#웹스톰-디버깅" class="headerlink" title="웹스톰 디버깅"></a>웹스톰 디버깅</h3><p>웹스톰에서 노드 디버깅 도구를 사용해 나이트왓치를 디버깅할 수 있다. 자세한 내용은 Debugging <a href="https://github.com/nightwatchjs/nightwatch/wiki/Debugging-Nightwatch-tests-in-WebStorm" target="_blank" rel="noopener">Nightwatch tests in WebStorm</a>을 참고한다. 다만, 파이프라인 방식이다 보니 브레이크 포인트를 활용한 디버깅이 다소 무의미한 느낌은 있다.</p><h2 id="끝으로"><a href="#끝으로" class="headerlink" title="끝으로"></a>끝으로</h2><p>여기까지 다양한 사전 지식을 설명하고 나이트왓치에 관해서 이해해봤다. E2E 테스트 특성 상 프로젝트 저장소에 테스트를 작성하고 유지하기 보단 별도의 E2E 테스트 저장소를 만들어 테스트를 작성하고 유지하는게 더 효율적이지 않을까 생각한다. 또, 나이트왓치에는 <a href="http://nightwatchjs.org/guide##page-objects" target="_blank" rel="noopener">페이지 오브젝트</a>, <a href="http://nightwatchjs.org/guide##extending" target="_blank" rel="noopener">커스텀 커맨드</a> 등 테스트를 작성할 때 유용한 개념을 제공한다. 이 두 개념을 적절히 잘 사용하면 생각보다 더 관리하기 쉬운 테스트 코드를 작성할 수 있다. </p><p>위에서 진행한 설치 및 설정 과정은 <a href="https://github.com/UYEONG/hello-nightwatch" target="_blank" rel="noopener">UYEONG/hello-nightwatch</a>에 올려놓았으니 참고하길 바란다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="http://docs.seleniumhq.org/about/history.jsp" target="_blank" rel="noopener">http://docs.seleniumhq.org/about/history.jsp</a></li><li><a href="http://google-opensource.blogspot.kr/2009/05/introducing-webdriver.html" target="_blank" rel="noopener">http://google-opensource.blogspot.kr/2009/05/introducing-webdriver.html</a></li><li><a href="http://www.infoq.com/news/2011/07/Selenium-2" target="_blank" rel="noopener">http://www.infoq.com/news/2011/07/Selenium-2</a></li><li><a href="https://seleniumhq.wordpress.com/2011/07/08/selenium-2-0/" target="_blank" rel="noopener">https://seleniumhq.wordpress.com/2011/07/08/selenium-2-0/</a></li><li><a href="http://www.slideshare.net/sethmcl/join-the-darkside-nightwatchjs" target="_blank" rel="noopener">http://www.slideshare.net/sethmcl/join-the-darkside-nightwatchjs</a></li><li><a href="https://github.com/SeleniumHQ/selenium/issues/2110" target="_blank" rel="noopener">https://github.com/SeleniumHQ/selenium/issues/2110</a></li><li><a href="http://blog.trident-qa.com/2013/05/so-many-seleniums" target="_blank" rel="noopener">http://blog.trident-qa.com/2013/05/so-many-seleniums</a> (일본어)</li><li><a href="https://app.codegrid.net/entry/selenium-1" target="_blank" rel="noopener">https://app.codegrid.net/entry/selenium-1</a> (일본어)</li><li><a href="http://pydiary.bitbucket.org/blog/html/2015/08/28/test.html" target="_blank" rel="noopener">http://pydiary.bitbucket.org/blog/html/2015/08/28/test.html</a> (일본어)</li><li><a href="http://blog.mmmcorp.co.jp/blog/2015/09/24/use-nightwatch/" target="_blank" rel="noopener">http://blog.mmmcorp.co.jp/blog/2015/09/24/use-nightwatch/</a> (일본어)</li><li><a href="http://www.infoq.com/jp/news/2014/03/nightwatch" target="_blank" rel="noopener">http://www.infoq.com/jp/news/2014/03/nightwatch</a> (일본어)</li><li><a href="http://qiita.com/yssg/items/a054d67bc7c7fc39b276" target="_blank" rel="noopener">http://qiita.com/yssg/items/a054d67bc7c7fc39b276</a> (일본어)</li></ul>]]></content>
    
    <summary type="html">
    
      E2E의 정의와 E2E 테스트 프레임워크의 역사 그리고 나이트왓치를 소개하며 설치하는 방법과 사용하는 방법까지 폭 넓게 설명합니다.
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
      <category term="Test" scheme="http://blog.coderifleman.com/categories/JavaScript/Test/"/>
    
    
      <category term="Test" scheme="http://blog.coderifleman.com/tags/Test/"/>
    
      <category term="E2E" scheme="http://blog.coderifleman.com/tags/E2E/"/>
    
      <category term="E2E Test" scheme="http://blog.coderifleman.com/tags/E2E-Test/"/>
    
      <category term="Nightwatch" scheme="http://blog.coderifleman.com/tags/Nightwatch/"/>
    
  </entry>
  
  <entry>
    <title>React에 대한 여러가지 생각을 읽고</title>
    <link href="http://blog.coderifleman.com/2016/04/26/read-the-thinking-about-react/"/>
    <id>http://blog.coderifleman.com/2016/04/26/read-the-thinking-about-react/</id>
    <published>2016-04-25T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>「<a href="http://youngrok.com/React%EC%97%90%20%EB%8C%80%ED%95%9C%20%EC%97%AC%EB%9F%AC%20%EA%B0%80%EC%A7%80%20%EC%83%9D%EA%B0%81#_=_" target="_blank" rel="noopener">React에 대한 여러 가지 생각</a>」이라는 글에 직접 코멘트를 달까 생각했지만, 쓰다 보니 글이 길어져서 포스팅한다. 해당 글과는 다른 개인적인 의견에 평소 이야기하고 싶었던 내용을 약간 첨부해 글을 작성했다.</p><p>개인적으로 느꼈던 리액트의 가장 큰 장점은 사고의 단순함을 끌어내는데 있다고 생각한다(물론 애플리케이션의 성격이나 상황에 따라 다르다). 성능는 부차적인 것으로 앵귤러1 보다 빠른 메커니즘을 제공하지만, 당연 순수 자바스크립트보단 느리다.</p><p>보통 자바스크립트 개발 시에는 일일이 변경을 검사해 해당하는 DOM을 가져와서 값을 대입해줘야 하는 번거로움(혹은 고통스러운)이 있다. 그래서 몇십 밀리세컨드는 신경쓰지 않고 처음부터 다시 그리는 방법을 택한 적도 있었지만 그것만으로 만족하긴 찜찜하다.</p><p>HTTP의 Stateless 성을 기반으로 개발된 웹 MVC 프레임워크를 사용할 때는 요청이 들어오면 요청에 맞는 HTML을 생성해 응답해주면 끝나는 단순한 구조이기 때문인데 이런 고통스러운 부분이 적었다. 이때의 단순함을 리액트로 개발할 때 느꼈다.</p><p>Stateless 하니 왠지 functional이라는 키워드도 떠오르는데 실제로 리액트에서 뷰는 어떤 값에 의해 생성되는 단순한 결과값(스냅샷)에 불과하다. 리액트의 가장 큰 장점은 여기에 있다고 생각한다. 이 부분이 불변, 단방향 데이터 플로우와 좋은 궁합을 보여주는 점이다. 실제로 React의 개발자인 Jordan Walke는 XHP와 함수형에서 영감을 받아 리액트를 개발했다(<a href="https://www.quora.com/How-was-the-idea-to-develop-React-conceived-and-how-many-people-worked-on-developing-it-and-implementing-it-at-Facebook" target="_blank" rel="noopener">참고</a>). 위와 같이 단순한 구조는 함수형에서, JSX는 XHP에서 영감을 받은 듯하다.</p><p>JSX는 서술적으로 컴포넌트를 표현하는 데 좋은 표기법이라고 생각한다. UI의 구조를 표현하거나 각 컴포넌트를 조합하는 데는 명령형(Imperative)보다 선언형(Declarative)이 더 적합한 경우가 많다.</p><p>아래는 jQuery로 뷰 로직을 작성할 때 자주 보이는 형태다.</p><iframe width="100%" height="300" src="//jsfiddle.net/uyeong21c/b5L5f3t9/5/embedded/js,css,html,result" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>아래는 JSX로 표현했을 때의 모습이다.</p><iframe width="100%" height="300" src="//jsfiddle.net/uyeong21c/h9y8o7ez/5/embedded/js,css,html,result" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>개인적으로 느꼈던 JSX의 단점은 애니메이션 표현에 있다. UI의 구조를 표현하기엔 적합하지만, 애니메이션처럼 뭔가 동적인 효과를 표현하기엔 오히려 장황하고 정확히 어떤 요소에 애니메이션을 적용하는지 한 번에 파악하기 힘들었다.</p><pre><code class="language-jsx">&lt;Animation fadeOut={true}&gt;&lt;Something&gt;&lt;Item/&gt;&lt;Item/&gt;&lt;/Something&gt;&lt;/Animation&gt;// or$('.somthing').fadeOut();</code></pre><p>JSX의 또 다른 문제는 낯섦이다. 기존 템플릿 방식이 아닌 XML 스러운 표기법을 그대로 자바스크립트 내에 작성한다. 이러한 방식은 처음에 상당히 혼란스럽게 느껴질 수 있다. 여기에서 거부감을 느끼고, 싫어야해야만 하는 또 다른 이유를 찾아 나서는 경우도 있다. 낯섦이라는 거부감을 잠시 잊어야하는데 말 처럼 쉬운 일은 아니다. 이런 거부감은 나 역시 있었고, 눈에 익는데 시간이 걸렸다(원래 새로운 패러다임은 이해하고 받아들이기 힘든 법이다).</p><p>해당 글에선 &lt;hr&gt;이나 &lt;input&gt;과 같은 한 줄 요소(Single-line element)도 닫아줘야 하는 이유를 HTML 규칙을 구현하는 데 한계가 있기 때문이라 말했지만, JSX는 XML-Like 한 언어이기 때문에 HTML이라기보단 XHTML에 가깝다. 그렇게 보면 당연한 부분이라고 생각한다.</p>        <figure title="공식 홈페이지의 JSX 소개 글">          <img src="/assets/img/2016/read-the-thinking-about-react/about_react.01.png" alt="공식 홈페이지의 JSX 소개 글" style="">          <figcaption>&lt;그림 1. 공식 홈페이지의 JSX 소개 글&gt;</figcaption>        </figure>    <p>또한, 여러 문맥에 걸쳐 가상 돔의 속도를 언급한다. 가상 돔의 속도를 <a href="https://github.com/trueadm/inferno" target="_blank" rel="noopener">inferno</a>와 같이 개선하는 방법도 있었는데 흥미로웠다. 랜더링 시 해당 DOM이 정적 요소인지 동적 요소인지 판단해 정적 요소라면 Diff 단계에서 아예 빼버린다. 이처럼 앞으로도 가상 돔의 속도를 개선할 수 있는 여지가 충분히 남아있다고 판단할 수 있다.</p><p>네이버의 효과툰 뷰 같이 인터렉션이나 애니메이션이 복잡해 성능을 많이 신경 써야 하는 부분이라면 React의 대체재를 찾기보단 해당 부분만 순수 자바스크립트로 구현하고 <a href="https://github.com/kirjs/react-highcharts" target="_blank" rel="noopener">react-hightchart</a> 처럼 리액트가 읽을 수 있도록 어댑터만 제공하는 게 낫다.</p>        <figure title="React Adapter">          <img src="/assets/img/2016/read-the-thinking-about-react/about_react.02.png" alt="React Adapter" style="">          <figcaption>&lt;그림 2. React Adapter 다이어그램&gt;</figcaption>        </figure>    <p>하나의 라이브러리만으로 서비스 개발 전체를 보완하긴 힘들다. 리액트가 서비스 개발 전체에 정답이 돼 줄 것으로 생각해선 안된다. 그렇다고 특정 부분에 한계가 있다고 다시 전체를 보완할 만한 프레임워크를 찾는 것도 무리다.</p><p>React의 본질은 성능이 아니다. 장점은 개인마다 느끼는 바가 다르겠지만, 개인적으로는 성능이라는 것에 너무 집중할 필요는 없다고 생각한다. React의 철학이 무엇이고 어떤 고통을 해결해주며 또, 어떤 고통은 해결해주지 못하는지 잘 이해하여 프로젝트 성격과 팀의 역량 등을 고려해 시기적절하게 사용하면 된다.</p>]]></content>
    
    <summary type="html">
    
      Youngrok Pak님의 「React에 대한 여러 가지 생각」을 읽고 해당 글에 대한 개인적인 의견과 React에 관해 평소에 이야기하고 싶었던 내용을 함께 이야기합니다.
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
      <category term="React" scheme="http://blog.coderifleman.com/categories/JavaScript/React/"/>
    
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
      <category term="React" scheme="http://blog.coderifleman.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React와 불변객체</title>
    <link href="http://blog.coderifleman.com/2015/08/16/react-and-immutable/"/>
    <id>http://blog.coderifleman.com/2015/08/16/react-and-immutable/</id>
    <published>2015-08-15T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>이번에는 불변객체의 개념과 React에 그 개념을 적용했을 때 어떤 이점을 얻을 수 있는지 소개하고자 합니다.</p><h2 id="불변객체란"><a href="#불변객체란" class="headerlink" title="불변객체란?"></a>불변객체란?</h2><p>객체 지향 프로그래밍에 있어서 불변객체(Immutable object)는 생성 후 그 상태를 변경할 수 없는 객체를 말합니다. 불변객체의 반대말은 가변객체로 자바스크립트의 배열과 같이 객체 내에서 관리하는 값이나 상태를 변경할 수 있는 것을 말합니다.</p><pre><code class="language-javascript">var greeting = new String('Hello World!!');greeting.replace('World', 'Gil-dong');greeting.valueOf(); // Hello World!!</code></pre><p>위 예에서 <code>greeting</code> 변수에 문자열 객체를 생성해 대입했습니다. 그리고 문자열 객체의 <code>replace</code> 메서드를 이용해 ‘World’라는 문자열을 ‘Gil-dong’으로 변경했습니다. 하지만 여전히 <code>greeting</code>의 값은 ‘Hello World’ 입니다.</p><p><code>greeting</code>에 생성한 문자열 객체는 불변 객체이므로 객체 자신이 소유하거나 관리하는 값 또는 상태를 바꿀 수 없습니다. 따라서 <code>replace</code> 메서드는 새로운 상태를 가지는 또 다른 객체를 생성합니다.</p><p>변수에 값을 바꾸기 위해서는 아래 처럼 새로운 객체를 변수에 대입해야 합니다.</p><pre><code class="language-javascript">var greeting = new String('Hello World!!');greeting = greeting.replace('World', 'Gil-dong');greeting.valueOf(); // Hello Gil-dong!!</code></pre><h3 id="값-객체"><a href="#값-객체" class="headerlink" title="값 객체"></a>값 객체</h3><p>이러한 불변 객체의 특성은 우리가 밀접히 사용하는 <code>Number</code>, <code>String</code>, <code>Boolean</code>과 같은 값 객체에서 만날 수 있습니다. 값 객체란 비교 연산 시 자신의 상태보다 값(value)을 우선하는 단순한 객체를 말합니다.</p>        <div class="alert alert--info">            <div class="alert__inner">                                    <div class="alert__title">                        <strong>자바스크립트에서 비교 연산</strong>                    </div>                                <div class="alert__body">                    <p>여기에서는 이해를 돕기 위해 생성자를 이용해 문자열이나 정수를 생성하고 있지만, 자바스크립트에서 생성자를 이용해 원시 타입 객체를 생성하면 비교 연산 시 참조를 이용해 비교합니다. 따라서 항상 리터럴 표기법으로 값을 다루기 바랍니다.</p><pre style="display:block"><code class="language-javascript">    new String('Hello') === new String('Hello'); // false    new Number(5) === new Number(5); // false</code></pre>                </div>            </div>        </div>    <p>값 객체는 값을 이용해 새로운 값을 만들어 낼 수 있지만 값 자체를 변경할 수 없습니다. 즉, 불변입니다.</p><pre><code class="language-javascript">var num = new Number(2);num = num + new Number(3);num.valueOf(); // 5</code></pre><p>위에서 숫자 <code>2</code>를 생성한 후 숫자 <code>3</code>을 더해 숫자 <code>5</code>를 얻고 있습니다. 숫자 <code>2</code>에 숫자 <code>3</code>을 더하는 것은 값 자체를 바꾸는 것이 아니라 새로운 값을 생성하는 것입니다. 이러한 특징은 상태를 변화시키지 않으며 새로운 값을 생성하는 함수형 스타일(functional style)과 닮았습니다.</p><h2 id="React-js와-불변객체"><a href="#React-js와-불변객체" class="headerlink" title="React.js와 불변객체"></a>React.js와 불변객체</h2><p>React 컴포넌트의 라이프 사이클 메서드 중에는 <code>shouldComponentUpdate</code> 메서드가 있습니다. 이 메서드는 컴포넌트가 다시 그려지기 전에 호출되며 만약 <code>false</code>를 반환하면 컴포넌트의 VirtualDOM을 비교하지 않습니다.</p><p>다량으로 엘리먼트를 출력하는 리스트나 피드와 같은 컴포넌트는 매번 VirtualDOM을 비교하게 되면 성능 문제가 발생할 수 있으므로 필수로 사용해야 하는 메서드입니다(대도록이면 모든 컴포넌트에 작성하는 습관을 들이는게 좋습니다).</p><h3 id="가변-객체일-때"><a href="#가변-객체일-때" class="headerlink" title="가변 객체일 때"></a>가변 객체일 때</h3><p>잘 알려진 TodoMVC를 예를 들어 설명하겠습니다.</p><pre><code class="language-javascript">// todoItem.jsshouldComponentUpdate(nextProps, nextState) {  return (    nextProps.todo !== this.props.todo ||    nextState.label !== this.state.label  );}</code></pre><p>todoItem 컴포넌트의 <code>shouldComponentUpdate</code> 메서드는 prop 속성으로 전달된 todo 객체를 비교하여 VirtualDOM을 비교할지 말지 결정하고 있습니다.</p><pre><code class="language-javascript">// todoHome.jsonUpdate(todoId, label) {  this.todos.update(todoId, label);}// todos.jsupdate(todoId, label) {    var todo = this._todos.find((todo) =&gt; todo.id === todoId);    todo.update(label);    this.emit('update');}</code></pre><p>특정 todo의 label 값을 변경하라고 todos 모델 객체에 요청하고 있습니다. todos 모델 객체는 자신이 관리하는 todo 객체들 중 하나를 찾아서 값을 변경하고 변경 사실을 통지합니다. 하지만 todoItem 컴포넌트의 단순한 비교문으로는 todo 객체의 값이 변경됐는지 알 수 없습니다.</p><p>todos 모델 객체에서 관리하는 todo 객체와 prop 속성으로 전달된 todo 객체의 참조가 동일하기 때문에 항상 참이되므로 의도한 결과를 얻을 수 없는 것입니다.</p><pre><code class="language-javascript">// todoItem.jsshouldComponentUpdate(nextProps, nextState) {  return (    nextProps.todo.label() !== this.props.todo.label() ||    nextProps.todo.completed() !== this.props.todo.completed() ||    nextState.label !== this.state.label  );}</code></pre><p><code>shouldComponentUpdate</code> 메서드의 비교문을 변경했습니다. 조금 복잡해졌습니다. 만약 하나의 객체에서 관리하고 있는 상태가 많을수록 이 비교문은 아주 복잡해질 것입니다.</p><p>하지만 여전히 이 코드는 동작하지 않습니다. todos 모델 객체에서 특정 todo 객체의 상태를 변경하면 같은 todo 객체를 참조하는 todoItem 컴포넌트에도 동일하게 반영돼 상태가 변경됐는지 알 수 없습니다. 이처럼 가변 객체의 참조를 가지고 있는 어떤 장소에서 객체를 변경하면 참조를 공유하는 모든 장소에서 그 영향을 받기 때문에 객체를 참조로 다루기란 쉽지 않습니다.</p><pre><code class="language-javascript">// todoHome.jsrender() {    var todos = this.props.todos.forEach((todo) =&gt; {        return &lt;TodoItem key={todo.get('id')} todo={todo.clone()} /&gt;;    });    return (        &lt;ul&gt;{todos}&lt;/ul&gt;    );}</code></pre><p>이번엔 <code>clone</code> 메서드를 이용해서 todo의 객체 상태를 전부 복사하여 새로운 todo 객체를 만들어 todoItem 컴포넌트에 전달하고 있습니다. 이러한 방법을 방어적 복사(defensive copy)라고 합니다.</p><p>드디어 코드는 의도한대로 동작하겠지만, 비교문은 여전히 복잡하며 매번 객체를 전체적으로 복사하는건 성능면에서 좋지 않습니다. 또, 객체의 전달 방식이나 사용 방식을 예의주시해야하는 번거로움도 수반됩니다.</p><h3 id="불변-객체일-때"><a href="#불변-객체일-때" class="headerlink" title="불변 객체일 때"></a>불변 객체일 때</h3><p>이제 todos 모델 객체의 update 메서드를 <a href="https://facebook.github.io/immutable-js/" target="_blank" rel="noopener">Immutable.js</a>를 이용해 불변 객체로 관리하도록 변경해보겠습니다.</p><pre><code class="language-javascript">// todos.jsclass Todos extends events.EventEmitter {    constructor() {        this._todos = new Immutable.List();    }    // ... 생략 ...    update(id, label) {        // 새로운 List 객체를 생성한다.        this._todos = this._todos.update(            this._todos.findIndex(t =&gt; t.get('id') === id),            t =&gt; t.set('label', label) // 새로운 todo 객체를 생성한다.        )        this.emit('update');    }}</code></pre><p>todos 객체의 생성자 메서드를 통해 Immutable.js의 List 객체를 생성하고 있습니다. 특정 todo 객체의 값을 변경할 때는 List 객체의 update 메서드를 이용해 새로운 상태를 갖는 todo 객체와 List 객체를 다시 생성하여 설정합니다.</p><pre><code class="language-javascript">// todoItem.jsshouldComponentUpdate(nextProps, nextState) {    return (        nextProps.todo !== this.props ||        nextState.label !== this.state.label    );}</code></pre><p>이제 비교문이 다시 단순해졌습니다. 객체의 상태가 변하지 않는 한 참조는 항상 같을 것이고, 객체의 상태가 변경될때만 새로운 객체가 생성되므로 참조가 달라집니다. 따라서 단순히 참조만 비교하는 것 만으로도 객체의 상태가 변경됐는지 판단할 수 있습니다.</p><p>매번 객체를 새로 생성하면 메모리 관리 시스템에 부담을 줄 수 있다고 생각할 수 있지만 이 점이 시스템 전체적인 병목을 일으키진 않습니다. 오히려 객체의 값을 전체적으로 복사하는 방어적 복사가 더 부담이 될 수 있습니다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>불변 객체는 값을 복사할 필요 없습니다. 객체를 복사할 때는 항상 같은 객체를 참조하는 주소만 반환하면 됩니다. 즉, 객체를 하나 생성하고 이를 지속적으로 재사용할 수 있습니다(Intern) 이처럼 불변 객체는 복사를 단순화할 수 있어 성능적으로 유리할 수 있습니다. 동일한 값을 여러번 복사해도 참조를 위한 포인터 크기 만큼만 메모리가 늘어날 뿐입니다.</p><p>또한 React.js의 <code>shouldComponentUpdate</code> 메서드를 통해 알 수 있듯이 비교문을 크게 단순화할 수 있습니다. 이 점이 React.js에서 불변 객체를 사용했을때 가장 피부로 체감할 수 있는 부분입니다. 단순한 비교문은 코드를 관리하기 쉽게 만들어줍니다. 반면, 가변 객체를 여러 뷰 컴포넌트에서 의존하면 이를 추적하고 관리하기 쉽지 않을 뿐더러 비교문도 작성하기 어렵습니다.</p><p><a href="https://facebook.github.io/flux" target="_blank" rel="noopener">Flux 아키텍처</a>에서 말하는 단방향 데이터 흐름과 Immutable.js의 불변 객체, 그리고 수동적인 뷰 특징을 가진 리액트 컴포넌트가 한데 어울어지면 보다 단순하고 사고하기 쉬운 프로그램을 작성할 수 있습니다.</p><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://ko.wikipedia.org/wiki/%EB%B6%88%EB%B3%80%EA%B0%9D%EC%B2%B4" target="_blank" rel="noopener">위키피디아:불변객체(한글)</a></li><li><a href="https://en.wikipedia.org/wiki/String_interning" target="_blank" rel="noopener">위키피디아:인턴(영어)</a></li><li><a href="http://wit.nts-corp.com/2015/03/04/3118" target="_blank" rel="noopener">7 Patterns to Refactor JavaScript Applications(한글)</a></li><li><a href="http://www.yes24.com/24/Goods/2824034?Acode=101" target="_blank" rel="noopener">켄트 벡의 구현 패턴</a></li></ul>]]></content>
    
    <summary type="html">
    
      불변객체(Immutable Object)의 개념과 React에 그 개념을 적용했을 때 어떤 이점을 얻을 수 있는지 소개합니다.
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
      <category term="React" scheme="http://blog.coderifleman.com/categories/JavaScript/React/"/>
    
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
      <category term="React" scheme="http://blog.coderifleman.com/tags/React/"/>
    
      <category term="Immutable Object" scheme="http://blog.coderifleman.com/tags/Immutable-Object/"/>
    
  </entry>
  
  <entry>
    <title>React.js를 이해하다(7)</title>
    <link href="http://blog.coderifleman.com/2015/07/12/learning-react-7/"/>
    <id>http://blog.coderifleman.com/2015/07/12/learning-react-7/</id>
    <published>2015-07-11T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[        <div class="alert alert--info">            <div class="alert__inner">                                    <div class="alert__title">                        <strong>읽기전에...</strong>                    </div>                                <div class="alert__body">                    <p>이 문서는 <a href="http://qiita.com/koba04" target="_blank" rel="noopener">koba04</a>님이 작성한 <a href="http://qiita.com/advent-calendar/2014/reactjs" target="_blank" rel="noopener">React.js Advent Calendar</a>를 번역한 것입니다. 본래 원문서는 캘린더 형식으로 소개하지만 여기에서는 회를 나눠 작성할 생각입니다. 또한, React 버전 0.12.1 때 작성된 문서이기 때문에 현 버전과 다른 점이 있을 수 있습니다. 최대한 다른 부분을 노트로 작성할 생각이지만, 만약 생략된 부분이 있다면 댓글로 알려주시면 감사하겠습니다.</p>                </div>            </div>        </div>    <h2 id="React-js-CSS"><a href="#React-js-CSS" class="headerlink" title="React.js + CSS"></a>React.js + CSS</h2><p>React.js 개발자인 <a href="https://twitter.com/vjeux" target="_blank" rel="noopener">vjeux</a>가 「<a href="https://speakerdeck.com/vjeux/react-css-in-js" target="_blank" rel="noopener">React:CSS in JS</a>」 라는 주제로 발표를 했는데 그 내용이 꽤 흥미있고 React.js와도 관계가 있는 것이기 때문에 소개하고자 합니다. 또다른 React.js 개발자 zpao의 「<a href="https://speakerdeck.com/zpao/react-through-the-ages" target="_blank" rel="noopener">React Through the Ages</a>」 라는 발표에서도 이 관점에 관해 언급하고 있습니다.</p><h3 id="CSS를-확장할-때의-문제점"><a href="#CSS를-확장할-때의-문제점" class="headerlink" title="CSS를 확장할 때의 문제점"></a>CSS를 확장할 때의 문제점</h3><ol><li>Global Namespace</li><li>Dependencies</li><li>Dead Code Elimination</li><li>Minification</li><li>Sharing Constantsn</li><li>Non-deterministic Resolution</li><li>Isolation</li></ol><p>여기에서 말하는 확장은 페이스북 정도의 규모에서 확장을 말하는 것 같습니다.</p><h4 id="Global-Namespace"><a href="#Global-Namespace" class="headerlink" title="Global Namespace"></a>Global Namespace</h4><p>CSS에서 모든 것은 글로벌 공간에 선언되기 때문에 명명 규칙 등으로 분할할 필요가 있습니다.(부트스트랩은 600개의 전역 이름을 정의하고 있습니다.)</p><h4 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h4><p>컴포넌트와의 의존 관계를 관리하기 힘듭니다. 컴포넌트 내에서 requireCSS 처럼 CSS를 읽어 들이도록 했다고 하더라도 다른 곳에서 이미 그 CSS를 require 했다면 이미 동작하게 됩니다.</p><h4 id="Dead-Code-Elimination"><a href="#Dead-Code-Elimination" class="headerlink" title="Dead Code Elimination"></a>Dead Code Elimination</h4><p>미사용 코드를 검출하기 어렵습니다.</p><h4 id="Minification"><a href="#Minification" class="headerlink" title="Minification"></a>Minification</h4><p>class 명의 minification에 관한 것입니다. (저자: 할 필요가 있는지 의문입니다) 이것도 템플릿(HTML or JS)과 CSS를 대응하여 개발할 필요가 있습니다.</p><h4 id="Sharing-Constantsn"><a href="#Sharing-Constantsn" class="headerlink" title="Sharing Constantsn"></a>Sharing Constantsn</h4><p>CSS와 JS 측에서 변수를 공유하기 어렵습니다.</p><h4 id="Non-deterministic-Resolution"><a href="#Non-deterministic-Resolution" class="headerlink" title="Non-deterministic Resolution"></a>Non-deterministic Resolution</h4><p>CSS에서는 상세한 속성이 같은 경우 나중에 작성한 것이 우선됩니다. 그래서 requireCSS 등의 구조를 사용해 컴포넌트와 같이 비동기로 CSS를 읽을 경우 읽는 순서에 따라 다르게 출력돼 의도하지 않는 결과가 발생할 수 있습니다.</p><pre><code class="language-html">&lt;div class="foo bar"&gt;xxx&lt;/div&gt;</code></pre><pre><code class="language-css">.foo {color: red}.bar {color: blue}/* or */.bar {color: blue}.foo {color: red}</code></pre><p>이를 회피하기 위해서 상세한 속성을 수정하는 등의 작업이 필요할 수 있습니다.</p><h4 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h4><p>React.js에서 Button 컴포넌트를 만들었을 때 이 button 태그의 스타일을 지정하려면 Button 컴포넌트가 어떤 태그 구조로 구현돼 있는지를 알아야 할 필요가 있어 컴포넌트를 잘 분리 할 수 없습니다.</p><pre><code class="language-html">&lt;div className="foo"&gt;  &lt;Button/&gt; &lt;!-- &lt;div&gt;&lt;button&gt;xxx&lt;/button&gt;&lt;/div&gt; --&gt;&lt;/div&gt;</code></pre><pre><code class="language-css">.foo &gt; div {  ...}</code></pre><h3 id="그렇다면-CSS-in-JS"><a href="#그렇다면-CSS-in-JS" class="headerlink" title="그렇다면 CSS in JS"></a>그렇다면 CSS in JS</h3><p>위와 같은 문제는 Sass 같은 CSS Preprocessor 등을 사용하거나 설계 레벨에서 해결 가능한 것도 있지만, CSS를 JavaScript의 Object 형태로 컴포넌트의 스타일을 지정하는데 사용하면 문제를 해결할 수 있지 않을까 하는 접근법입니다. 즉, 템플릿(HTML)을 JS의 안에 가지고 온 것(JSX)처럼 CSS도 JS 안으로 가지고 오겠다는 뜻입니다.</p><pre><code class="language-js">var style = {  container: {    backgroundColor: '#ddd',    width: 900  }}var Container = React.createClass({  render() {    return &lt;div style={style.container}&gt;{this.props.children}&lt;/div&gt;;  }});</code></pre><p>아래와 같은 함수를 이용하면 조금 더 유연하게 스타일을 지정할 수 있습니다.</p><pre><code class="language-jsx">function m() {  var res = {};  for (var i=0; i &lt; arguments.length; ++i) {    if (arguments[i]) assign(res, arguments[i]);  }  return res;}&lt;div style={m(  style.container,  { marginTop: 10 },  this.props.isWarning && {color: 'red'})}&gt;xxx&lt;/div&gt;</code></pre><p>또, Prop을 공개해 밖에서 스타일을 지정하도록 할 수 있습니다.</p><pre><code class="language-jsx">propTypes: {  style: React.PropTypes.object},render() {  return &lt;div style={m(style.container, this.props.style)}&gt;xxx&lt;/div&gt;}</code></pre><p>스타일의 우선 순위는 순서를 조절하는 것으로 간단히 변경할 수 있습니다.</p><pre><code class="language-jsx">propTypes: {  style: React.PropTypes.object},render() {  return &lt;div style={m(this.props.style, style.container)}&gt;xxx&lt;/div&gt;}</code></pre><p>이처럼 컴포넌트에 직접 지정하는 것으로 상세한 속성 등은 알 필요 없어지고 JavaScript에 가져오는 것으로 프로그래밍적으로 처리 가능하며 공통화나 상속 등도 간단히 실현할 수 있어 그 결과 처음에 언급한 여러가지 문제를 해결할 수 있습니다. 예에서는 스타일을 컴포넌트의 안에 작성했지만 다른 파일에 작성하고 require 해서 사용할 수도 있습니다. </p><p>JavaScript 쪽으로 마크업을 가지고 온 JSX 처럼 CSS도 JavaScript로 가져오자는 이 접근에 관해 어떻게 생각하시나요? 여기까지 CSS in JS를 소개했습니다.</p><h2 id="React-js-in-future"><a href="#React-js-in-future" class="headerlink" title="React.js in future"></a>React.js in future</h2><p>React.js의 향후라는 주제로 이번 절을 작성할까 합니다. React.js의 로드맵은 facebook/react와는 다른 저장소 인 <a href="https://github.com/reactjs/react-future" target="_blank" rel="noopener">react-future</a>에서 논의되고 있습니다. 여기에 있는 것은 어디까지나 아이디어 수준이지만 구체적인 코드로 설명돼 있어서 어떤 모습일지 예측하기 쉽습니다.</p><p>또, 이전 절에서도 소개했던 「React Through the Ages」 슬라이드에서도 React.js의 현재와 미래에 대해서 이야기하고 있으므로 참고하세요.</p><h3 id="지금까지의-React-js"><a href="#지금까지의-React-js" class="headerlink" title="지금까지의 React.js"></a>지금까지의 React.js</h3><p>React.js는 원래 페이스북이 PHP + XML로 만든 <a href="https://github.com/facebook/xhp-lib" target="_blank" rel="noopener">XHP</a> 프로젝트에서 시작됐습니다. 이를 JavaScript에 가져온 것이 React.js입니다. 애플리케이션 전체적으로 rerender 하는 구조는 서버 측의 rendering 방식과 비슷하다는 점에서도 이런 흐름을 예측할 수 있습니다. 또, React.js는 최초엔 <a href="https://ja.wikipedia.org/wiki/Standard_ML" target="_blank" rel="noopener">Standard ML</a>로 만들어졌다가 그 뒤 Haxe가 되어 지금의 Pure한  JavaScript가 됐습니다.</p><h3 id="1-0과-그-앞"><a href="#1-0과-그-앞" class="headerlink" title="1.0과 그 앞"></a>1.0과 그 앞</h3><p>「React Through the Ages」를 보면 API의 안정화와 삭제 그리고 ES6, 7 사양을 따르려고 하는 의도를 느낄 수 있습니다. ES6, 7에서 사용할 수 있는 기능을 최대한 활용하여 React.js 자체에서는 부가적인 처리를 하지 않겠다는 방향성을 엿볼 수 있습니다.</p><pre><code class="language-jsx">class Button extends React.Component {  getInitialState() {    return {count: 0};  },  render() {    return (      &lt;button onClick={() =&gt; this.setState({count: this.state.count + 1}) }&gt;        {this.state.count}      &lt;/button&gt;    );  }}</code></pre><ul><li><strong>CSS in JS</strong> : 이는 이전 절에서 소개한 CSS의 문제를 해결하기 위한 접근 방식입니다.</li><li><strong>Web Workers</strong> : VirtualDOM 계산을 WebWorkers에서 하는 것으로 UI 단에 좋은 영향을 줄 수 있다면 도입하고 싶다고 합니다.</li><li><strong>Layout &amp; Animation</strong> : 어떠한 방식으로 정의하도록 하느냐가 어려운 문제이지만 중요한 기능이기 때문에 지원하고 싶다고 합니다.</li><li><strong>M(V)C</strong> : 자신(페이스북)은 필요하지 않지만 많은 개발자가 React.js를 사용했을 때의 MVC의 M과 C에 대해 논의하거나 개발하고 있는 것을 보고 이에 대한 지원도 중요한 사항으로 여기는 것 같습니다. React.js가 풀-프레임워크가 되는 일은 없을 것 같습니다만…</li><li><strong>Other</strong> : 이 외에도 새로운 테스트 지원이나 문서, Immutable Data 등 다양한 아이디어가 있는 것 같습니다.</li></ul><h3 id="React-js의-미래"><a href="#React-js의-미래" class="headerlink" title="React.js의 미래"></a>React.js의 미래</h3><p>react-future의 저장소를 보면 ES6, 7의 기능을 도입할 경우의 형태를 볼 수 있습니다. 단, 여기에서 소개하는 기능은 아직 구현돼 있지 않고 합의된 것도 아니기 때문에 이렇게 지원된다고 장담할 순 없습니다.</p>        <div class="alert alert--info">            <div class="alert__inner">                                    <div class="alert__title">                        <strong>역자노트</strong>                    </div>                                <div class="alert__body">                    <p>일부 기능은 이미 사용할 수 있습니다. 원문이 2014년 12월에 작성됐다는 사실을 감안해주세요.</p>                </div>            </div>        </div>    <h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><pre><code class="language-jsx">import {Component} from 'react';export class Button extends Component {  props : {    width: number  }  static defaultProps = {    width: 100  }  state = {    counter: Math.round(this.props.width / 10)  }  handleClick = (event) =&gt; {    event.preventDefault();    this.setState({counter: this.state.counter + 1});  }  render(props, state) {    return (      &lt;div&gt;        This button has been clicked: {state.counter} times        &lt;button onClick={this.handleClick} style={{ idth: props.width}}/&gt;      &lt;/div&gt;    );  }}</code></pre><p>ES6의 Module이나 Class, ArrowFunction 등이 사용됐고 React.js 독자적인 부분이 적어졌습니다. 또 props의 형 지정 방식도 변경 됐는데 이는 facebook/flow와 연계될 수도 있을 것 같습니다. (댓글에는 TypeScript compatible syntax로 작성돼 있지만) 또, render에 props와 state를 인자로 전달하는 것 같은 형태로 돼 있습니다.</p><h4 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h4><pre><code class="language-jsx">import { mixin } from 'react-utils';const A = {  componentDidMount() {    super();    console.log('A');  }};class B extends mixin(A) {  componentDidMount() {    console.log('B');    super();  }}new B().componentDidMount(); // B, Aimport { Component } from 'react';class Component extends mixin(Component, C) {  render() {    return &lt;div/&gt;;  }}</code></pre><p>mixin은 util로써 준비하고, super로 부모의 것을 호출하는 식으로 디자인돼 있습니다. state의 merge 방식에 관한 문제가 있는 것 같습니다.</p><h4 id="Stateless-Functions"><a href="#Stateless-Functions" class="headerlink" title="Stateless Functions"></a>Stateless Functions</h4><pre><code class="language-jsx">export function Button(props : {width: number, onClick: function}) {  return (    &lt;div&gt;      Fancy button      &lt;button onClick={props.onClick} style={{width: props.width}}/&gt;    &lt;/div&gt;  );}</code></pre><p>Prop 만을 갖는 Stateless한 컴포넌트는 Prop을 전달받는 함수로써 정의할 수 있도록 돼 있습니다.</p><h4 id="Elements"><a href="#Elements" class="headerlink" title="Elements"></a>Elements</h4><p>JavaScript 객체 문법이나 JSX 이외에도 여러가지 방법으로 React Element를 작성할 수 있도록 하고자 하는 바램이 있는 것 같습니다.</p><h5 id="Object-리터럴"><a href="#Object-리터럴" class="headerlink" title="Object 리터럴"></a>Object 리터럴</h5><pre><code class="language-jsx">{  type: Button,  props: {    foo: bar,    children: [      { type: 'span', props: { children: a } },      { type: 'span', props: { children: b } }    ]  },  // optional  key: 'mybutton',  ref: myButtonRef}</code></pre><h5 id="Native-Components"><a href="#Native-Components" class="headerlink" title="Native Components"></a>Native Components</h5><p>React.DOM 이하의 API는 없어지고 단순한 문자열로 정의할 수 있도록 돼 있습니다. 또 Web Components의 커스텀 태그에도 호환성을 지니게 돼 있습니다.</p><h5 id="Template-Strings"><a href="#Template-Strings" class="headerlink" title="Template Strings"></a>Template Strings</h5><p>ES6의 Template Strings을 이용해 정의할 수 있도록 돼 있습니다.</p><pre><code class="language-jsx">X` &lt;my-button foo=${bar} key="mybutton" ref=${myButtonRef}&gt;   &lt;span&gt;${a}&lt;/span&gt;   &lt;span&gt;${b}&lt;/span&gt; &lt;/my-button&gt;`</code></pre><p>이외에도 여러가지 소개하고 있으므로 흥미가 있다면 꼭 한번 읽어보시길 바랍니다.</p><h2 id="React-js에-관한-리소스-그리고-정리"><a href="#React-js에-관한-리소스-그리고-정리" class="headerlink" title="React.js에 관한 리소스, 그리고 정리"></a>React.js에 관한 리소스, 그리고 정리</h2><p>여기까지 React.js를 소개했습니만, 조금이라도 사용하는데 참고가 됐다면 좋겠습니다. React.js는 facebook, instagram이나 Github의 AtomEditor 물론, 「Atlassian」, 「Netflix」, 「Reddit」, 「The New York Times」, 「Yahoo」 등 많은 곳에서 사용하고 있는 것 같습니다(<a href="https://github.com/facebook/react/wiki/Sites-Using-React" target="_blank" rel="noopener">참고</a>).</p><p>또, 내년 1월말에는 <a href="http://conf.reactjs.com/" target="_blank" rel="noopener">React.js Conf</a>가 있으므로 여러가지 소식이 공유되고 점점 분위기도 무르익을 것으로 생각됩니다. 내년도 즐거운 한해가 될 것 같습니다.</p><p>React.js의 <a href="http://facebook.github.io/react/blog/" target="_blank" rel="noopener">공식 블로그</a>나 <a href="https://twitter.com/hashtag/reactjs?f=realtime&amp;src=hash" target="_blank" rel="noopener">#reactjs</a> 해쉬 태그를 구독하면 여러가지 정보를 모을 수 있습니다.</p><h3 id="리소스-정리"><a href="#리소스-정리" class="headerlink" title="리소스 정리"></a>리소스 정리</h3><p>개인적으로 읽고 재미있었던 것이나 공식적인 사이트를 정리해봤습니다.</p><h4 id="공식-사이트"><a href="#공식-사이트" class="headerlink" title="공식 사이트"></a>공식 사이트</h4><ul><li><a href="http://facebook.github.io/react/" target="_blank" rel="noopener">공식 홈페이지</a>(<a href="http://reactkr.github.io/react/index.html" target="_blank" rel="noopener">한국어</a>)</li><li><a href="http://facebook.github.io/flux/" target="_blank" rel="noopener">Flux</a></li><li><a href="https://github.com/facebook/react/wiki/Complementary-Tools" target="_blank" rel="noopener">Complementary Tools</a></li><li><a href="http://facebook.github.io/immutable-js/" target="_blank" rel="noopener">Immutable.js</a></li><li><a href="http://facebook.github.io/jest/" target="_blank" rel="noopener">Jest</a></li></ul><h4 id="컴포넌트-샘플-모음집"><a href="#컴포넌트-샘플-모음집" class="headerlink" title="컴포넌트, 샘플 모음집"></a>컴포넌트, 샘플 모음집</h4><ul><li><a href="http://react-components.com/" target="_blank" rel="noopener">React Coponents</a>: 공개된 React.js 컴포넌트가 정리돼 있습니다.</li><li><a href="http://react.rocks/" target="_blank" rel="noopener">React Rocks</a>: React.js의 샘플이나 데모가 모여있습니다.</li></ul><h4 id="입문"><a href="#입문" class="headerlink" title="입문"></a>입문</h4><ul><li><a href="https://scotch.io/tutorials/learning-react-getting-started-and-concepts" target="_blank" rel="noopener">Learning React.js: Getting Started and Concepts</a>: React.js를 사용하여 앱을 만드는 과정을 순차적으로 쉽게 설명하고 있습니다.</li><li><a href="http://www.slideshare.net/AndrewHull/react-js-and-why-its-awesome" target="_blank" rel="noopener">React JS and why it’s awesome</a>: React.js의 장점이 잘 설명돼 있습니다.</li></ul><h4 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h4><ul><li><a href="https://speakerdeck.com/vjeux/oscon-react-architecture" target="_blank" rel="noopener">OSCON - React Architecture</a>: 페이스북 개발자가 설명하는 React.js의 VirualDOM 구현 단의 이야기 입니다.</li><li><a href="http://slides.com/danabramov/components-react-flux-wip#/" target="_blank" rel="noopener">Components, React and Flux</a>: React.js와 Flux를 코드와 함께 이해하기 쉽게 설명하고 있습니다.</li></ul><h4 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h4><ul><li><a href="https://speakerdeck.com/mridgway/isomorphic-flux" target="_blank" rel="noopener">Isomorphic Flux</a>: Yahoo가 Isomorphic한 Flux 애플리케이션을 만든 이야기입니다.</li><li><a href="https://speakerdeck.com/fisherwebdev/flux-meetup" target="_blank" rel="noopener">flux-meetup</a>: 페이스북의 개발자가 하는 React.js와 Flux에 관한 설명입니다.</li></ul><h4 id="Developer-tool"><a href="#Developer-tool" class="headerlink" title="Developer tool"></a>Developer tool</h4><p>소개하는 것을 깜빡 잊고 있었습니다. React.js 개발을 할 때에 편리하게 사용할 수 있는 크롬 확장 도구인 <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="noopener">React Developer Tools</a>도 있습니다.</p><p>아래 그림과 같이 React.js를 사용하는 페이지에 가면 개발자 도구에 React탭이 표시되고 거기서 HTML의 태그가 아니라 Component로 볼 수 있습니다. 또, Prop과 State및 EventListener와 Component의 값도 확인 할 수 있어 편리하게 디버깅할 수 있습니다.</p>        <figure title="React Developer Tools">          <img src="/assets/img/2015/learning-react-7/react_debugging_tool.01.png" alt="React Developer Tools" style="">          <figcaption>&lt;그림 1 React Developer Tools&gt;</figcaption>        </figure>    <h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><p>역시 읽을 때와 번역해서 공유할 때 느낌은 많이 다르네요. 알아서 이해했던 것들도 신경 써야 하니 시간이 좀 걸렸습니다.  koba04님의 React.js Advent Calendar는 제가 처음 React.js를 학습할때 도움을 받았던 문서였기 때문에 무엇부터 차근차근 봐야 할지 모르시는 분들이 있을 것 같아서 일본어 문서를 번역했습니다. React.js를 이해하는데 많은 도움이 되길 간절히 바라면서 이만 마치도록 하겠습니다.</p><p>여기까지 React.js를 소개했습니다. 끝까지 읽어주셔서 감사합니다!</p>]]></content>
    
    <summary type="html">
    
      일본의 개발자 koba04님이 작성한 React.js Advent Calendar를 번역한 글로, React.js를 보다 쉽게 접근하고 이해하기 쉽게 설명합니다. 이 글은 시리즈로 작성됐으며 이 문서는 그 중 마지막 편입니다.
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/categories/JavaScript/"/>
    
      <category term="React" scheme="http://blog.coderifleman.com/categories/JavaScript/React/"/>
    
    
      <category term="JavaScript" scheme="http://blog.coderifleman.com/tags/JavaScript/"/>
    
      <category term="React" scheme="http://blog.coderifleman.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React.js를 이해하다(6)</title>
    <link href="http://blog.coderifleman.com/2015/07/11/learning-react-6/"/>
    <id>http://blog.coderifleman.com/2015/07/11/learning-react-6/</id>
    <published>2015-07-10T15:00:00.000Z</published>
    <updated>2017-12-18T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[        <div class="alert alert--info">            <div class="alert__inner">                                    <div class="alert__title">                        <strong>읽기전에...</strong>                    </div>                                <div class="alert__body">                    <p>이 문서는 <a href="http://qiita.com/koba04" target="_blank" rel="noopener">koba04</a>님이 작성한 <a href="http://qiita.com/advent-calendar/2014/reactjs" target="_blank" rel="noopener">React.js Advent Calendar</a>를 번역한 것입니다. 본래 원문서는 캘린더 형식으로 소개하지만 여기에서는 회를 나눠 작성할 생각입니다. 또한, React 버전 0.12.1 때 작성된 문서이기 때문에 현 버전과 다른 점이 있을 수 있습니다. 최대한 다른 부분을 노트로 작성할 생각이지만, 만약 생략된 부분이 있다면 댓글로 알려주시면 감사하겠습니다.</p>                </div>            </div>        </div>    <h2 id="React-js의-테스트"><a href="#React-js의-테스트" class="headerlink" title="React.js의 테스트"></a>React.js의 테스트</h2><p>이번에는 React.js 환경에서 테스트하는 방법을 소개하겠습니다.</p><h3 id="React-js와-테스트"><a href="#React-js와-테스트" class="headerlink" title="React.js와 테스트"></a>React.js와 테스트</h3><p>React.js는 컴포넌트에 대응하여 테스트를 작성해야 하므로 DOM을 의존하여 힘들 것으로 예상하지만 React.addons.TestUtils라는 Addon이 테스트에 편리한 함수를 제공하고 있으므로 이를 이용하면 더 쉽게 테스트를 작성할 수 있습니다.</p><h3 id="DOM이-필요할까"><a href="#DOM이-필요할까" class="headerlink" title="DOM이 필요할까?"></a>DOM이 필요할까?</h3><p>React.js 컴포넌트는 서버-사이드에서도 사용할 수 있으므로 node.js 환경에서 테스트를 작성하고 싶을 수 있지만 onClick이나 onKeyUp 같은 이벤트에 실제로 반응하는지 테스트하기 위해서 DOM이 필요합니다. 단순히 Prop 값을 전달하고 renderToStaticMarkup을 사용하여 결괏값인 HTML을 테스트하는 경우엔 node.js 환경에서 작성할 수 있습니다.</p><h3 id="이벤트-시뮬레이트"><a href="#이벤트-시뮬레이트" class="headerlink" title="이벤트 시뮬레이트"></a>이벤트 시뮬레이트</h3><p>「버튼을 클릭하면」이라는 테스트를 작성하고자 할 때 DOM을 셀렉트하고 값을 설정하여 이벤트를 발생시키는 일련의 과정이 필요하지만, React.addons.TestUtils.Simulate를 사용하면 DOM을 지정하고, 전달하고 싶은 이벤트 객체의 형식을 지정할 수 있으므로 격식없이 사용자 액션 테스트를 작성할 수 있습니다.</p><pre><code class="language-js">Simulate.{eventName}(DOMElement element, object eventData)</code></pre><pre><code class="language-js">var node = this.refs.input.getDOMNode();React.addons.TestUtils.Simulate.click(node);// 전달하고자 하는 이벤트 객체를 지정한다.React.addons.TestUtils.Simulate.change(node, {target: {value: 'Hello, world'}});React.addons.TestUtils.Simulate.keyDown(node, {key: 'Enter'});</code></pre><h3 id="컴포넌트-작성-지원"><a href="#컴포넌트-작성-지원" class="headerlink" title="컴포넌트 작성 지원"></a>컴포넌트 작성 지원</h3><h4 id="renderIntoDocument"><a href="#renderIntoDocument" class="headerlink" title="renderIntoDocument"></a>renderIntoDocument</h4><p>renderIntoDocument를 사용하면 DOM에 컴포넌트를 실제로 추가하지 않아도 테스트할 수 있습니다. 아래 예제를 보면 일단 renderintoDocument가 컴포넌트를 DOM에 추가해 나갈 것으로 보입니다.</p><pre><code class="language-jsx">var Hello = require('./components/hello');var component = React.addons.TestUtils.renderIntoDocument(&lt;Hello name="foo" /&gt;);</code></pre><p>하지만 이것은 실제 DOM 트리에 추가되는 것이 아니라 document.createElement로 생성한 div에 render 할 뿐입니다. 그래서 요소의 실제 높이나 너비 등은 알 수 없습니다. (이름이 다소 혼란스럽기 때문에 변경될 수 있을 것 같습니다)</p><h4 id="mockComponent"><a href="#mockComponent" class="headerlink" title="mockComponent"></a>mockComponent</h4><p>Jest를 사용하고 있을 때 mock 컴포넌트에서 더미로 <code>&lt;div/&gt;</code>(엘리먼트 요소)를 반환하도록 하는 mockComponent도 있습니다. 이 함수를 사용하기 위해서는<code>component.prototype.render.mockImplementation</code>이 작성되어야 하는데 Jest를 고려한 함수(<a href="http://facebook.github.io/jest/docs/api.html#mockfn-mockimplementation-fn" target="_blank" rel="noopener">mockFn.mockImplementation(fn)</a>) 인듯합니다. 자주 쓰일지 모르겠습니다만, 보통 Mock으로 작성한 컴포넌트에서 render를 동작시키고 싶을 때 사용하는 듯합니다.</p><pre><code class="language-js">mockComponent: function(module, mockTagName) {  mockTagName = mockTagName || module.mockTagName || 'div';  module.prototype.render.mockImplementation(function() {    return React.createElement(      mockTagName,      null,      this.props.children    );  });  return this;},</code></pre><h3 id="컴포넌트-셀렉트"><a href="#컴포넌트-셀렉트" class="headerlink" title="컴포넌트 셀렉트"></a>컴포넌트 셀렉트</h3><h4 id="findAllInRenderedTree-ReactComponent-tree-function-test"><a href="#findAllInRenderedTree-ReactComponent-tree-function-test" class="headerlink" title="findAllInRenderedTree(ReactComponent tree, function test)"></a>findAllInRenderedTree(ReactComponent tree, function test)</h4><p>특정 컴포넌트의 하위 컴포넌트 중에서 지정한 함수의 조건을 충족한 컴포넌트만 배열로 반환합니다. 아래에서 소개할 함수를 사용할 수 없는 경우에 사용할 수 있는 가장 기본적인 구현입니다.</p><pre><code class="language-jsx">console.log(  React.addons.TestUtils.findAllInRenderedTree(    React.render(&lt;div&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;p&gt;baz&lt;/p&gt;&lt;/div&gt;, document.body),    function(component) { return component.tagName === 'SPAN' }  ).map(function(component){ return component.getDOMNode().textContent })); // ['foo', 'bar']</code></pre><h4 id="scryRenderedDOMComponentsWithClass-ReactComponent-tree-string-className"><a href="#scryRenderedDOMComponentsWithClass-ReactComponent-tree-string-className" class="headerlink" title="scryRenderedDOMComponentsWithClass(ReactComponent tree, string className)"></a>scryRenderedDOMComponentsWithClass(ReactComponent tree, string className)</h4><p>특정 컴포넌트의 하위 컴포넌트 중, 지정한 className에 해당하는 컴포넌트를 배열로 반환합니다.</p><pre><code class="language-jsx">console.log(  React.addons.TestUtils.scryRenderedDOMComponentsWithClass(    React.render(      &lt;div&gt;        &lt;span className="foo"&gt;foo1&lt;/span&gt;        &lt;span className="foo"&gt;foo2&lt;/span&gt;        &lt;span className="bar"&gt;barbar&lt;/span&gt;      &lt;/div&gt;,      document.body    ),    'foo'  ).map(function(component){ return component.getDOMNode().textContent })); // ['foo1', 'foo2']</code></pre><h4 id="findRenderedDOMComponentWithClass-ReactComponent-tree-string-className"><a href="#findRenderedDOMComponentWithClass-ReactComponent-tree-string-className" class="headerlink" title="findRenderedDOMComponentWithClass(ReactComponent tree, string className)"></a>findRenderedDOMComponentWithClass(ReactComponent tree, string className)</h4><p>특정 컴포넌트의 하위 컴포넌트 중, 지정한 className에 해당하는 컴포넌트를 1개만 반환합니다.</p><pre><code class="language-jsx">console.log(  React.addons.TestUtils.findRenderedDOMComponentWithClass(    React.render(      &lt;div&gt;        &lt;span className="foo"&gt;foo1&lt;/span&gt;        &lt;span className="foo2"&gt;foo2&lt;/span&gt;        &lt;span className="bar"&gt;barbar&lt;/span&gt;      &lt;/div&gt;,      document.body    ),    'foo'  ).getDOMNode().textContent); // ['foo1']</code></pre><p>해당하는 컴포넌트가 없거나 여러개가 매치되면 오류를 발생시킵니다.</p><pre><code class="language-jsx">console.log(  React.addons.TestUtils.findRenderedDOMComponentWithClass(    React.render(      &lt;div&gt;        &lt;span className="foo"&gt;foo1&lt;/span&gt;        &lt;span className="foo"&gt;foo2&lt;/span&gt;        &lt;span className="bar"&gt;barbar&lt;/span&gt;      &lt;/div&gt;,      document.body    ),    'foo'  ).getDOMNode().textContent); //  Uncaught Error: Did not find exactly one match for class:foo</code></pre><h4 id="scryRenderedDOMComponentsWithTag-ReactComponent-tree-string-tagName"><a href="#scryRenderedDOMComponentsWithTag-ReactComponent-tree-string-tagName" class="headerlink" title="scryRenderedDOMComponentsWithTag(ReactComponent tree, string tagName)"></a>scryRenderedDOMComponentsWithTag(ReactComponent tree, string tagName)</h4><p>특정 컴포넌트의 하위 컴포넌트 중, 지정한 태그 네임에 해당하는 컴포넌트를 배열로 반환합니다.</p><pre><code class="language-jsx">console.log(  React.addons.TestUtils.scryRenderedDOMComponentsWithTag(    React.render(      &lt;div&gt;        &lt;span&gt;foo1&lt;/span&gt;        &lt;span&gt;foo2&lt;/span&gt;        &lt;p&gt;barbar&lt;/p&gt;      &lt;/div&gt;,      document.body    ),    'span'  ).map(function(component){ return component.getDOMNode().textContent })); // ['foo1', 'foo2']</code></pre><h4 id="findRenderedDOMComponentWithTag-ReactComponent-tree-string-tagName"><a href="#findRenderedDOMComponentWithTag-ReactComponent-tree-string-tagName" class="headerlink" title="findRenderedDOMComponentWithTag(ReactComponent tree, string tagName)"></a>findRenderedDOMComponentWithTag(ReactComponent tree, string tagName)</h4><p>특정 컴포넌트의 하위 컴포넌트 중, 지정한 className에 해당하는 컴포넌트를 1개만 반환합니다. 해당하는 컴포넌트가 없거나 여러개가 매치되면 오류를 발생시킵니다.</p><pre><code class="language-jsx">console.log(  React.addons.TestUtils.findRenderedDOMComponentWithTag(    React.render(      &lt;div&gt;        &lt;span&gt;foo1&lt;/span&gt;        &lt;span&gt;foo2&lt;/span&gt;        &lt;p&gt;barbar&lt;/p&gt;      &lt;/div&gt;,      document.body    ),    'p'  ).getDOMNode().textContent); // barbar</code></pre><h4 id="scryRenderedComponentsWithType-ReactComponent-tree-function-componentClass"><a href="#scryRenderedComponentsWithType-ReactComponent-tree-function-componentClass" class="headerlink" title="scryRenderedComponentsWithType(ReactComponent tree, function componentClass)"></a>scryRenderedComponentsWithType(ReactComponent tree, function componentClass)</h4><p>특정 컴포넌트의 하위 컴포넌트 중, 지정한 컴포넌트의 인스턴스에 해당하는 컴포넌트를 배열로 반환합니다.</p><pre><code class="language-jsx">console.log(  React.addons.TestUtils.scryRenderedComponentsWithType(    React.render(      &lt;div&gt;        &lt;Hello name="foo" key="foo" /&gt;        &lt;Hello name="bar" key="bar" /&gt;        &lt;span&gt;xxx&lt;/span&gt;        &lt;p&gt;zzz&lt;/p&gt;      &lt;/div&gt;,      document.body    ),    Hello  ).map(function(component){ return component.getDOMNode().textContent })); // ['foo', 'bar']</code></pre><h4 id="findRenderedComponentWithType-ReactComponent-tree-function-componentClass"><a href="#findRenderedComponentWithType-ReactComponent-tree-function-componentClass" class="headerlink" title="findRenderedComponentWithType(ReactComponent tree, function componentClass)"></a>findRenderedComponentWithType(ReactComponent tree, function componentClass)</h4><p>특정 컴포넌트의 하위 컴포넌트 중, 지정한 컴포넌트의 인스턴스에 해당하는 컴포넌트를 1개만 반환합니다. 해당하는 컴포넌트가 없거나 여러개가 매치되면 오류를 발생시킵니다.</p><pre><code class="language-jsx">console.log(  React.addons.TestUtils.findRenderedComponentWithType(    React.render(      &lt;div&gt;        &lt;Hello name="foo" key="foo" /&gt;        &lt;span&gt;xxx&lt;/span&gt;      &lt;/div&gt;,      document.body    ),    Hello  ).getDOMNode().textContent); // foo</code></pre><h3 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h3><p>React 컴포넌트의 상태를 확인하기 위한 함수들의 모음입니다.</p><h4 id="isElementOfType-ReactElement-element-function-componentClass"><a href="#isElementOfType-ReactElement-element-function-componentClass" class="headerlink" title="isElementOfType(ReactElement element, function componentClass)"></a>isElementOfType(ReactElement element, function componentClass)</h4><p>특정 컴포넌트가 지정한 컴포넌트의 인스턴스에 해당하는지를 판단합니다.</p><pre><code class="language-jsx">React.addons.TestUtils.isElementOfType(&lt;Hello /&gt;, Hello);</code></pre><h4 id="isDOMComponent-ReactComponent-instance"><a href="#isDOMComponent-ReactComponent-instance" class="headerlink" title="isDOMComponent(ReactComponent instance)"></a>isDOMComponent(ReactComponent instance)</h4><p>특정 컴포넌트가 div나 span과 같은 DOM 컴포넌트인지 판단합니다.</p><pre><code class="language-jsx">React.addons.TestUtils.isDOMComponent(  React.render(&lt;div /&gt;, document.body));</code></pre><h4 id="isCompositeComponent-ReactComponent-instance"><a href="#isCompositeComponent-ReactComponent-instance" class="headerlink" title="isCompositeComponent(ReactComponent instance)"></a>isCompositeComponent(ReactComponent instance)</h4><p>특정 컴포넌트가 React.createClass에 의해 정의된 컴포넌트를 포함해 작성된 것인지 판단합니다. div나 span 등은 포함하지 않습니다.</p><pre><code class="language-jsx">React.addons.TestUtils.isCompositeComponent(  React.render(&lt;Hello /&gt;, document.body));</code></pre><h4 id="isCompositeComponentWithType-ReactComponent-instance-function-componentClass"><a href="#isCompositeComponentWithType-ReactComponent-instance-function-componentClass" class="headerlink" title="isCompositeComponentWithType(ReactComponent instance, function componentClass)"></a>isCompositeComponentWithType(ReactComponent instance, function componentClass)</h4><p>특정 컴포넌트가 지정한 Component 타입을 포함해 작성된 것인지 판단합니다.</p><pre><code class="language-jsx">React.addons.TestUtils.isCompositeComponentWithType(  React.render(&lt;Hello /&gt;, document.body), Hello);</code></pre><h4 id="isTextComponent-ReactComponent-instance"><a href="#isTextComponent-ReactComponent-instance" class="headerlink" title="isTextComponent(ReactComponent instance)"></a>isTextComponent(ReactComponent instance)</h4><p>특정 컴포넌트가 텍스트 컴포넌트를 반환하는지 판단합니다.</p><pre><code class="language-js">var textComponents = React.addons.TestUtils.findAllInRenderedTree(  React.render(    &lt;div&gt;{'hello'}{'react'}&lt;/div&gt;,    document.body  ),  function(component) {    return React.addons.TestUtils.isTextComponent(component)  } );console.log(textComponents[0].props + ' ' + textComponents[1].props);// hello react</code></pre><p>여기까지 TestUtils의 종류와 사용 방법을 설명했습니다. 다음 절에서는 페이스북이 만들고 배포한 테스트 프레임워크인 Jest와 조합하는 방법을 소개하고자 합니다.</p><h2 id="React-js와-Jest"><a href="#React-js와-Jest" class="headerlink" title="React.js와 Jest"></a>React.js와 Jest</h2><p>이전에는 TestUtils를 사용하는 방법을 중심으로 설명했습니다. 이번에는 facebook이 개발하고 있는 Jest라고 하는 프레임워크와 함께 구성해 보고자 합니다.</p><h3 id="Painless-JavaScript-Unit-Testing"><a href="#Painless-JavaScript-Unit-Testing" class="headerlink" title="Painless JavaScript Unit Testing"></a>Painless JavaScript Unit Testing</h3><p>Jest는 공식 홈페이지에서 「Painless JavaScript Unit Testing」 문구를 대표적으로 소개하고 있으며 도입하기 쉽다는 특징을 가지고 있습니다. 그 특징으로는 「Mock By Default」가 있는데 기본적으로 Jest에서는 CommonJS Style의 require 구문이 Mock을 반환하도록 설정합니다. 조금 과격한 느낌입니다만 테스트 대상이 되는 동작에만 민감한 테스트를 간단하게 작성할 수 있습니다. 반대로 테스트 대상 이 외는 모두 Mock으로 대체 되므로 인터페이스 밖에 테스트 할 수 없지만, 그것은 Unit Test의 범위 밖으로 볼 수 있어서 큰 문제가 되지 않습니다.</p><h3 id="Jasmine"><a href="#Jasmine" class="headerlink" title="Jasmine"></a>Jasmine</h3><p>Jest는 Jasmine을 기반으로 만들어졌습니다. 따라서 Assert 등과 같은 기본적인 문법은 Jasmine과 같습니다. 단, Jasmine 2.0에서 비동기 테스트를 작성하기 보다 쉬워졌지만 1.3을 기반으로 하고 있어 이를 이용할 수 없습니다(<a href="https://github.com/facebook/jest/issues/74" target="_blank" rel="noopener">issues/74</a>).</p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p>Jest는 jsdom으로 생성한 DOM 위에서 실행되므로 Node.js 환경처럼 CLI로 테스트를 실행할 수 있습니다. 즉, Jest를 사용하면 Karma 같은 Test Runner를 사용할 필요가 없으므로 간단하게 도입할 수 있습니다.</p><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>jest-cli만 설치하면 됩니다.</p><pre><code class="language-bash">$ npm install --save-dev jest-cli</code></pre><h3 id="tests"><a href="#tests" class="headerlink" title="tests"></a>tests</h3><p>기본적으로 <strong>tests</strong> 디렉터리를 찾습니다. 그리고 그 디렉터리 내의 파일을 테스트로써 실행합니다. 따라서 Getting Started에서도 알 수 있듯이 <strong>tests</strong> 디렉터리를 내에 테스트 파일를 두고 jest를 실행하면 테스트가 진행됩니다. 만약 jest-cli를 전역이 아닌 devDependencies에 설치한다면 package.json의 scripts 프로퍼티에 npm test로 실행할 수 있도록 아래처럼 작성하면 편리하게 사용할 수 있습니다.</p><pre><code class="language-js">"scripts": {  "test": "jest"}</code></pre><h3 id="React-js를-테스트한다"><a href="#React-js를-테스트한다" class="headerlink" title="React.js를 테스트한다."></a>React.js를 테스트한다.</h3><p>Jest의 <a href="https://facebook.github.io/jest/docs/tutorial-react.html" target="_blank" rel="noopener">Tutorial – React</a> 문서에 React.js를 사용한 애플리케이션을 테스트하는 경우도 작성돼 있습니다. 테스트하기 위해서는 두 가지 설정을 할 필요가 있습니다.</p><h4 id="JSX의-변환"><a href="#JSX의-변환" class="headerlink" title="JSX의 변환"></a>JSX의 변환</h4><p>JSX를 사용해 애플리케이션을 작성한 경우에는 테스트를 위해 JSX를 변환할 필요가 있습니다. package.json의 Jest 프로퍼티에 scriptPreprocessor로 사전에 동작해야할 script를 지정합니다.</p><pre><code class="language-js">// package.json"jest": {  "scriptPreprocessor": "preprocessor.js"},// preprocessor.jsvar ReactTools = require('react-tools');module.exports = {  process: function(src) {    return ReactTools.transform(src, {harmony: true});  }};</code></pre><h3 id="Mock의-해제"><a href="#Mock의-해제" class="headerlink" title="Mock의 해제"></a>Mock의 해제</h3><p>위에서 언급한 것처럼 Jest에서는 모든 require 구문이 Mock을 반환합니다. 단, React도 Mock으로 대체되면 테스트할 수 없으므로 react를 Mock으로 대체하지 않도록 경로를 설정할 필요가 있습니다. 이러한 설정도 package.json에 속성을 추가하는 것으로 간단하게 할 수 있습니다. 테스트 파일에서도 Mock하지 않을 파일을 지정할 수 있지만, 만약 모든 테스트에서 Mock 하고 싶지 않은 파일이 있다면 아래와 같이 작성합니다.</p><pre><code class="language-jsx">"jest": {  "scriptPreprocessor": "preprocessor.js",  "unmockedModulePathPatterns": ["node_modules/react"]},</code></pre><h3 id="테스트-작성해보기"><a href="#테스트-작성해보기" class="headerlink" title="테스트 작성해보기"></a>테스트 작성해보기</h3><p>아래와 비슷한 느낌으로 React 컴포넌트의 테스트를 작성할 수 있습니다.(<a href="https://github.com/koba04/react-boilerplate/blob/master/app/components/__tests__/InputArtistTest.js" target="_blank" rel="noopener">참고</a>)</p><pre><code class="language-jsx">jest.dontMock('../InputArtist'); var React = require('react/addons'),    InputArtist = require('../InputArtist'),    AppTracksActionCreators = require('../../actions/AppTracksActionCreators'); describe('inputArtist', function() {  var inputArtist;  beforeEach(function() {    inputArtist = React.addons.TestUtils.renderIntoDocument(&lt;InputArtist /&gt;);  });   describe('state',  function() {    it('set inputArtist radiohead', function() {      expect(inputArtist.state.inputArtist).toBe('radiohead');    });  });   describe('handleSubmit', function() {    var preventDefault;    beforeEach(function() {      preventDefault = jest.genMockFunction();      inputArtist.setState({ inputArtist: 'travis' });      React.addons.TestUtils.Simulate.submit(inputArtist.getDOMNode(), {        preventDefault: preventDefault      });    });    it ('calls AppTracksActionCreators.fetchByArtist with state.inputArtist', function() {      expect(AppTracksActionCreators.fetchByArtist).toBeCalled();      expect(AppTracksActionCreators.fetchByArtist).toBeCalledWith('travis');    });    it ('calls e.preventDefault', function() {      expect(preventDefault).toBeCalled();    });  });});</code></pre>        <figure title="Jest 동작 테스트">          <img src="/assets/img/2015/learning-react-6/react_test.01.gif" alt="Jest 동작 테스트" style="">          <figcaption>&lt;그림 1 Jest 동작 테스트&gt;</figcaption>        </figure>    <p>그럼 코드를 자세히 살펴보겠습니다.</p><pre><code class="language-js">jest.dontMock('../InputArtist');</code></pre><p>Mock으로 대체할 필요가 없는 module은 dontMock에 명시적으로 지정합니다.</p><pre><code class="language-js">var React = require('react/addons'),    InputArtist = require('../InputArtist'),    AppTracksActionCreators = require('../../actions/AppTracksActionCreators');</code></pre><p>React는 package.json의 unmockedModulePathPatterns의 지정했으므로 Mock으로 대체되지 않습니다. 그 외 다른 모듈은 Mock으로 대체됩니다.</p><pre><code class="language-jsx">describe('inputArtist', function() {  var inputArtist;  beforeEach(function() {    inputArtist = React.addons.TestUtils.renderIntoDocument(&lt;InputArtist /&gt;);  });   describe('state',  function() {    it('set inputArtist radiohead', function() {      expect(inputArtist.state.inputArtist).toBe('radiohead');    });  });</code></pre><p>이 코드는 보통의 Jasmine 테스트 코드와 같습니다. React.addons.TestUtils.renderIntoDocument를 사용하여 Component를 DOM에 붙여서 테스트하고 있습니다.</p><pre><code class="language-jsx">describe('handleSubmit', function() {  var preventDefault;  beforeEach(function() {    preventDefault = jest.genMockFunction();    inputArtist.setState({ inputArtist: 'travis' });    React.addons.TestUtils.Simulate.submit(inputArtist.getDOMNode(), {      preventDefault: preventDefault    });  });  it ('calls AppTracksActionCreators.fetchByArtist with state.inputArtist', function() {    expect(AppTracksActionCreators.fetchByArtist).toBeCalled();    expect(AppTracksActionCreators.fetchByArtist).toBeCalledWith('travis');  });  it ('calls e.preventDefault', function() {    expect(preventDefault).toBeCalled();  });</code></pre><p>위는 submit 버튼이 클릭 됐을 때 fetchByArtist와 e.preventDefault가 호출되는지 테스트하는 코드입니다. React.addons.TestUtils.Simulate.submit를 사용해 submit 이벤트를 발생시켜 이벤트 객체의  jest.genMockFunction 생성한 preventDefault Mock 함수을 통해서 호출됐지 확인합니다. fetchByArtist는 실제로 Ajax 요청을 하지만 Jest가 Mock으로  대체했으므로 특별히 의식하지 않고 간단하게 테스트를 작성할 수 있습니다.</p><h3 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h3><p>Mock은 jest.genMockFunction과 같은 API로 직접 만드는 것도 가능하며 mock property에 calls나 instances 등의 호출 정보가 기록되므로 이 기록을 사용해 테스트를 작성할 수 있습니다. 또, Mock Function의 mockReturnValue를 사용해 지정한 값을 반환하도록 할 수 있고 mockimplementation에 callback을 전달하는 것으로 직접 Mock을 구현할 수도 있습니다.</p><h4 id="Mock-Assert"><a href="#Mock-Assert" class="headerlink" title="Mock Assert"></a>Mock Assert</h4><p>Mock을 확인하기 위한 assert도 준비돼 있습니다. expect(mockFunc).toBeCalled와 같이 테스트를 작성할 수 있습니다.</p><h4 id="module-교체"><a href="#module-교체" class="headerlink" title="module 교체"></a>module 교체</h4><p><strong>mocks</strong> 디렉터리를 생성하여 그 안에 module 구현을 작성하는 하면 테스트 시 모듈 자체를 항상 대체할 수 있습니다. superagent를 Mock으로 대체하면 에러가 발생하는 이슈가 있는데, 이를 방지하기 위해 <a href="https://github.com/koba04/react-boilerplate/blob/master/app/actions/__mocks__/superagent.js" target="_blank" rel="noopener"><strong>mocks</strong>/superagent.js</a>에서 workaround로 Mock을 두고 있습니다.</p><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>setTimeout이나 setInterval을 사용하는 구현을 테스트하는 경우 jset.runAllTimers나 jset.runOnlyPendingTimers를 사용하여 동기적으로 테스트를 작성할 수 있습니다. runAllTimers는 setTimeout이나 setInterval 큐에 존재하는 모든 태스크를 실행하고 runOnlyPendingTimers는 호출한 시점에서 대기중인 태스크만 실행합니다. setTimeout으로 반복하고 있는 구현의 경우 runAllTimers를 사용하면 무한 루프에 빠지므로 runOnlyPendingTimers를 사용해 한 번에 하나씩 테스트를 진행하도록 작성합니다.</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>API는 공식 홈페이지의 <a href="https://facebook.github.io/jest/docs/api.html#content" target="_blank" rel="noopener">API Reference</a>에 정리돼 있습니다. 여기에서 전부 소개하진 않지만 여러 상황에 대응한 API를 제공하고 있음을 알 수 있습니다.</p><h3 id="불편한-점"><a href="#불편한-점" class="headerlink" title="불편한 점"></a>불편한 점</h3><p>이것저것 설정하여 해결할 수 있을지 모르지만, Karma와 비교할 때 상대적으로 테스트 실행이 느립니다. 이슈(<a href="https://github.com/facebook/jest/issues/116" target="_blank" rel="noopener">issues/116</a>)로도 등록돼 있으므로 빨리 개선되길 바랍니다.</p><p>여기까지 Jest를 소개하겠습니다. 다음 절에서는 Flux를 소개하겠습니다.</p><h2 id="React-js와-Flux"><a href="#React-js와-Flux" class="headerlink" title="React.js와 Flux"></a>React.js와 Flux</h2><p>이번에는 React.js와 관계가 깊은 <a href="http://facebook.github.io/flux/" target="_blank" rel="noopener">Flux</a>를 소개하겠습니다.</p><h3 id="Flux-is-Architecture"><a href="#Flux-is-Architecture" class="headerlink" title="Flux is Architecture"></a>Flux is Architecture</h3>        <figure title="Flux 아키텍처">          <img src="/assets/img/2015/learning-react-6/react_flux.01.png" alt="Flux 아키텍처" style="">          <figcaption>&lt;그림 2 Flux 아키텍처&gt;</figcaption>        </figure>    <p>위는 깃-허브 저장소에 명시된 그림입니다. Flux는 위와 같은 아키텍처의 명칭이기도 합니다. 조금 더 살펴보면 알겠지만, Dispatcher 부분만 구현하고 있습니다.</p><h3 id="Unidirectional-data-flow"><a href="#Unidirectional-data-flow" class="headerlink" title="Unidirectional data flow"></a>Unidirectional data flow</h3><p>위 아키텍처를 보면 알 수 있듯이 Flux는 애플리케이션의 복잡함을 없애기 위해서 데이터의 흐름을 단방향 운영합니다. 이런 방식은 전체적인 처리 흐름을 알기 쉽지만 Angular.js 등과 비교했을 때 상대적으로 표현이나 문법이 장황한 느낌이 있습니다. 그렇지만 데이터의 흐름을 단순하게 만드는 것으로 애플리케이션의 규모가 커져 복잡화돼도 데이터나 이벤트의 흐름이 엉키지 않고 파악하기 쉬운 구조를 유지할 수 있다고 합니다. (실제로 Flux를 사용해 대규모 애플리케이션을 구현해보지 않아서 단언할 순 없습니다)</p><p>자, 그럼 <a href="https://github.com/koba04/react-boilerplate" target="_blank" rel="noopener">react-boilerplate</a>를 예제를 사용해 본격적으로 Flux를 소개하겠습니다.</p><h3 id="Flux의-구성-요소"><a href="#Flux의-구성-요소" class="headerlink" title="Flux의 구성 요소"></a>Flux의 구성 요소</h3><h4 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h4><p>Flux에서는 각 요소 간 주고 받을 타입을 상수처럼 정의합니다.</p><pre><code class="language-js">var keyMirror = require('react/lib/keyMirror'); module.exports = {  ActionTypes: keyMirror({    RECEIVE_TRACKS_BY_ARTIST: null,    RECEIVE_TRACKS_BY_COUNTRY: null  }),  PayloadSources: keyMirror({    VIEW_ACTION: null  })};</code></pre><p>참고로 keyMirror는 key를 사용해 value로 설정해주는 Util 입니다.</p><h4 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h4><p>Dispatcher는 Action을 받아 등록된 callback을 실행합니다. 여기에서는 facebook/flux가 유일하게 제공하고 있는 Dispatcher를 확장하는 느낌으로 오브젝트를 생성해 싱들톤으로 반환합니다. 여기에서는 ActionCreators부터 Dispatcher에 Acton을 던지기 위한 handleViewAction을 정의하고 있습니다.</p><pre><code class="language-js">var Dispatcher    = require('flux').Dispatcher,    assign        = require('object-assign'),    AppConstants  = require('../constants/AppConstants'); var PayloadSources = AppConstants.PayloadSources; module.exports = assign(new Dispatcher(), {  handleViewAction: function(action) {    this.dispatch({      source: PayloadSources.VIEW_ACTION,      action: action    });  }});</code></pre><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>Store는 애플리케이션의 데이터와 비즈니스 로직을 담당합니다. Store에서 담당하는 데이터는 메시지 목록과 같은 집합도 다룹니다.</p><pre><code class="language-js">var AppDispatcher = require('../dispatcher/AppDispatcher'),    AppConstants  = require('../constants/AppConstants'),    EventEmitter  = require('events').EventEmitter,    assign        = require('object-assign'); var ActionTypes = AppConstants.ActionTypes;var CHANGE_EVENT = 'change';var tracks = []; var TrackStore = assign({}, EventEmitter.prototype, {   emitChange: function() {    this.emit(CHANGE_EVENT);  },  addChangeListener: function(callback) {    this.on(CHANGE_EVENT, callback);  },  removeChangeListener: function(callback) {    this.removeListener(CHANGE_EVENT, callback);  },  getAll: function() {    return tracks;  },}); TrackStore.dispatchToken = AppDispatcher.register(function(payload) {  var action = payload.action;   switch (action.type) {    case ActionTypes.RECEIVE_TRACKS_BY_ARTIST:      tracks = action.tracks;      TrackStore.emitChange();      break;    case ActionTypes.RECEIVE_TRACKS_BY_COUNTRY:      tracks = action.tracks;      TrackStore.emitChange();      break;  }}); module.exports = TrackStore;</code></pre><p>여기에서 눈여겨 봐야 할 포인트는 다음과 같습니다.</p><ul><li>getter 메서드만 정의하여 외부에서 데이터에 접근할 수 없는 형태로 유지합니다.</li><li>데이터의 갱신은 ActionCreator에서 Despatcher에 전달하여 등록한 callback 함수를 호출하여 실시합니다.</li><li>Dispatcher에 callback을 등록하여 처리 할 수 있도록 합니다.</li><li>Store는 EventEmiiter의 기능을 가지고 있어 데이터가 갱신되면 이벤트를 발행합니다.</li><li>View는 Store의 이벤트를 구독합니다.</li></ul><h4 id="ActionCreators-Action"><a href="#ActionCreators-Action" class="headerlink" title="ActionCreators (Action)"></a>ActionCreators (Action)</h4><p>Action을 생성해 Dispatcher에 전달합니다. 이 문서의 예제에서는 Ajax 요청도 ActionCreators 내에서 담당하고 있지만 facebook/flux의 예제에서는 Utils 이라고 하는 네임스페이스를 만들어 그 안에서 담당하도록 디자인돼 있습니다. Ajax이 끝난 시점뿐만 아니라 시작한 시점에도 Action을 발생시켜 로딩하는 View를 출력할 수도 있을 것 같습니다.</p><pre><code class="language-js">var request = require('superagent'),    AppDispatcher = require('../dispatcher/AppDispatcher'),    AppConstants  = require('../constants/AppConstants'); var ActionTypes = AppConstants.ActionTypes;var urlRoot = 'http://ws.audioscrobbler.com/2.0/?api_key=xxxx&format=json&'; // TODO Loadingmodule.exports = {  fetchByArtist: function(artist) {    request.get(      urlRoot + 'method=artist.gettoptracks&artist=' + encodeURIComponent(artist),      function(res) {        AppDispatcher.handleViewAction({          type: ActionTypes.RECEIVE_TRACKS_BY_ARTIST,          tracks: res.body.toptracks.track        });      }.bind(this)    );  },  fetchByCountry: function(country) {    request.get(      urlRoot + 'method=geo.gettoptracks&country=' + encodeURIComponent(country),      function(res) {        AppDispatcher.handleViewAction({          type: ActionTypes.RECEIVE_TRACKS_BY_ARTIST,          tracks: res.body.toptracks.track        });      }.bind(this)    );  }};</code></pre><p>Action은 아래와 같은 형태의 리터럴 객체입니다.</p><pre><code class="language-js">{  type: ActionTypes.RECEIVE_TRACKS_BY_ARTIST,  tracks: res.body.toptracks.track}</code></pre><h4 id="View-ReactComponent"><a href="#View-ReactComponent" class="headerlink" title="View (ReactComponent)"></a>View (ReactComponent)</h4><p>데이터를 출력하는 View와 Action을 발생하는 View를 나누어서 소개하겠습니다.</p><h5 id="Store의-데이터를-출력하는-컴포넌트"><a href="#Store의-데이터를-출력하는-컴포넌트" class="headerlink" title="Store의 데이터를 출력하는 컴포넌트"></a>Store의 데이터를 출력하는 컴포넌트</h5><p>View에서는 componentDidMount로 Store의 change 이벤트를 구독하고 componentWillUnmount에서 구독을 해제하고 있습니다. change 이벤트가 발행되면 Store에서 다시 데이터를 가져와 setState에 설정합니다. 여기에서 Store 데이터는 동기적으로 취득할 수 있다고 전제하고 있습니다.</p><pre><code class="language-jsx">module.exports = React.createClass({  getInitialState() {    return {      tracks: TrackStore.getAll(),    };  },  componentDidMount: function() {    TrackStore.addChangeListener(this.&lt;onChange);  },  componentWillUnmount: function() {    TrackStore.removeChangeListener(this.&lt;onChange);  },  &lt;onChange: function() {    this.setState({ tracks: TrackStore.getAll() });  },  render() {    var tracks = this.state.tracks.map( (track, index) =&gt; {      return (        &lt;li className="list-group-item" key={index}&gt;          &lt;span className="label label-info"&gt;{index+1}&lt;/span&gt;          &lt;a href={track.url} target="&lt;blank"&gt;&lt;span className="track"&gt;{track.name}&lt;/span&gt;&lt;/a&gt;          &lt;span className="artist"&gt;{track.artist.name}&lt;/span&gt;          &lt;small className="listeners glyphicon glyphicon-headphones"&gt;{track.listeners}&lt;/small&gt;        &lt;/li&gt;      );    });    return (      &lt;div className="tracks"&gt;        &lt;ul className="list-group"&gt;          {tracks}        &lt;/ul&gt;      &lt;/div&gt;    );  }});</code></pre><h5 id="Action을-발생시키는-컴포넌트"><a href="#Action을-발생시키는-컴포넌트" class="headerlink" title="Action을 발생